{
  "subjects": [
    {
      "SubjectID": 1,
      "SubjectName": "OCP19C082",
      "questions": [
       {
      "QuestionID": 1,
      "QuestionType": "multiple",
      "QuestionText": "You execute this command: Sufficient storage is available in filesystem /u01. Which two statements are true about the BIG_TBS tablespace? (Choose two)",
      "ImageURL": "images/q1.png",
      "Options": [
        {"label": "A","text": "AUTOEXTEND is possible for the datafile"},
        {"label": "B","text": "It must be bigger than the largest SMALLFILE tablespace"},
        {"label": "C","text": "Additional data files may not be added"},
        {"label": "D","text": "It will be a dictionary-managed tablespace by default"},
        {"label": "E","text": "It will always have a 32K block size"}
      ],
      "CorrectAnswer": ["A", "C"],
      "Explanation": "1.单文件：只能有一个数据文件。 2.可大：单文件可以非常大（TB 级别）。 3.可扩展：支持 AUTOEXTEND。 4.默认 LMT：locally managed tablespace，而不是 dictionary-managed。 5.块大小可选：不是固定 32K。"
    },
    {
    "QuestionID": 2,
    "QuestionType": "single",
    "QuestionText": "Which statement is true about the INTERSECT operator used in compound queries?",
    "ImageURL": "",
    "Options": [
      {"label": "A","text": "Multiple INTERSECT operators are not possible in the same SQL statement"},
      {"label": "B","text": "It processes NULLs in the selected columns"},
      {"label": "C","text": "INTERSECT is of lower precedence than UNION or UNION ALL"},
      {"label": "D","text": "It ignores NULLs"}
    ],
    "CorrectAnswer": ["B"],
    "Explanation": ""
  },
  {
    "QuestionID": 3,
    "QuestionType": "multiple",
    "QuestionText": "Which three statements are true about advanced connection options supported by Oracle Net for connection to Oracle Database instances? (Choose three)",
    "ImageURL": "",
    "Options": [
      {"label": "A","text": "Connect Time Failover requires the use of Transparent Application Failover (TAF)"},
      {"label": "B","text": "Source Routing requires the use of a name server"},
      {"label": "C","text": "Source Routing enables the use of Connection Manager (CMAN) which enables network traffic to be routed through a firewall"},
      {"label": "D","text": "Load Balancing can balance the number of connections to dispatchers when using a Shared Server configuration"},
      {"label": "E","text": "Load Balancing requires the use of a name server"},
      {"label": "F","text": "Connect Time Failover requires the connect string to have two or more listener addresses configured"}
    ],
    "CorrectAnswer": ["C", "D", "F"],
    "Explanation": "Connect-Time Failover 当客户端尝试连接时，如果第一个监听器（Listener）或主机不可用，Oracle Net 会自动尝试下一个地址。也就是在“连接阶段”发生故障切换。只在连接时生效（不是运行时）。不需要 Transparent Application Failover（TAF）。必须在连接字符串中配置两个或以上的 listener 地址。TAF 是一种运行时故障切换机制，当数据库连接中断时，客户端会自动尝试重连到另一节点或实例。由服务器端或客户端配置。可在重连后重新执行查询（SELECT）。常用于 RAC（Real Application Cluster）环境中。Load Balancing 在多个可用的数据库监听器或实例之间，Oracle 可以自动分配客户端连接，以平衡负载。Client-side Load Balancing 客户端随机选择一个监听地址连接。Server-side Load Balancing 由监听器根据当前负载把连接分配给最空闲的实例或 dispatcher，不需要 Name Server，IP 地址即可。通常与 Connect-Time Failover 一起使用。"
  },
  {
    "QuestionID": 4,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about date/time functions in a session where NLS_DATE_FORMAT is set to DD-MON-YYYY HH24:MI:SS? (Choose two)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "CURRENT_TIMESTAMP returns the same date and time as SYSDATE with additional details of fractional seconds" },
      { "label": "B", "text": "SYSDATE can be queried only from the DUAL table" },
      { "label": "C", "text": "CURRENT_DATE returns the current date and time as per the session time zone" },
      { "label": "D", "text": "SYSDATE can be used in expressions only if the default date format is DD-MON-RR" },
      { "label": "E", "text": "SYSDATE and CURRENT_DATE return the current date and time set for the operating system of the database server" },
      { "label": "F", "text": "CURRENT_TIMESTAMP returns the same date as CURRENT_DATE" }
    ],
    "CorrectAnswer": ["C", "F"],
    "Explanation": "1.服务器时间：用 SYS 开头的函数（SYSDATE、SYSTIMESTAMP） 2.会话时区时间：用 CURRENT_ 或 LOCAL 开头的函数 3.是否有小数秒：只有 TIMESTAMP 才有小数秒 4.是否带时区：只有 WITH TIME ZONE 的类型才带时区 5.格式显示：NLS_DATE_FORMAT 只影响显示，不影响计算 6.CURRENT_DATE vs SYSDATE：前者用会话时区，后者用服务器时区 7.CURRENT_TIMESTAMP vs CURRENT_DATE：日期部分相同，只是一个有小数秒和时区信息"
  },
  {
    "QuestionID": 5,
    "QuestionType": "single",
    "QuestionText": "A database is configured to use automatic undo management with temporary undo enabled. An UPDATE is executed on a temporary table. Where is the UNDO stored?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "in the undo tablespace" },
      { "label": "B", "text": "in the SYSAUX tablespace" },
      { "label": "C", "text": "in the SGA" },
      { "label": "D", "text": "in the PGA" },
      { "label": "E", "text": "in the temporary tablespace" }
    ],
    "CorrectAnswer": ["E"],
    "Explanation": ""
  },
  {
    "QuestionID": 6,
    "QuestionType": "single",
    "QuestionText": "You have been tasked to create a table for a banking application. One of the columns must meet three requirements: \n1.Be stored in a format supporting date arithmetic without using conversion functions. \n2.Store a loan period of up to 10 years 3.Be used for calculating interest for the number of days the loan remains unpaid. \nWhich data type should you use?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "INTERVAL YEAR TO MONTH" },
      { "label": "B", "text": "INTERVAL DAY TO SECOND" },
      { "label": "C", "text": "TIMESTAMP WITH LOCAL TIMEZONE" },
      { "label": "D", "text": "TIMESTAMP" },
      { "label": "E", "text": "TIMESTAMP WITH TIMEZONE" }
    ],
    "CorrectAnswer": ["B"],
    "Explanation": ""
  },
  {
    "QuestionID": 7,
    "QuestionType": "single",
    "QuestionText": "Which statement is true?\nIn the spfile of a single instance database, LOCAL_LISTENER is set to LISTENER_1. The TNSNAMES.ORA file in $ORACLE_HOME/network/admin in the database home contains:",
    "ImageURL": "images/q7.png",
    "Options": [
      { "label": "A", "text": "Dynamic service registration cannot be used for this database instance" },
      { "label": "B", "text": "The LREG process registers services dynamically with the LISTENER_1 listener" },
      { "label": "C", "text": "LISTENER_1 must also be defined in the LISTENER.ORA file to enable dynamic service registration" },
      { "label": "D", "text": "There are two listeners named LISTENER and LISTENER_1 running simultaneously using port 1521 on the same host as the database instances" },
      { "label": "E", "text": "The definition for LISTENER_1 requires a CONNECT_DATA section to enable dynamic service Registration" }
    ],
    "CorrectAnswer": ["B"],
    "Explanation": "1.监听器 ≠ 数据库实例 2.PMON+LREG 自动注册数据库服务到监听器 3.LOCAL_LISTENER 控制注册到哪个监听器 4.TNSNAMES.ORA 仅是名字解析，帮助 PMON 或客户端找到监听器地址 5.LISTENER.ORA 配置监听器自身（端口、协议）"
  },
  {
    "QuestionID": 8,
    "QuestionType": "multiple",
    "QuestionText": "Which three statements are true concerning logical and physical database structures? (Choose three)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "All tablespaces may have one or more data files" },
      { "label": "B", "text": "The extents of a segment must always reside in the same datafile" },
      { "label": "C", "text": "A smallfile tablespace might be bigger than a bigfile tablespace" },
      { "label": "D", "text": "A segment can span multiple data files in some tablespaces" },
      { "label": "E", "text": "A segments blocks can be of different sizes" },
      { "label": "F", "text": "A segment might have only one extent" },
      { "label": "G", "text": "Segments can span multiple tablespsaces" }
    ],
    "CorrectAnswer": ["C", "D", "F"],
    "Explanation": "1.每个 datafile 只属于一个 tablespace。tablespace可以有多个 datafile（smallfile）或只有一个（bigfile） 2.一个 Segment 可以跨多个 datafile（多个 extent 分布在不同文件） 3.一个 Extent 必须在同一个 datafile 中 4.一个 Block 是最小单元8kb"
  },
  {
    "QuestionID": 9,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true regarding a SAVEPOINT? (Choose two)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Rolling back to a SAVEPOINT can undo a CREATE INDEX statement" },
      { "label": "B", "text": "Rolling back to a SAVEPOINT can undo a TRUNCATE statement" },
      { "label": "C", "text": "Only one SAVEPOINT may be issued in a transaction" },
      { "label": "D", "text": "A SAVEPOINT does not issue a COMMIT" },
      { "label": "E", "text": "Rolling back to a SAVEPOINT can undo a DELETE statement" }
    ],
    "CorrectAnswer": ["D", "E"],
    "Explanation": "1.ROLLBACK TO savepoint 之后，事务仍然继续，你可以继续做修改、再创建 savepoint 或 COMMIT。 2.COMMIT 会清除所有 savepoints。 3.CREATE INDEX、TRUNCATE 等是 DDL 并且通常会引起隐式 COMMIT，一旦执行了这些语句，ROLLBACK TO savepoint 不能撤销它们。"
  },
  {
    "QuestionID": 10,
    "QuestionType": "multiple",
    "QuestionText": "Which three functions are performed by dispatchers in a shared server configuration? (Choose three)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "writing inbound request to the common request queue from all shared server connections" },
      { "label": "B", "text": "checking for outbound shared server responses on the common outbound response queue" },
      { "label": "C", "text": "receiving inbound requests from processes using shared server connections" },
      { "label": "D", "text": "sending each connection input request to the appropriate shared server input queue" },
      { "label": "E", "text": "broadcasting shared server session responses back to requesters on all connections" },
      { "label": "F", "text": "sending shared server session responses back to requesters on the appropriate connection" }
    ],
    "CorrectAnswer": ["A", "D", "F"],
    "Explanation": "1.Dispatcher：客户端请求入口 → 写入 CRQ → 从 Response Queue 取结果 → 发回客户端。 2.Shared Server：从 CRQ 获取请求 → 执行 SQL → 写入 Response Queue。 3.Queues：CRQ 是共享请求队列，Response Queue 每个会话有独立队列。"
  },
  {
    "QuestionID": 11,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about the SET VERIFY ON command? (Choose two)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "It can be used only in SQL*Plus" },
      { "label": "B", "text": "It displays values for variables used only in the WHERE clause of a query" },
      { "label": "C", "text": "It can be used in SQL Developer and SQL*Plus" },
      { "label": "D", "text": "It displays values for variables created by the DEFINE command" },
      { "label": "E", "text": "It displays values for variables prefixed with &&" }
    ],
    "CorrectAnswer": ["C", "D"],
    "Explanation": "1.SET VERIFY 开 → 打开显示变量替换前后的 SQL。 2.SQL old new 显 → 显示 old（替换前）和 new（替换后）SQL。 3.& 每次问 → &var 每次使用都会提示输入。 4.&& 首次存 → &&var 第一次输入后保存，后续不再提示。 5.DEFINE 定值全显示 → DEFINE var = 值 创建的变量也会显示替换结果。"
  },
  {
    "QuestionID": 12,
    "QuestionType": "multiple",
    "QuestionText": "Which three statements are true about a self-join? (Choose three)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "The ON clause must be used" },
      { "label": "B", "text": "The query must use two different aliases for the table" },
      { "label": "C", "text": "It must be an equi join" },
      { "label": "D", "text": "It must be an inner join" },
      { "label": "E", "text": "The ON clause can be used" },
      { "label": "F", "text": "It can be an outer join" }
    ],
    "CorrectAnswer": ["B", "E", "F"],
    "Explanation": "1.自连接（Self-Join）是让同一张表与自己进行连接，用于比较、匹配、查找同表中不同行之间的关系。通常用于层级关系（员工-经理）、行间比较（工资高低）等 2.必须给同一张表取不同的别名，否则 SQL 无法区分两份数据来源。FROM employees e JOIN employees m ... 3.自连接可以是 INNER JOIN 或 OUTER JOIN，不局限于某一种。比如 LEFT JOIN 用来保留没有上级的员工（如 CEO） 4.自连接的连接条件既可以是 等值连接（equi join），也可以是 非等值连接（non-equi join）。例如 e1.salary > e2.salary 也是自连接 5.ON 子句是可选的，常见于显式 JOIN 语法中，但旧式语法也可以用 WHERE。"
  },
  {
    "QuestionID": 13,
    "QuestionType": "single",
    "QuestionText": "You want to write a query that prompts for two column names and the WHERE condition each time it is executed in a session but only prompts for the table name the first time it is executed. The variables used in your query are never undefined in your session. Which query can be used?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "SELECT &&col1, &&col2 FROM &table WHERE &&condition = &&cond;" },
      { "label": "B", "text": "SELECT &col1, &col2 FROM &&table WHERE &condition;" },
      { "label": "C", "text": "SELECT &col1, &col2 FROM '&table' WHERE &condition;" },
      { "label": "D", "text": "SELECT '&&col1', '&&col2' FROM &table WHERE '&&condition' = '&cond';" },
      { "label": "E", "text": "SELECT &&col1, &&col2 FROM &table WHERE &&condition;" }
    ],
    "CorrectAnswer": ["B"],
    "Explanation": ""
  },
  {
    "QuestionID": 14,
    "QuestionType": "single",
    "QuestionText": "Examine the description of the CUSTOMERS table: You want to display details of all customers who reside in cities starting with the letter D followed by at least two characters. Which query can be used?",
    "ImageURL": "images/q14.png",
    "Options": [
      { "label": "A", "text": "SELECT * FROM customers WHERE city LIKE 'D_%';" },
      { "label": "B", "text": "SELECT * FROM customers WHERE city = '%D_';" },
      { "label": "C", "text": "SELECT * FROM customers WHERE city LIKE 'D_';" },
      { "label": "D", "text": "SELECT * FROM customers WHERE city = 'D_%';" }
    ],
    "CorrectAnswer": ["A"],
    "Explanation": ""
  },
  {
    "QuestionID": 15,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true? (Choose two)",
    "ImageURL": "images/q15.png",
    "Options": [
      { "label": "A", "text": "DML may be performed on tables with one or more extents in this data file during the execution of this command." },
      { "label": "B", "text": "The tablespace containing SALES1.DBF must be altered READ ONLY before executing the command." },
      { "label": "C", "text": "The tablespace containing SALES1.DBF must be altered OFFLINE before executing the command." },
      { "label": "D", "text": "If Oracle Managed Files (OMF) is used, then the file is renamed but moved to DB_CREATE_FILE_DEST." },
      { "label": "E", "text": "The file is renamed and stored in the same location" }
    ],
    "CorrectAnswer": ["A", "E"],
    "Explanation": "Oracle支持在线移动数据文件，这里的在线，意味着不用设置表空间为只读，也不影响数据文件里的表的DML语句，所以A对BC错；reuse参数表明重用原来的数据文件，只是改了名字。所以E对D错。"
  },
  {
    "QuestionID": 16,
    "QuestionType": "multiple",
    "QuestionText": "Which three statements are true about dropping and unused columns in an Oracle database?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "A primary key column referenced by another column as a foreign key can be dropped if using the CASCADE option." },
      { "label": "B", "text": "A DROP COLUMN command can be rolled back" },
      { "label": "C", "text": "An UNUSED column's space is reclaimed automatically when the block containing that column is next queried" },
      { "label": "D", "text": "An UNUSED column's space is reclaimed automatically when the row containing that column is next queried." },
      { "label": "E", "text": "Partition key columns cannot be dropped." },
      { "label": "F", "text": "A column that is set to UNUSED still counts towards the limit of 1000 columns per table." }
    ],
    "CorrectAnswer": ["A", "E", "F"],
    "Explanation": "1.DROP COLUMN（删除列）真正从表中删除列，包括数据和元数据。是 DDL 操作，会自动提交，不能回滚。可以使用 CASCADE CONSTRAINT,分区键列（Partition Key）不能删除。 2.SET UNUSED（标记列为 UNUSED）将列标记为 UNUSED，使列名不可见，但数据仍在表中。快速，不需要重写整个表。数据仍占用空间。UNUSED 列仍计入表的最大列数（1000 列/表）。不会立即释放空间可以通过 ALTER TABLE DROP UNUSED COLUMNS 真正删除列并释放空间。"
  },
  {
    "QuestionID": 17,
    "QuestionType": "multiple",
    "QuestionText": "Which three statements are true about using an invisible column in the PRODUCTS table?",
    "ImageURL": "images/q17.png",
    "Options": [
      { "label": "A", "text": "The %ROWTYPE attribute declarations in PL/SQL to access a row will not display the invisible column in the output." },
      { "label": "B", "text": "The DESCRIBE commands in SQL*Plus will not display the invisible column in the output." },
      { "label": "C", "text": "Referential integrity constraint cannot be set on the invisible column." },
      { "label": "D", "text": "The invisible column cannot be made visible and can only be marked as unused." },
      { "label": "E", "text": "A primary key constraint can be added on the invisible column." }
    ],
    "CorrectAnswer": ["A", "B", "E"],
    "Explanation": ""
  },
  {
    "QuestionID": 18,
    "QuestionType": "single",
    "QuestionText": "ALTER TABLE orders SET UNUSED (order_date);Which statement is true?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "After executing the ALTER TABLE command, you can add a new column called ORDER_DATE to the ORDERS table." },
      { "label": "B", "text": "The ORDER_DATE column should be empty for the ALTER TABLE command to execute successfully." },
      { "label": "C", "text": "ROLLBACK can be used to get back the ORDER_DATE column in the ORDERS table." },
      { "label": "D", "text": "The DESCRIBE command would still display the ORDER_DATE column." }
    ],
    "CorrectAnswer": ["A"],
    "Explanation": ""
  },
  {
    "QuestionID": 19,
    "QuestionType": "single",
    "QuestionText": "ALTER TABLE hr.emp SET UNUSED (mgr_id); Which statement is true regarding the effect of the above SQL statement?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Any views created on the EMP table that include the MGR_ID column would be automatically modified and remain valid." },
      { "label": "B", "text": "Any constraints defined on the MGR_ID column would be removed by the above command." },
      { "label": "C", "text": "Any synonym existing on the EMP table would have to be re-created." },
      { "label": "D", "text": "Any index created on the MGR_ID column would continue to exist until the DROP UNUSED COLUMNS command is executed." }
    ],
    "CorrectAnswer": ["B"],
    "Explanation": "列一旦被设置为 unused 以后，基于该列的约束、索引都被删除，同时相关的视图被无法访问，但是列的数据需要 drop column 时才会被删除"
  },
  {
    "QuestionID": 20,
    "QuestionType": "multiple",
    "QuestionText": "You execute the following command:SQL> ALTER TABLE departments SET UNUSED (country); Which two statements are true?",
    "ImageURL": "images/q20.png",
    "Options": [
      { "label": "A", "text": "A new column, COUNTRY, can be added to the DEPARTMENTS table after executing the command." },
      { "label": "B", "text": "Indexes created on the COUNTRY column exist until the DROP UNUSED COLUMNS command is executed." },
      { "label": "C", "text": "Unique key constraints defined on the COUNTRY column are removed." },
      { "label": "D", "text": "Synonyms existing on the DEPARTMENTS table would have to be re-created." },
      { "label": "E", "text": "Views created on the DEPARTMENTS table that include the COUNTRY column are automatically modified and remain valid." }
    ],
    "CorrectAnswer": ["A", "C"],
    "Explanation": "列一旦被设置为 unused 以后，基于该列的约束、索引都被删除，同时相关的视图被无法访问，但是列的数据需要 drop column 时才会被删除"
  },
  {
    "QuestionID": 21,
    "QuestionType": "multiple",
    "QuestionText": "Rows exist in this table with data in all the columns. You put the PRODUCTS table in read-only mode.Which three commands execute successfully on PRODUCTS?",
    "ImageURL": "images/q21.png",
    "Options": [
      { "label": "A", "text": "ALTER TABLE products DROP COLUMN expiry_date;" },
      { "label": "B", "text": "CREATE INDEX price_idx ON products (price);" },
      { "label": "C", "text": "ALTER TABLE products SET UNUSED (expiry_date);" },
      { "label": "D", "text": "TRUNCATE TABLE products;" },
      { "label": "E", "text": "ALTER TABLE products DROP UNUSED COLUMNS;" },
      { "label": "F", "text": "DROP TABLE products;" }
    ],
    "CorrectAnswer": ["B", "E", "F"],
    "Explanation": "当一个表被设置为 READ ONLY 时：1.不允许 DML 操作：INSERT, UPDATE, DELETE, TRUNCATE 2.不允许修改表结构：ALTER TABLE ... ADD / DROP / MODIFY COLUMN 3.可以创建或删除索引 4.可以删除整个表（DROP TABLE） 5.可以执行 SELECT"
  },
  {
    "QuestionID": 22,
    "QuestionType": "multiple",
    "QuestionText": "Choose three: Which three are true about dropping columns from a table?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "A column can be removed only if it contains no data." },
      { "label": "B", "text": "A column drop is implicitly committed." },
      { "label": "C", "text": "A column that is referenced by another column in any other table cannot be dropped." },
      { "label": "D", "text": "A column must be set as UNUSED before it is dropped from a table." },
      { "label": "E", "text": "A primary key column cannot be dropped." },
      { "label": "F", "text": "Multiple columns can be dropped simultaneously using the ALTER TABLE command." }
    ],
    "CorrectAnswer": ["B", "C", "F"],
    "Explanation": "所有DDL语句（包括 ALTER TABLE、DROP TABLE、CREATE TABLE 等）在Oracle中都会自动提交（implicitly committed）而且无法回滚（cannot be rolled back），主键解除constraints也可以drop"
  },
  {
    "QuestionID": 23,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true regarding Oracle database space management within blocks managed by Automatic Segment Space Management (ASSM)? (Choose two)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "PCTFREE defaults to 10% for all blocks in all segments for all compression methods." },
      { "label": "B", "text": "ASSM assigns blocks to one of four fullness categories based on what percentage of the block is allocated for rows." },
      { "label": "C", "text": "Update operations always attempt to find blocks with free space appropriate to the length of the row being updated." },
      { "label": "D", "text": "Insert operations always attempt to find blocks with free space appropriate to the length of the row being inserted." },
      { "label": "E", "text": "A block will always be eligible for inserts if the row is short enough to fit into the block." }
    ],
    "CorrectAnswer": ["A", "D"],
    "Explanation": "1. 自动分配，不用 FREELIST； 2. 仍看 PCTFREE，不用 PCTUSED； 3. 插入找块靠位图； 4. 更新太大迁移行； 5. 压缩表 PCTFREE = 0。"
  },
  {
    "QuestionID": 24,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about the ORD_ITEMS table and the ORD_SEQ sequence? (Choose two)",
    "ImageURL": "images/q24.png",
    "Options": [
      { "label": "A", "text": "If sequence ORD_SEQ is dropped then the default value for column ORD_NO will be NULL for rows inserted into ORD_ITEMS." },
      { "label": "B", "text": "Any user inserting rows into table ORD_ITEMS must have been granted access to sequence ORD_SEQ." },
      { "label": "C", "text": "Column ORD_NO gets the next number from sequence ORD_SEQ whenever a row is inserted into ORD_ITEMS and no explicit value is given for ORD_NO." },
      { "label": "D", "text": "Sequence ORD_SEQ cycles back to 1 after every 5000 numbers and can cycle 20 times." },
      { "label": "E", "text": "Sequence ORD_SEQ is guaranteed not to generate duplicate numbers." }
    ],
    "CorrectAnswer": ["B", "C"],
    "Explanation": "1. DEFAULT ord_seq.NEXTVAL 会在插入未赋值时调用 2. 想手动插入，必须有 SELECT 权限才能使用 NEXTVAL 3. 理解循环条件，不会因为 CACHE 而循环，和 maxvalue 有关 4. 删除序列 → 表默认值失效，插入报错，不会显示 null 5. 循环序列可能重复，不能绝对保证唯一"
  },
  {
    "QuestionID": 25,
    "QuestionType": "multiple",
    "QuestionText": "Which three instance situations are possible with the Oracle Database server without multi-tenant?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Two or more instances on separate servers all associated with one database." },
      { "label": "B", "text": "One instance on one server associated with one database." },
      { "label": "C", "text": "One instance on one server associated with two or more databases on the same server." },
      { "label": "D", "text": "One instance on one server not associated with any database." },
      { "label": "E", "text": "One instance on one server associated with two or more databases on separate servers." }
    ],
    "CorrectAnswer": ["A", "B", "D"],
    "Explanation": "两个或者多个实例都与同一个数据库关联，适合 RAC 的场景；相对的选项 B 适合单实例的场景；选项 D 适合实例和数据库不关联的场景，配置阶段或挂起阶段。"
  },
  {
    "QuestionID": 26,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about the ORDER BY clause when used with a SQL statement containing a SET operator such as UNION? (Choose two)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Column positions must be used in the ORDER BY clause." },
      { "label": "B", "text": "Only column names from the first SELECT statement in the compound query are recognized." },
      { "label": "C", "text": "The first column in the first SELECT of the compound query with the UNION operator is used by default to sort output in the absence of an ORDER BY clause." },
      { "label": "D", "text": "Each SELECT statement in the compound query must have its own ORDER BY clause." },
      { "label": "E", "text": "Each SELECT statement in the compound query can have its own ORDER BY clause." }
    ],
    "CorrectAnswer": ["B", "C"],
    "Explanation": "Using the ORDER BY Clause in Set Operations: 1. The ORDER BY clause can appear only once at the end of the compound query. 2. Component queries cannot have individual ORDER BY clauses. 3. The ORDER BY clause recognizes only the columns of the first SELECT query. 4. By default, the first column of the first SELECT query is used to sort the output in an ascending order"
  },
  {
    "QuestionID": 27,
    "QuestionType": "multiple",
    "QuestionText": "Valuate the following SQL statement: \nSQL> select cust_id, cust_last_name \"Last name\" \nFROM customers \nWHERE country_id = 10 \nUNION \nSELECT cust_id CUST_NO, cust_last_name \nFROM customers \nWHERE country_id = 30\nIdentify three ORDER BY clauses either one of which can complete the query.",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "ORDER BY 'Last name'" },
      { "label": "B", "text": "ORDER BY 2, cust_id" },
      { "label": "C", "text": "ORDER BY CUST_NO" },
      { "label": "D", "text": "ORDER BY 2, 1" },
      { "label": "E", "text": "ORDER BY 'CUST_NO'" }
    ],
    "CorrectAnswer": ["A", "B", "D"],
    "Explanation": ""
  },
  {
    "QuestionID": 28,
    "QuestionType": "multiple",
    "QuestionText": "Which four account management capabilities can be configured using Oracle profiles? (Choose four)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "The number of hours for which an account is locked after the configured number of login attempts has been reached." },
      { "label": "B", "text": "The number of days for which an account may be inactive before it is locked." },
      { "label": "C", "text": "The maximum amount of CPU time allowed for a user's sessions before their account is locked." },
      { "label": "D", "text": "The ability to prevent a password from ever being reused." },
      { "label": "E", "text": "The number of password changes required within a period of time before a password can be reused." },
      { "label": "F", "text": "The number of days for which an account is locked after the configured number of login attempts has been reached." },
      { "label": "G", "text": "The maximum number of sessions permitted for a user before the account is locked." }
    ],
    "CorrectAnswer": ["B", "D", "E", "F"],
    "Explanation": ""
  },
{
    "QuestionID": 29,
    "QuestionType": "single",
    "QuestionText": "Which statement is true about profiles?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Resource limits specified in a profile assigned to a user are always enabled" },
      { "label": "B", "text": "A profile can be assigned only to one user" },
      { "label": "C", "text": "A user can exist without any profile" },
      { "label": "D", "text": "Password management using profiles is always enabled" }
    ],
    "CorrectAnswer": ["D"],
    "Explanation": "Oracle 必须设置 RESOURCE_LIMIT = TRUE，资源限制才会生效；一个 profile 文件可以指定给多个用户，所以 B 错；任何 oracle 用户必然属于某一个 profile，未指定的话则属于 default，所以 C 错。D 是正确的，profile 里密码管理策略总是 enable 的"
  },
  {
    "QuestionID": 30,
    "QuestionType": "single",
    "QuestionText": "Which statement is true about the DEFAULT profile?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "It can be dropped and recreated" },
      { "label": "B", "text": "It must be explicitly assigned to a user" },
      { "label": "C", "text": "The values assigned to the resource limits and password parameters in the default profile can be altered" },
      { "label": "D", "text": "A different DEFAULT profile can be created for each user in a database" }
    ],
    "CorrectAnswer": ["C"],
    "Explanation": ""
  },
  {
    "QuestionID": 31,
    "QuestionType": "multiple",
    "QuestionText": "Which three are true about the effects of executing these statements?",
    "ImageURL": "images/q31.png",
    "Options": [
      { "label": "A", "text": "User HR is permitted to create more than three concurrent sessions" },
      { "label": "B", "text": "The password complexity will not be enforced on the HR account" },
      { "label": "C", "text": "Password complexity checking is enforced for user HR" },
      { "label": "D", "text": "The HR account will get locked by Oracle after ten consecutive failed login attempts" },
      { "label": "E", "text": "The HR account will be locked after three consecutive failed login attempts" },
      { "label": "F", "text": "User HR sessions will terminate after ten minutes of continuous inactivity" }
    ],
    "CorrectAnswer": ["A","C","E"],
    "Explanation": ""
  },
  {
    "QuestionID": 32,
    "QuestionType": "single",
    "QuestionText": "A user establishes a connection to a database instance by using an Oracle Net connection. You want to ensure the following: \n1. The user account must be locked after five unsuccessful login attempts. \n2. Data read per session must be limited for the user. \n3. The user cannot have more than three simultaneous sessions. \n4. The user must have a maximum of 10 minutes session idle time before being logged off automatically. \nHow would you accomplish this?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "By granting a secure application role to the user" },
      { "label": "B", "text": "By implementing Database Resource Manager" },
      { "label": "C", "text": "By using Oracle Label Security options" },
      { "label": "D", "text": "By assigning a profile to the user" }
    ],
    "CorrectAnswer": ["D"],
    "Explanation": ""
  },
  {
    "QuestionID": 33,
    "QuestionType": "single",
    "QuestionText": "You are administering a database and you receive a requirement to apply the following restrictions: \n1. A connection must be terminated after four unsuccessful login attempts by user. \n2. A user should not be able to create more than four simultaneous sessions. \n3. User session must be terminated after 15 minutes of inactivity. \n4. Users must be prompted to change their passwords every 15 days. \nHow would you accomplish these requirements?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "By granting a secure application role to the users" },
      { "label": "B", "text": "By creating and assigning a profile to the users and setting the REMOTE_OS_AUTHENT parameter to FALSE" },
      { "label": "C", "text": "By creating and assigning a profile to the users and setting the FAILED_LOGIN_ATTEMPTS parameter to 4" },
      { "label": "D", "text": "By implementing Fine-Grained Auditing (FGA) and setting the REMOTE_LOGIN_PASSWORD_FILE parameter to NONE" },
      { "label": "E", "text": "By implementing the Database Resource Manager plan and setting the SEC_MAX_FAILED_LOGIN_ATTEMPTS parameter to 4" }
    ],
    "CorrectAnswer": ["C"],
    "Explanation": ""
  },
  {
    "QuestionID": 34,
    "QuestionType": "single",
    "QuestionText": "In your database, you want to ensure that idle sessions that are blocking active are automatically terminated after a specified period of time. How would you accomplish this?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Setting a metric threshold" },
      { "label": "B", "text": "Implementing Database Resource Manager" },
      { "label": "C", "text": "Enabling resumable timeout for user sessions" },
      { "label": "D", "text": "Decreasing the value of the IDLE_TIME resource limit in the default profile" }
    ],
    "CorrectAnswer": ["B"],
    "Explanation": "DBRM ：“阻塞会话 + 活跃资源管理” IDLE_TIME：“单纯空闲时间限制” DLE_TIME 参数是指定超过了该时间不管有没有阻塞别人的会话，请求会话都会被 kill，但是题目的前提是阻塞了别人的会话，所有只有通过资源管理器才能够实现这一要求"
  },
  {
    "QuestionID": 35,
    "QuestionType": "multiple",
    "QuestionText": "Which three statements are true about single-row functions?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "They can be used only in the WHERE clause of a SELECT statement" },
      { "label": "B", "text": "The argument can be a column name, variable, literal or an expression" },
      { "label": "C", "text": "The data type returned can be different from the data type of the argument" },
      { "label": "D", "text": "They can be nested to any level" },
      { "label": "E", "text": "They can accept only one argument" },
      { "label": "F", "text": "They return a single result row per table" }
    ],
    "CorrectAnswer": ["B","C","D"],
    "Explanation": ""
  },
  {
    "QuestionID": 36,
    "QuestionType": "multiple",
    "QuestionText": "Which three statements are true regarding single-row functions?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "The data type returned can be different from the data type of the argument that is referenced" },
      { "label": "B", "text": "They can return multiple values of more than one data type" },
      { "label": "C", "text": "They can accept only one argument" },
      { "label": "D", "text": "They can be nested up to only two levels" },
      { "label": "E", "text": "They can be used in SELECT, WHERE, and ORDER BY clauses" },
      { "label": "F", "text": "They can accept column names, expressions, variable names, or user-supplied constants as arguments" }
    ],
    "CorrectAnswer": ["A","E","F"],
    "Explanation": ""
  },
  {
    "QuestionID": 37,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true regarding single row functions?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "MOD: returns the quotient of a division" },
      { "label": "B", "text": "TRUNC: can be used with NUMBER and DATE values" },
      { "label": "C", "text": "CONCAT: can be used to combine any number of values" },
      { "label": "D", "text": "SYSDATE: returns the database server current date and time" },
      { "label": "E", "text": "INSTR: can be used to find only the first occurrence of a character in a string" },
      { "label": "F", "text": "TRIM: can be used to remove all the occurrences of a character from a string" }
    ],
    "CorrectAnswer": ["B","D"],
    "Explanation": ""
  },
  {
    "QuestionID": 38,
    "QuestionType": "single",
    "QuestionText": "You want to use table compression suitable for OLTP that will: 1. Compress rows for all DML statements on that table 2. Minimize the overheads associated with compression. Which compression option is best suited for this?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "COLUMN STORE COMPRESS FOR QUERY LOW" },
      { "label": "B", "text": "ROW STORE COMPRESS BASIC" },
      { "label": "C", "text": "COLUMN STORE COMPRESS FOR ARCHIVE LOW" },
      { "label": "D", "text": "COLUMN STORE COMPRESS FOR ARCHIVE HIGH" },
      { "label": "E", "text": "ROW STORE COMPRESS ADVANCED" }
    ],
    "CorrectAnswer": ["E"],
    "Explanation": ""
  },
  {
    "QuestionID": 39,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about space-saving features in an Oracle Database?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Private Temporary Tables (PTTs) store metadata in memory only" },
      { "label": "B", "text": "An index created with the UNUSABLE attribute has no segment" },
      { "label": "C", "text": "If they exist for a session, Private Temporary Tables (PTTs) are always dropped at the next COMMIT OR ROLLBACK statement" },
      { "label": "D", "text": "An index that is altered to be UNUSABLE will retain its segment" },
      { "label": "E", "text": "A table that is truncated will always have its segment removed" }
    ],
    "CorrectAnswer": ["A","B"],
    "Explanation": ""
  },
{
    "QuestionID": 40,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about the PMON background process?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "It registers database services with all local and remote listeners known to the database instance."},
      { "label": "B", "text": "It frees resources held by abnormally terminated processes."},
      { "label": "C", "text": "It records checkpoint information in the control file."},
      { "label": "D", "text": "It frees unused temporary segments."},
      { "label": "E", "text": "It kills sessions that exceed idle time."}
    ],
    "CorrectAnswer": ["B","E"],
    "Explanation": ""
  },
  {
    "QuestionID": 41,
    "QuestionType": "single",
    "QuestionText": "The EMPLOYEES table contains columns EMP_ID of data type NUMBER and HIRE_DATE of data type DATE. You want to display the date of the first Monday after the completion of six months since hiring. The NLS_TERRITORY parameter is set to AMERICA in the session and, therefore, Sunday is the first day on the week. Which query can be used?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "SELECT emp_id, ADD_MONTHS(hire_date, 6), NEXT_DAY('MONDAY') FROM employees;"},
      { "label": "B", "text": "SELECT emp_id, NEXT_DAY(ADD_MONTHS(hire_date, 6), 'MONDAY') FROM employees;"},
      { "label": "C", "text": "SELECT emp_id, NEXT_DAY(MONTHS_BETWEEN(hire_date, SYSDATE), 6) FROM employees;"},
      { "label": "D", "text": "SELECT emp_id, NEXT_DAY(ADD_MONTHS(hire_date, 6), 1) FROM employees;"}
    ],
    "CorrectAnswer": ["B"],
    "Explanation": ""
  },
  {
    "QuestionID": 42,
    "QuestionType": "multiple",
    "QuestionText": "Which are three actions any one of which the DBA could take to resume the session?",
    "ImageURL": "images/q42.png",
    "Options": [
      { "label": "A", "text": "Add a data file to DATA."},
      { "label": "B", "text": "Drop other U1 objects in DATA."},
      { "label": "C", "text": "Increase U1's quota sufficiently in DATA."},
      { "label": "D", "text": "Set DEFERRED_SEGMENT_CREATION to TRUE."},
      { "label": "E", "text": "Grant UNLIMITED TABLESPACE to U1."},
      { "label": "F", "text": "Set AUTOEXTEND ON for data files in DATA."}
    ],
    "CorrectAnswer": ["B","C","E"],
    "Explanation": "1. A 添加数据文件仅增加表空间总容量，但 U1 的配额仍为 1 MB，无法解决配额不足问题。 2. D 设置 DEFERRED_SEGMENT_CREATION=TRUE 仅对后续操作生效，当前已挂起的操作仍因段已分配而受配额限制。 3. F 启用数据文件自动扩展仅增加表空间总容量，但 U1 的配额未变，无法解决当前配额不足问题。"
  },
  {
    "QuestionID": 43,
    "QuestionType": "multiple",
    "QuestionText": "In which three situations does a new transaction always start?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "When issuing a SELECT FOR UPDATE statement after a CREATE TABLE AS SELECT statement was issued in the same session."},
      { "label": "B", "text": "When issuing a TRUNCATE statement after a SELECT statement was issued in the same session."},
      { "label": "C", "text": "When issuing a CREATE TABLE statement after a SELECT statement was issued in the same session."},
      { "label": "D", "text": "When issuing the first Data Manipulation Language (DML) statement after a COMMIT OR ROLLBACK statement was issued in the same session."},
      { "label": "E", "text": "When issuing a CREATE INDEX statement after a CREATE TABLE statement completed successfully in the same session."},
      { "label": "F", "text": "When issuing a DML statement after a DML statement failed in the same session."}
    ],
    "CorrectAnswer": ["A","D","F"],
    "Explanation": "1.DML (INSERT/UPDATE/DELETE/MERGE)自动开始新事务，如果前一个事务结束（COMMIT/ROLLBACK） 2.SELECT不会启动事务 3.SELECT FOR UPDATE会锁行，启动事务 4.DDL (CREATE/ALTER/DROP/TRUNCATE)不算新事务启动，但隐式提交前一个事务DDL 执行会自动 COMMIT 前一个事务 5.DML 失败，事务仍然存在，下一条 DML 在同一事务中"
  },
  {
    "QuestionID": 44,
    "QuestionType": "single",
    "QuestionText": "Which set operator generates the required output?",
    "ImageURL": "images/q44.png",
    "Options": [
      { "label": "A", "text": "INTERSECT"},
      { "label": "B", "text": "UNION ALL"},
      { "label": "C", "text": "UNION"},
      { "label": "D", "text": "SUBTRACT"},
      { "label": "E", "text": "MINUS"}
    ],
    "CorrectAnswer": ["E"],
    "Explanation": ""
  },
  {
    "QuestionID": 45,
    "QuestionType": "single",
    "QuestionText": "What is the outcome?",
    "ImageURL": "images/q45.png",
    "Options": [
      { "label": "A", "text": "The value is changed only in the PFILE and takes effect at the next instance startup."},
      { "label": "B", "text": "The value is changed for the current instance and in the PFILE."},
      { "label": "C", "text": "It fails because the SCOPE clause is missing."},
      { "label": "D", "text": "Change is applied to the current instance, but does not persist after instance restart."}
    ],
    "CorrectAnswer": ["D"],
    "Explanation": "starting db instance with PFILE, SCOPE=MEMORY is a default /implicit option, so it can be omitted. Change is applied to current instance.starting db instance with spfile,scope=both is default;"
  },
  {
    "QuestionID": 46,
    "QuestionType": "multiple",
    "QuestionText": "Which three statements are true about pfiles, spfiles or both?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "All spfile parameters can be modified successfully with the scope=both clause." },
      { "label": "B", "text": "A spfile can be created by an idle instance." },
      { "label": "C", "text": "Spfiles and pfiles may both be edited with an O/S editing utility." },
      { "label": "D", "text": "Some spfile parameters can be modified successfully with the scope=memory clause." },
      { "label": "E", "text": "A pfile can be created by an idle instance." },
      { "label": "F", "text": "All spfile parameters can be modified successfully with the scope=memory clause." }
    ],
    "CorrectAnswer": ["B","D","E"],
    "Explanation": ""
  },
  {
    "QuestionID": 47,
    "QuestionType": "multiple",
    "QuestionText": "Which four statements are true about database instance behavior?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Redo log files can be renamed in mount state." },
      { "label": "B", "text": "Datafiles can be renamed in mount state." },
      { "label": "C", "text": "All dynamic performance views (v$ views) return data when queried from a session connected to an instance in nomount state." },
      { "label": "D", "text": "An spfile can be updated when connected to an idle instance." },
      { "label": "E", "text": "The consistency of redo logs and data files is checked when mounting the database." },
      { "label": "F", "text": "An idle instance is created when a startup nomount is successful." }
    ],
    "CorrectAnswer": ["A","B","D","F"],
    "Explanation": "1.NOMOUNT：实例已启动，SGA 分配完成，后台进程启动，但控制文件未挂载，可以修改 spfile- 创建 PFILE/SPFILE- 连接实例执行部分管理命令，不可以访问数据文件- 查询大部分 v$ 视图 2.MOUNT：控制文件挂载，数据文件和 redo log 尚未打开，可以重命名 redo log / 数据文件- 执行恢复操作（recover）- 查询部分 v$ 视图，不可以数据操作（SELECT/INSERT/UPDATE） 3.OPEN：数据库完全打开，可以读写数据- 全部 v$ 视图可用"
  },
  {
    "QuestionID": 48,
    "QuestionType": "single",
    "QuestionText": "Your database instance is started by using a server parameter file (SPFILE). You execute the following command to change the value of the LOG_BUFFER initialization parameter: ALTER SYSTEM SET LOG_BUFFER=32M; What is the outcome of this command?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "The parameter value is changed and it comes into effect as soon as space becomes available in the SGA." },
      { "label": "B", "text": "The parameter value is changed and it comes into effect at the next instance startup." },
      { "label": "C", "text": "It returns an error because SCOPE should be set to MEMORY." },
      { "label": "D", "text": "It returns an error because the value of this parameter cannot be changed dynamically." }
    ],
    "CorrectAnswer": ["D"],
    "Explanation": ""
  },
  {
    "QuestionID": 49,
    "QuestionType": "multiple",
    "QuestionText": "A PFILE exists for your database. You want to increase the value of the PROCESSES parameter from 300 to 400 and make it persistent for your database instance. You plan to use the ALTER SYSTEM command. Which two methods can be used?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Edit the PFILE manually, re-create the SPFILE from the edited PFILE, and restart the database instance by using the SPFILE." },
      { "label": "B", "text": "Use the PFILE to STARTUP MOUNT the database instance and then execute the ALTER SYSTEM SET PROCESSES=400 command." },
      { "label": "C", "text": "Create an SPFILE, start the database instance by using the SPFILE, and then execute the ALTER SYSTEM SET PROCESSES=400 SCOPE=SPFILE command." },
      { "label": "D", "text": "Create an SPFILE, STARTUP MOUNT the database instance by using the SPFILE, and then execute the ALTER SYSTEM SET PROCESSES=400 command." },
      { "label": "E", "text": "Create an SPFILE, start the database instance by using the SPFILE, and then execute the ALTER SYSTEM SET PROCESSES=400 SCOPE=DEFERRED command." },
      { "label": "F", "text": "Start the database instance by using the PFILE, and then execute the ALTER SYSTEM SET PROCESSES=400 SCOPE=BOTH command." }
    ],
    "CorrectAnswer": ["A","C"],
    "Explanation": ""
  },
  {
    "QuestionID": 50,
    "QuestionType": "single",
    "QuestionText": "Choose the best answer. Examine this scenario: connect / as sysdba Connected. SHUTDOWN TRANSACTIONAL. Database closed. Database dismounted. ORACLE instance shut down. STARTUP Now examine these steps:\n 1. Oracle instance is started. \n2. The control file is read. \n3. Instance recovery is started.\n 4. Datafiles and redo log files are opened.\n 5. The spfile or pfile is read.\n 6. The database is available for use. \n7. The database is mounted.\n 8. Instance recovery is completed.\n Identify the correct steps and the order they will be executed in following this command",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "5,2,1,7,4,6" },
      { "label": "B", "text": "5,1,2,7,4,3,8,6" },
      { "label": "C", "text": "5,2,1,4,7,6" },
      { "label": "D", "text": "5,1,2,7,4,3,6,8" },
      { "label": "E", "text": "5,1,2,7,4,6" },
      { "label": "F", "text": "5,1,3,2,7,4,8,6" }
    ],
    "CorrectAnswer": ["E"],
    "Explanation": ""
  },
  {
    "QuestionID": 51,
    "QuestionType": "multiple",
    "QuestionText": "Which three are true about the result of processing the last statement?",
    "ImageURL": "images/q51.png",
    "Options": [
      { "label": "A", "text": "The parameter is modified in memory and in the parameter file." },
      { "label": "B", "text": "The modification does not persist across a SHUTDOWN TRANSACTIONAL command." },
      { "label": "C", "text": "The parameter is modified in memory only." },
      { "label": "D", "text": "The modification persists across a SHUTDOWN IMMEDIATE command." },
      { "label": "E", "text": "The modification persists across instance checkpoints." },
      { "label": "F", "text": "The parameter is modified in the parameter file only." }
    ],
    "CorrectAnswer": ["B","C","E"],
    "Explanation": ""
  },
  {
    "QuestionID": 52,
    "QuestionType": "single",
    "QuestionText": "Choose the best answer. All of your database instances use SPFILES. You executed this command in one of them: ALTER SYSTEM SET MEMORY_MAX_TARGET=1024M; Which statement is true?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "The command returns an error." },
      { "label": "B", "text": "The parameter is modified in the parameter file only." },
      { "label": "C", "text": "The parameter is modified in memory and in the parameter file." },
      { "label": "D", "text": "The parameter is modified in memory only." }
    ],
    "CorrectAnswer": ["A"],
    "Explanation": "静态参数，所以必须要加 scope=spfile 选项"
  },
  {
    "QuestionID": 53,
    "QuestionType": "multiple",
    "QuestionText": "Which three Oracle database space management features will work with both Dictionary and Locally managed tablespaces?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Oracle Managed Files (OMF)." },
      { "label": "B", "text": "Online table segment shrink." },
      { "label": "C", "text": "Online index segment shrink." },
      { "label": "D", "text": "Automatic data file extension (AUTOEXTEND)." },
      { "label": "E", "text": "Capacity planning growth reports based on historical data in the Automatic Workload Repository (AWR)." }
    ],
    "CorrectAnswer": ["A","D","E"],
    "Explanation": ""
  },
  {
    "QuestionID": 54,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about the job?",
    "ImageURL": "images/q54.png",
    "Options": [
      { "label": "A", "text": "You can no longer monitor it." },
      { "label": "B", "text": "You can reattach to it and monitor it." },
      { "label": "C", "text": "It is paused and can be resumed." },
      { "label": "D", "text": "It continues to run in the background." },
      { "label": "E", "text": "It terminates." }
    ],
    "CorrectAnswer": ["B","C"],
    "Explanation": "1.Ctrl + C → Detach 前台退出，后台继续（旧版） 2.STOP_JOB正常暂停 3.STOP_JOB=IMMEDIATE立即暂停，不终止 4.KILL_JOB彻底终止并删除"
  },
  {
    "QuestionID": 55,
    "QuestionType": "multiple",
    "QuestionText": "In one of your databases, you create a user, HR, and then execute this command: GRANT CREATE SESSION TO hr WITH ADMIN OPTION; Which actions can HR perform? (Choose Four.)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Revoke the CREATE SESSION privilege from other users." },
      { "label": "B", "text": "Revoke the CREATE SESSION privilege from user HR." },
      { "label": "C", "text": "Log in to the database instance." },
      { "label": "D", "text": "Grant the CREATE SESSION privilege with ADMIN OPTION to other users." },
      { "label": "E", "text": "Execute DDL statements in the HR schema." },
      { "label": "F", "text": "Execute DML statements in the HR schema." }
    ],
    "CorrectAnswer": ["A","B","C","D"],
    "Explanation": "实验证明拥有该权限的可以把其它用户、或者自己、以及 sys 用户的 CREATE SESSION 权限给撤除"
  },
  {
    "QuestionID": 56,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about the WHERE and HAVING clauses in a SELECT statement?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Aggregating functions and columns used in HAVING clauses must be specified in the SELECT list of a query." },
      { "label": "B", "text": "WHERE and HAVING clauses can be used in the same statement only if applied to different table columns." },
      { "label": "C", "text": "The HAVING clause can be used with aggregating functions in subqueries." },
      { "label": "D", "text": "The WHERE clause can be used to exclude rows before dividing them into groups." },
      { "label": "E", "text": "The WHERE clause can be used to exclude rows after dividing them into groups." }
    ],
    "CorrectAnswer": ["C","D"],
    "Explanation": "先用 WHERE 过滤掉不需要的行，再用 HAVING 筛选分组结果"
  },
  {
    "QuestionID": 57,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about UNDO and REDO?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "The generation of REDO generates UNDO." },
      { "label": "B", "text": "DML modifies Oracle database objects and generates UNDO and REDO." },
      { "label": "C", "text": "The generation of UNDO generates REDO." },
      { "label": "D", "text": "DML modifies Oracle database objects and only generates UNDO." },
      { "label": "E", "text": "DML modifies Oracle database objects and only generates REDO." }
    ],
    "CorrectAnswer": ["B","C"],
    "Explanation": "1.UNDO回滚事务DML 修改数据时 2.REDO数据恢复DML 修改数据时 3.产生 redo 的不一定产生 undo，比如 ddl 操作；但是产生 undo 的肯定有 redo"
  },
  {
    "QuestionID": 58,
    "QuestionType": "single",
    "QuestionText": "The SCOTT/TIGER user exists in two databases, BOSTON_DB and DALLAS_DB, in two different locations. Each database has a tnsnames.ora file defining DALLAS_DB as a service name. Examine this command: CREATE DATABASE LINK dblink1 CONNECT TO scott IDENTIFIED BY tiger USING ‘dallas_db’; How do you execute the command so that only SCOTT in BOSTON_DB can access the SCOTT schema in DALLAS_DB?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "As SCOTT in DALLAS_DB." },
      { "label": "B", "text": "As SCOTT in BOSTON_DB." },
      { "label": "C", "text": "As SCOTT in BOSTON_DB and SYS in DALLAS_DB." },
      { "label": "D", "text": "as SYS in both the databases" },
      { "label": "E", "text": "as SCOTT in both the databases" }
    ],
    "CorrectAnswer": ["B"],
    "Explanation": ""
  },
  {
    "QuestionID": 59,
    "QuestionType": "multiple",
    "QuestionText": "Which three statements are true about the DESCRIBE command?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "It displays the PRIMARY KEY constraint for any column or columns that have that constraint" },
      { "label": "B", "text": "It can be used from SQL Developer" },
      { "label": "C", "text": "It displays the NOT NULL constraint for any columns that have that constraint" },
      { "label": "D", "text": "It can be used to display the structure of an existing view" },
      { "label": "E", "text": "It displays all constraints that are defined for each column" },
      { "label": "F", "text": "It can be used only from SQL *Plus" }
    ],
    "CorrectAnswer": ["B","C","D"],
    "Explanation": "DESCRIBE 想成“列结构快照”：列名 + 类型 + 是否可为空 → 快速了解表结构。其他约束信息 → 要查系统表或用 DBA/USER_CONSTRAINTS"
  },
  {
    "QuestionID": 60,
    "QuestionType": "single",
    "QuestionText": "Which query should be used?",
    "ImageURL": "images/q60.png",
    "Options": [
      { "label": "A", "text": "SELECT cust_first_name, cust_credit_limit * .05 AS DUE_AMOUNT FROM customers WHERE cust_incoms_level IS NOT NULL AND due_amount IS NOT NULL;" },
      { "label": "B", "text": "SELECT cust_first_name, cust_credit_limit * .05 AS DUE_AMOUNT FROM customers WHERE cust_income_level != NULL AND cust_credit_level !=NULL;" },
      { "label": "C", "text": "SELECT cust_first_name, cust_credit_limit * .05 AS DUE_AMOUNT FROM customers WHERE cust_income_level <> NULL AND due_amount <> NULL;" },
      { "label": "D", "text": "SELECT cust_first_name, cust_credit_limit * .05 AS DUE_AMOUNT FROM customers WHERE cust_income_level != NULL AND due_amount !=NULL;" },
      { "label": "E", "text": "SELECT cust_first_name, cust_credit_limit * .05 AS DUE_AMOUNT FROM customers WHERE cust_income_level IS NOT NULL AND cust_credit_limit IS NOT NULL;" }
    ],
    "CorrectAnswer": ["E"],
    "Explanation": ""
  },
  {
    "QuestionID": 61,
    "QuestionType": "multiple",
    "QuestionText": "The INVOICE table has a QTY_SOLD column of data type NUMBER and an INVOICE_DATE column of data type DATE. NLS_DATE_FORMAT is set to DD-MON-RR. Which two are true about data type conversions involving these columns in query expressions?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "CONCAT (qty_sold, invoice_date) : requires explicit conversion" },
      { "label": "B", "text": "invoice_date = '15-march-2019' : uses implicit conversion" },
      { "label": "C", "text": "invoice_date > '01-02-2019' : uses implicit conversion" },
      { "label": "D", "text": "qty_sold BETWEEN '101' AND '110' : uses implicit conversion" },
      { "label": "E", "text": "qty_sold = '0554982' uses implicit conversion" }
    ],
    "CorrectAnswer": ["B", "D"],
    "Explanation": ""
  },
  {
    "QuestionID": 62,
    "QuestionType": "multiple",
    "QuestionText": "Which three are types of segments in an Oracle Database?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "undo" },
      { "label": "B", "text": "index" },
      { "label": "C", "text": "stored procedures" },
      { "label": "D", "text": "sequences" },
      { "label": "E", "text": "tables" },
      { "label": "F", "text": "clusters" }
    ],
    "CorrectAnswer": ["B", "E", "F"],
    "Explanation": "1.用户数据TABLE segment 2.用户索引INDEX segment 3.多表共享CLUSTER segment 4.系统管理Undo、Temp、Rollback"
  },
  {
    "QuestionID": 63,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about the results of using the INTERSECT operator in compound queries?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Column names in each SELECT in the compound query can be different" },
      { "label": "B", "text": "The number of columns in each SELECT in the compound query can be different" },
      { "label": "C", "text": "Reversing the order of the intersected tables can sometimes affect the output" },
      { "label": "D", "text": "INTERSECT returns rows common to both sides of the compound query" },
      { "label": "E", "text": "INTERSECT ignores NULLs" }
    ],
    "CorrectAnswer": ["A", "D"],
    "Explanation": "复合查询的列名可以不一样，但是个数和数据类型必须一样；INTERSECT 获得是交集，所以 INTERSECT 返回复合查询两边共有的行"
  },
  {
    "QuestionID": 64,
    "QuestionType": "single",
    "QuestionText": "Which statement is true regarding the INTERSECT operator?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "The names of columns in all SELECT statements must be identical." },
      { "label": "B", "text": "It ignores NULL values." },
      { "label": "C", "text": "Reversing the order of the intersected tables alters the result." },
      { "label": "D", "text": "The number of columns and data types must be identical for all SELECT statements in the query." }
    ],
    "CorrectAnswer": ["D"],
    "Explanation": ""
  },
  {
    "QuestionID": 65,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about single row functions?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "MOD: returns the quotient of a division operation" },
      { "label": "B", "text": "FLOOR: returns the smallest integer greater than or equal to a specified number" },
      { "label": "C", "text": "TRUNC: can be used to combine any number of values" },
      { "label": "D", "text": "CONCAT: can be used to combine any number of values" },
      { "label": "E", "text": "CEIL: can be used for positive and negative numbers" }
    ],
    "CorrectAnswer": ["C", "E"],
    "Explanation": ""
  },
  {
    "QuestionID": 66,
    "QuestionType": "multiple",
    "QuestionText": "Which three statements are true about the Oracle Data Dictionary?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Data dictionary views are created by joins of dictionary base tables and DBA-defined tables" },
      { "label": "B", "text": "The data dictionary is created and maintained by the database administrator" },
      { "label": "C", "text": "Views with the same name but different prefixes, such as CDB, DBA, ALL and USER, reference the same base tables from the data dictionary" },
      { "label": "D", "text": "Base tables can be queried directly" },
      { "label": "E", "text": "It is owned by the SYSTEM user" },
      { "label": "F", "text": "Usernames of all users including database administrators are stored in the data dictionary" }
    ],
    "CorrectAnswer": ["C", "D", "F"],
    "Explanation": "1. 数据字典是 Oracle 自动创建并维护的，包含数据库所有元数据。 2. 数据字典的 base tables 归 SYS 用户所有，普通用户通过视图访问。 3. 不同前缀的视图（DBA_, ALL_, USER_）是同一底层表的不同访问接口。 4. 用户信息（包括 DBA）存储在数据字典中。 5. 直接查询 base tables 一般不推荐，但 SYS 用户可以。"
  },
  {
    "QuestionID": 67,
    "QuestionType": "single",
    "QuestionText": "In one of your databases, the user HR has the password HRMGR. You want to connect to a database instance whose listener listens on port 1531 by using this statement: CONNECT HR/HRMGR@orcl. No name server is used. Which statement is true about ORCL?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "It must be the value of the SERVICE_NAMES parameter on the client side" },
      { "label": "B", "text": "It must resolve to a valid connect descriptor in the server's tnsnames.ora file" },
      { "label": "C", "text": "It must resolve to a valid connect descriptor in the client's tnsnames.ora file" },
      { "label": "D", "text": "It must be the name of the database to whose instance HR wishes to connect" },
      { "label": "E", "text": "It must be the name of the server running the database to whose instance HR wishes to connect" }
    ],
    "CorrectAnswer": ["C"],
    "Explanation": ""
  },
  {
    "QuestionID": 68,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about views used for viewing tablespace and datafile information?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Tablespace free space can be viewed in V$TABLESPACE" },
      { "label": "B", "text": "V$TABLESPACE displays information that is contained in the controlfile about tablespaces" },
      { "label": "C", "text": "V$TABLESPACE displays information about tablespaces contained in the data dictionary" },
      { "label": "D", "text": "Tablespace free space can be viewed in DBA_TABLESPACES" },
      { "label": "E", "text": "A datafile can be renamed when the database is in MOUNT state and the new file name is displayed when querying DBA_DATA_FILES after the database is opened" }
    ],
    "CorrectAnswer": ["B", "E"],
    "Explanation": "1.V$TABLESPACE = 仓库管理员实时看报告（控制文件里的实时状态） 2.DBA_TABLESPACES = 仓库档案室记录（数据字典里的定义信息） 3.查看空闲空间 ≠ V$TABLESPACE，也 ≠ DBA_TABLESPACES，要查 DBA_FREE_SPACE 4.改文件名：先把仓库锁上（MOUNT），改名字，再正式登记（OPEN 后 DBA_DATA_FILES 可以看到）"
  },
  {
    "QuestionID": 69,
    "QuestionType": "multiple",
    "QuestionText": "Which two queries can be used?",
    "ImageURL": "images/q69.png",
    "Options": [
      { "label": "A", "text": "SELECT promo_cost, promo_category FROM promotions ORDER BY 1;" },
      { "label": "B", "text": "SELECT DISTINCT promo_cost || ' in ' || DISTINCT promo_category FROM promotions ORDER BY 1;" },
      { "label": "C", "text": "SELECT DISTINCT promo_category || ' has ' || promo_cost AS COSTS FROM promotions ORDER BY 1;" },
      { "label": "D", "text": "SELECT promo_category, DISTINCT promo_cost FROM promotions ORDER BY 2;" },
      { "label": "E", "text": "SELECT DISTINCT promo_category, promo_cost FROM promotions ORDER BY 1;" }
    ],
    "CorrectAnswer": ["C", "E"],
    "Explanation": "distinct 只能在 select 子句第一个位置使用，不能有两个 distinct 语句。"
  },
  {
    "QuestionID": 70,
    "QuestionType": "single",
    "QuestionText": "Which query would satisfy this requirement?",
    "ImageURL": "images/q70.png",
    "Options": [
      { "label": "A", "text": "SELECT DISTINCT promo_category, promo_cost FROM promotions ORDER BY 1" },
      { "label": "B", "text": "SELECT promo_category, DISTINCT promo_cost FROM promotions" },
      { "label": "C", "text": "SELECT DISTINCT promo_cost, promo_category FROM promotions" },
      { "label": "D", "text": "SELECT DISTINCT promo_cost, DISTINCT promo_category FROM promotions;" }
    ],
    "CorrectAnswer": ["A"],
    "Explanation": ""
  },
  {
    "QuestionID": 71,
    "QuestionType": "single",
    "QuestionText": "In the ORCL database, UNDOTBS1 is the active undo tablespace with these properties: \n1. A size of 100 MB \n2. AUTOEXTEND is off \n3. UNDO_RETENTION is set to 15 minutes\n 4. It has RETENTION GUARANTEE \nUNDOTBS1 fills with uncommitted undo 10 minutes after the database opens. What will happen when the next update is attempted by any transaction?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "It succeeds and the generated undo is stored in SYSTEM" },
      { "label": "B", "text": "It fails and returns the error message 'ORA-30036: unable to extend segment by 8 in undo tablespace UNDOTBS1'" },
      { "label": "C", "text": "It succeeds and the least recently written undo block of UNDOTBS1 is overwritten by the generated undo" },
      { "label": "D", "text": "It succeeds and the generated undo is stored in SYSAUX" },
      { "label": "E", "text": "It succeeds and the least recently read undo block of UNDOTBS1 is overwritten by the generated undo" }
    ],
    "CorrectAnswer": ["B"],
    "Explanation": "1.UNDO 只能在 undo tablespace 2.SYSAUX 用于存储 Oracle 辅助组件的数据 3.系统运行时，如果 undo tablespace 满了，Oracle 不会把 undo 放到 SYSAUX，会报错（如 ORA-30036）。"
  },
  {
    "QuestionID": 72,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about the rules of precedence for operators?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "The concatenation operator || is always evaluated before addition and subtraction in an expression" },
      { "label": "B", "text": "NULLS influence the precedence of operators in an expression" },
      { "label": "C", "text": "+ binary operator has the highest precedence in an expression in a SQL statement" },
      { "label": "D", "text": "Arithmetic operators with equal precedence are evaluated from left to right within an expression" },
      { "label": "E", "text": "Multiple parentheses can be used to override the default precedence of operators in an expression" }
    ],
    "CorrectAnswer": ["D", "E"],
    "Explanation": "1. 算术运算符* / 优先级最高+ -其次 2. 字符串连接|| → 低于算术运算符 3. 逻辑运算符NOT → 高于 AND、OR 4. 括号总是最高优先级，可以强制改变计算顺序 5. 同级运算符从左到右依次执行"
  },
  {
    "QuestionID": 73,
    "QuestionType": "single",
    "QuestionText": "What must you do so that KING is authenticated by the OS when connecting to the database instance?",
    "ImageURL": "images/q73.png",
    "Options": [
      { "label": "A", "text": "Set OS_AUTHEN_PREFIX to OPS$" },
      { "label": "B", "text": "Have the OS administrator add KING to the OSDBA group" },
      { "label": "C", "text": "Grant DBA to KING" },
      { "label": "D", "text": "Unset REMOTE_LOGIN_PASSWORD FILE" },
      { "label": "E", "text": "Alter user KING to be IDENTIFIED EXTERNALLY" }
    ],
    "CorrectAnswer": ["E"],
    "Explanation": ""
  },
  {
    "QuestionID": 74,
    "QuestionType": "single",
    "QuestionText": "What will be the result?",
    "ImageURL": "images/q74.png",
    "Options": [
      { "label": "A", "text": "It gives an error because the ALL keyword is not valid" },
      { "label": "B", "text": "It gives an error because the GROUP BY clause is not valid" },
      { "label": "C", "text": "It executes successfully but does not give the required result" },
      { "label": "D", "text": "It executes successfully and gives the required result" }
    ],
    "CorrectAnswer": ["D"],
    "Explanation": ""
  },
  {
    "QuestionID": 75,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about trace files produced by the Oracle Database server?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "They can be written by server processes" },
      { "label": "B", "text": "Trace files are written to the Fast Recovery Area (FRA)" },
      { "label": "C", "text": "They can be written by background processes" },
      { "label": "D", "text": "All trace files contain error information that require contacting Oracle Support" },
      { "label": "E", "text": "Trace file names are based on the database name concatenated with a sequential number" }
    ],
    "CorrectAnswer": ["A", "C"],
    "Explanation": ""
  },
  {
    "QuestionID": 76,
    "QuestionType": "multiple",
    "QuestionText": "You need to calculate the number of days from 1st January 2019 until today. Dates are stored in the default format of DD-MON-RR. Which two queries give the required output?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "SELECT TO_CHAR(SYSDATE, 'DD-MON-YYYY') -'01-JAN-2019' FROM DUAL;" },
      { "label": "B", "text": "SELECT ROUND(SYSDATE - '01-JAN-2019') FROM DUAL;" },
      { "label": "C", "text": "SELECT ROUND(SYSDATE - TO_DATE('01/JANUARY/2019')) FROM DUAL;" },
      { "label": "D", "text": "SELECT TO_DATE(SYSDATE, 'DD/MONTH/YYYY') - '01/JANUARY/2019' FROM DUAL;" },
      { "label": "E", "text": "SELECT SYSDATE - TO_DATE('01-JANUARY-2019') FROM DUAL;" }
    ],
    "CorrectAnswer": ["C", "E"],
    "Explanation": ""
  },
  {
    "QuestionID": 77,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about the DUAL table?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "It can be accessed only by the SYS user" },
      { "label": "B", "text": "It consists of a single row and single column of VARCHAR2 data type" },
      { "label": "C", "text": "It can display multiple rows but only a single column" },
      { "label": "D", "text": "It can be used to display only constants or pseudo columns" },
      { "label": "E", "text": "It can be accessed by any user who has the SELECT privilege in any schema" },
      { "label": "F", "text": "It can display multiple rows and columns" }
    ],
    "CorrectAnswer": ["E", "F"],
    "Explanation": ""
  },
  {
    "QuestionID": 78,
    "QuestionType": "single",
    "QuestionText": "Which query is valid?",
    "ImageURL": "images/q78.png",
    "Options": [
      { "label": "A", "text": "SELECT dept_id, AVG(MAX(salary)) FROM employees GROUP BY dept_id;" },
      { "label": "B", "text": "SELECT dept_id, join_date, SUM(salary) FROM employees GROUP BY dept_id;" },
      { "label": "C", "text": "SELECT dept_id, join_date, SUM(salary) FROM employees GROUP BY dept_id, join_date;" },
      { "label": "D", "text": "SELECT dept_id, MAX(AVG(salary)) FROM employees GROUP BY dept_id;" }
    ],
    "CorrectAnswer": ["C"],
    "Explanation": "SELECT 中出现的列必须在 GROUP BY 中出现，或者被聚合函数包裹。"
  },
  {
    "QuestionID": 79,
    "QuestionType": "multiple",
    "QuestionText": "Which four statements are true regarding primary and foreign key constraints and the effect they can have on table data?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "A table can have only one primary key but multiple foreign keys" },
      { "label": "B", "text": "A table can have only one primary key and foreign key" },
      { "label": "C", "text": "The foreign key columns and parent table primary key columns must have the same names" },
      { "label": "D", "text": "It is possible for child rows that have a foreign key to remain in the child table at the time the parent row is deleted" },
      { "label": "E", "text": "It is possible for child rows that have a foreign key to be deleted automatically from the child table at the time the parent row is deleted" },
      { "label": "F", "text": "Only the primary key can be defined at the column and table level" },
      { "label": "G", "text": "Primary key and foreign key constraints can be defined at both the column and table level" }
    ],
    "CorrectAnswer": ["A", "D", "E", "G"],
    "Explanation": ""
  },
  {
    "QuestionID": 80,
    "QuestionType": "multiple",
    "QuestionText": "What is true about non-equijoin statement performance? (Choose two.)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Table aliases can improve performance" },
      { "label": "B", "text": "The BETWEEN condition always performs better than using the >= and <= conditions" },
      { "label": "C", "text": "The join syntax used makes no difference to performance" },
      { "label": "D", "text": "The BETWEEN condition always performs less well than using the >= and <=conditions" },
      { "label": "E", "text": "The Oracle join syntax performs better than the SQL:1999 compliant ANSI join syntax" }
    ],
    "CorrectAnswer": ["A", "C"],
    "Explanation": "1. 非等值连接本身比等值连接慢，因为索引利用有限。 2. BETWEEN 和 >= AND <= 性能相同。 3. 表别名和语法选择主要是可读性和维护性，不显著影响性能。 4. 性能优化主要依赖：数据量大小，索引的存在与类型，执行计划选择"
  },
  {
    "QuestionID": 81,
    "QuestionType": "multiple",
    "QuestionText": "In your data center, Oracle Managed Files (OMF) is used for all databases. All tablespaces are smallfile tablespaces. SALES_Q1 is a permanent user-defined tablespace in the SALES database. Examine this command which is about to be issued by a DBA logged in to the SALES database: \nALTER TABLESPACE sales_q1 ADD DATAFILE; \nWhich are two actions, either one of which you could take to ensure that the command executes successfully?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Ensure that DB_RECOVERY_FILE_DEST and DB_CREATE_FILE_DEST each specify with at least 50 Mb of available space." },
      { "label": "B", "text": "Specify a path in the DATAFILE clause of the command specifying a location with at least 100M of available space." },
      { "label": "C", "text": "Ensure that DB_CREATE_FILE_DEST specifies a location with at least 100 Mb of available space." },
      { "label": "D", "text": "Add the AUTOEXTEND ON clause with NEXT set to 100M." },
      { "label": "E", "text": "Ensure that DB_RECOVERY_FILE_DEST and DB_CREATE_FILE_DEST each specify locations with at least 50 Mb of available space." }
    ],
    "CorrectAnswer": ["B","C"],
    "Explanation": ""
  },
  {
    "QuestionID": 82,
    "QuestionType": "multiple",
    "QuestionText": "Which two are true about this tablespace and its attributes?",
    "ImageURL": "images/q82.png",
    "Options": [
      { "label": "A", "text": "The datafile is created with a name generated by the Oracle Instance." },
      { "label": "B", "text": "The datafile size is 100M." },
      { "label": "C", "text": "The tablespace is created with manual segment space management." },
      { "label": "D", "text": "The datafile that is created is not auto extensible." },
      { "label": "E", "text": "The tablespace is a dictionary managed tablespace." }
    ],
    "CorrectAnswer": ["A","B"],
    "Explanation": "OMF 管理的数据文件，它的名字由 oracle 自动起名；而且默认是 100M，自动扩展"
  },
  {
    "QuestionID": 83,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about Oracle Managed Files (OMF)?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "OMF cannot be used in a database that already has data files created with user-specified directions." },
      { "label": "B", "text": "The file system directions that are specified by OMF parameters are created automatically." },
      { "label": "C", "text": "OMF can be used with ASM disk groups, as well as with raw devices, for better file management." },
      { "label": "D", "text": "OMF automatically creates unique file names for tablespaces and control files." },
      { "label": "E", "text": "OMF may affect the location of the redo log files and archived log files." }
    ],
    "CorrectAnswer": ["D","E"],
    "Explanation": "1.OMF 的核心功能之一：自动命名、自动管理数据库文件，减轻 DBA 手动管理 OS 层文件名/路径的负担。 2.Oracle 会在你给出一个已存在的目录（或 ASM 磁盘组）时在其中创建和管理文件，但Oracle 不会自动创建操作系统上的目录"
  },
  {
    "QuestionID": 84,
    "QuestionType": "single",
    "QuestionText": "Why does the DB01.abc.com service show unknown status?",
    "ImageURL": "images/q84.png",
    "Options": [
      { "label": "A", "text": "The service DB01.abc.com is dynamically registered" },
      { "label": "B", "text": "The LOCAL_LISTENER database parameter is not set to a service name that refers to LISTENER_1" },
      { "label": "C", "text": "The service DB01.abc.com is statically registered" },
      { "label": "D", "text": "The listener is not listening on the default port 1521" },
      { "label": "E", "text": "The SID_LIST_LISTENER section is not contained in the LISTENER.ORA file" }
    ],
    "CorrectAnswer": ["C"],
    "Explanation": "当实例是通过 PMON 动态注册（dynamic registration，又称“动态注册”或“service registration”）到监听器时，监听器通常能看到实例的运行状态并显示为 READY。反之，如果监听器对实例无法获取到 PMON 提供的状态信息（常见于静态注册或动态注册未成功时），它会把状态显示为 UNKNOWN。"
  },
  {
    "QuestionID": 85,
    "QuestionType": "multiple",
    "QuestionText": "Which three statements are true about the tools used to configure Oracle Net Services?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "The Oracle Net Configuration Assistant is only used when running the Oracle installer" },
      { "label": "B", "text": "Oracle Net Manager can be used to centrally configure listeners on any database server target" },
      { "label": "C", "text": "The lsnrctl utility requires a listener.ora file to exist before it is started" },
      { "label": "D", "text": "Oracle Net Manager can be used to locally configure naming methods on a database server" },
      { "label": "E", "text": "Enterprise Manager Cloud Control can be used to centrally configure listeners on any managed database server" },
      { "label": "F", "text": "Enterprise Manager Cloud Control can be used to centrally configure net service names for any database server target" }
    ],
    "CorrectAnswer": ["D","E","F"],
    "Explanation": ""
  },
  {
    "QuestionID": 86,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true regarding the UNION and UNION ALL operators?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Duplicates are eliminated automatically by the UNION ALL operator" },
      { "label": "B", "text": "The number of columns selected in each SELECT statement must be identical" },
      { "label": "C", "text": "The names of columns selected in each SELECT statement must be identical" },
      { "label": "D", "text": "The output is sorted by the UNION ALL operator" },
      { "label": "E", "text": "NULLS are not ignored during duplicate checking" }
    ],
    "CorrectAnswer": ["B","E"],
    "Explanation": "UNION 去重（包括 NULL），列数必须相同；UNION ALL 不去重，不排序，列名不必相同。"
  },
  {
    "QuestionID": 87,
    "QuestionType": "multiple",
    "QuestionText": "Which two statements are true about the Automatic Diagnostic Repository (ADR)",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "The ADR base defaults to $ORACLE_HOME/rdbms/admin if neither DIAGNOSTIC_DEST or ORACLE_BASE is set" },
      { "label": "B", "text": "The ADR base defaults to $ORACLE_HOME/dbs if the DIAGNOSTIC_DEST parameter and the ORACLE_BASE environment variable are not set" },
      { "label": "C", "text": "It supports diagnostics for Automatic Storage Management (ASM)" },
      { "label": "D", "text": "It supports diagnostics for Oracle Clusterware" },
      { "label": "E", "text": "It is held inside an Oracle database schema" }
    ],
    "CorrectAnswer": ["C","D"],
    "Explanation": "1.DIAGNOSTIC_DEST 设置了使用它 2.没设置 DIAGNOSTIC_DEST，但 ORACLE_BASE 设置了$ORACLE_BASE/diag 3.两者都没设置 $ORACLE_HOME/diag"
  },
   {
    "QuestionID": 88,
    "QuestionType": "multiple",
    "QuestionText": "Examine this command: SQL> ALTER SYSTEM SET ENABLE_DDL_LOGGING=TRUE;\n Which two statements are true?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "All DDL statements are logged in to a text file in Automatic Diagnostic Repository (ADR) home." },
      { "label": "B", "text": "The Alert Log still contains some DDL statements." },
      { "label": "C", "text": "Some data definition language (DDL) statements are written to the control file." },
      { "label": "D", "text": "All data definition language (DDL) statements are written to the control file." },
      { "label": "E", "text": "Some DDL statements are written to a text file in the ADR home." },
      { "label": "F", "text": "Some DDL statements are written to an XML file in the ADR home." }
    ],
    "CorrectAnswer": ["A","F"],
    "Explanation": "开 DDL 跟踪后，要通过 adrci 命令的 show log 才能够查看 DDL 日志，sys用户的 DDL 语句也会被纪录。adrci> show log ADR Home = /u01/app/oracle/diag/rdbms/orcl/ORCL，在该目录下有个 log 目录，里面有ddl_ORCL.log 文本跟踪日志，同时在 log 目录的 ddl 目录中有 log.xml 日志文件"
  },
  {
    "QuestionID": 89,
    "QuestionType": "single",
    "QuestionText": "ALTER SYSTEM SET enable_ddl_logging = TRUE; Which statement is true?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "Only the data definition language (DDL) commands that resulted in errors are logged in the alert log file." },
      { "label": "B", "text": "All DDL commands are logged in the alert log file." },
      { "label": "C", "text": "All DDL commands are logged in a different log file that contains DDL statements and their execution dates." },
      { "label": "D", "text": "Only DDL commands that resulted in the creation of new segments are logged." },
      { "label": "E", "text": "All DDL commands are logged in XML format in the alert directory under the Automatic Diagnostic Repository (ADR) home." }
    ],
    "CorrectAnswer": ["C"],
    "Explanation": "默认情况下，Oracle 不会记录所有 DDL 到日志中，只有报错或某些特殊情况会记录。1.如果设置为 TRUE：所有 DDL 操作都会被记录到一个日志文件中。2.这个日志文件不是 alert.log，而是 位于ADR（Automatic Diagnostic Repository）中的 DDL 日志文件。3.文件会记录 DDL 语句及执行的时间。"
  },
  {
    "QuestionID": 90,
    "QuestionType": "multiple",
    "QuestionText": "You want to apply the principle of Least Privilege in all your live databases. One of your requirements is to revoke unnecessary privileges from all users who have them using Privilege Analysis. Which three types of analyses can be done using the DBMS_PRIVILEGE_CAPTURE package?",
    "ImageURL": "",
    "Options": [
      { "label": "A", "text": "analysis of all privileges used by all users including administrative users in the database" },
      { "label": "B", "text": "analysis of all privileges used by all users but excluding administrative users in the database" },
      { "label": "C", "text": "analysis of privileges that a user has on their own schema objects that they did not use" },
      { "label": "D", "text": "analysis of privileges that a user has on their own schema objects that they did use" },
      { "label": "E", "text": "analysis of privileges granted directly to a role that are then used by a user who has been granted that role" },
      { "label": "F", "text": "analysis of privileges granted indirectly to a role that are then used by a user who has been granted that role" }
    ],
    "CorrectAnswer": ["B","E","F"],
    "Explanation": "DBMS_PRIVILEGE_CAPTURE 就像一个门禁监控系统，它能分析普通用户（不含管理员）和角色（直接或间接授予）的权限使用情况，帮助 DBA 确定哪些权限没被用过、可以撤销。"
  },
   {
        "QuestionID": 91,
        "QuestionType": "multiple",
        "QuestionText": "Which three statements are true about undo segments and the use of undo by transactions in an Oracle database instance?",
        "ImageURL": "",
        "Options": [
            {"label": "A", "text": "An undo segment may be used by multiple transactions simultaneously"},
            {"label": "B", "text": "Undo segments can wrap around to the first extent when a transaction fills the last extent of the undo segment"},
            {"label": "C", "text": "Undo segments have a minimum of three extents"},
            {"label": "D", "text": "Undo segments can extend when a transaction fills the last extent of the undo segment"},
            {"label": "E", "text": "A single transaction may use multiple undo segments simultaneously"},
            {"label": "F", "text": "Undo segments must be stored in a BIGFILE tablespace"},
            {"label": "G", "text": "Undo segments must be stored in a SMALLFILE tablespace"}
        ],
        "CorrectAnswer": ["A","B","D"],
        "Explanation": "undo 段可被多个事务同时使用；段可以在填满 extent 时回绕到前面的 extent；在需要且可能的情况下段也可以扩展。"
    },
    {
        "QuestionID": 92,
        "QuestionType": "single",
        "QuestionText": "What is the effect on new transactions when all undo space in the default undo tablespace is in use by active transactions?",
        "ImageURL": "images/q92.png",
        "Options": [
            {"label": "A", "text": "Transactions wait until space becomes available in UNDOTBS1."},
            {"label": "B", "text": "Transactions write their undo in a temporary tablespace."},
            {"label": "C", "text": "Transactions fail."},
            {"label": "D", "text": "Transactions write their undo in the SYSTEM undo segment."}
        ],
        "CorrectAnswer": ["C"],
        "Explanation": "即使系统有多个 undo tablespace，Oracle 在运行时只会使用当前 undo_tablespace 参数指定的那一个；它不会自动切换到别的 undo 表空间；如果默认的 undo tablespace 空间用完又不能扩展，新的事务就会失败。"
    },
    {
        "QuestionID": 93,
        "QuestionType": "multiple",
        "QuestionText": "One of your databases supports an OLTP workload. The default undo tablespace is fixed size with:\n 1. RETENTION NOGUARANTEE \n2. undo_retention is 12 minutes. \nUser scott get this error after a query on the sales table has run for more than 15 minutes: ORA-01555: snapshot too old \nWhich three factors taken separately or in some combination might be the cause?",
        "ImageURL": "",
        "Options": [
            {"label": "A", "text": "A committed delete to the sales table was made more than 12 minutes before the query began."},
            {"label": "B", "text": "An uncommitted delete to the sales table was made more than 12 minutes before the query began."},
            {"label": "C", "text": "A committed update to the sales table was made more than 12 minutes before the query began."},
            {"label": "D", "text": "An uncommitted update to the sales table was made more than 12 minutes before the query began."},
            {"label": "E", "text": "An update was made to the sales table before the query began."},
            {"label": "F", "text": "An update to the SALES table was committed after the query began."},
            {"label": "G", "text": "An update was made to the sales table after the query began."}
        ],
        "CorrectAnswer": ["A","C","F"],
        "Explanation": "1.未提交（活动）--从不覆盖 2.已提交（未过期） -- 少于保留期 12 分钟 -- 保留 --但不保证 3.旧提交（已过期） --早于保留期 12 分钟 --被新事务覆盖"
    },
    {
        "QuestionID": 94,
        "QuestionType": "multiple",
        "QuestionText": "Which two statements are true about Enterprise Manager Database Express?",
        "ImageURL": "",
        "Options": [
            {"label": "A", "text": "It is available only when the database is open"},
            {"label": "B", "text": "It can be used to perform database recovery"},
            {"label": "C", "text": "The same port number can be used for Database Express configurations for databases on different hosts"},
            {"label": "D", "text": "It can be used to switch a database into ARCHIVELOG MODE"},
            {"label": "E", "text": "The same port number can be used for multiple Database Express configurations for multiple databases on the same host"}
        ],
        "CorrectAnswer": ["A","C"],
        "Explanation": "1. EM Express 只管理单个数据库实例。\n2. 需要数据库 OPEN 才能访问。\n3. 端口号是访问入口，不同主机可以重复，相同主机不能重复。"
    },
    {
        "QuestionID": 95,
        "QuestionType": "multiple",
        "QuestionText": "Which two statements are true?",
        "ImageURL": "images/q95.png",
        "Options": [
            {"label": "A", "text": "Employee 100 will have SALARY set to the same value as the SALARY of employee 200"},
            {"label": "B", "text": "Employee 200 will have JOB_ID set to the same value as the JOB_ID of employee 100"},
            {"label": "C", "text": "Employee 200 will have SALARY set to the same value as the SALARY of employee 100"},
            {"label": "D", "text": "Employee 100 will have JOB_ID set to the same value as the JOB_ID of employee 200"},
            {"label": "E", "text": "Employees 100 and 200 will have the same JOB_ID as before the update command"},
            {"label": "F", "text": "Employees 100 and 200 will have the same SALARY as before the update command"}
        ],
        "CorrectAnswer": ["A","D"],
        "Explanation": ""
    },
    {
        "QuestionID": 96,
        "QuestionType": "multiple",
        "QuestionText": "Which two are true about a SQL statement using SET operators such as UNION?",
        "ImageURL": "",
        "Options": [
            {"label": "A", "text": "The data type group of each column returned by the second query must match the data type group of the corresponding column returned by the first query"},
            {"label": "B", "text": "The number, but not names, of columns must be identical for all SELECT statements in the query."},
            {"label": "C", "text": "The data type of each column returned by the second query must exactly match the data type of the corresponding column returned by the first query."},
            {"label": "D", "text": "The names and number of columns must be identical for all SELECT statements in the query."},
            {"label": "E", "text": "The data type of each column returned by the second query must be implicitly convertible to the data type of the corresponding column returned by the first query."}
        ],
        "CorrectAnswer": ["A","B"],
        "Explanation": ""
    },
    {
        "QuestionID": 97,
        "QuestionType": "multiple",
        "QuestionText": "Which three statements are true about time zones, date data types, and timestamp data types in an Oracle database?",
        "ImageURL": "",
        "Options": [
            {"label": "A", "text": "The CURRENT_TIMESTAMP function returns data without time zone information"},
            {"label": "B", "text": "A TIMESTAMP WITH LOCAL TIMEZONE data type column is stored in the database using the time zone of the session that inserted the row"},
            {"label": "C", "text": "A TIMESTAMP data type column contains information about year, month, and day"},
            {"label": "D", "text": "The DBTIMEZONE function can return an offset from Universal Coordinated Time (UTC)"},
            {"label": "E", "text": "The SESSIONTIMEZONE function can return an offset from Universal Coordinated Time (UTC)"}
        ],
        "CorrectAnswer": ["B","C","E"],
        "Explanation": ""
    },
    {
        "QuestionID": 98,
        "QuestionType": "multiple",
        "QuestionText": "Which three statements are true about time zones,date data types,and timestamp data types in an oracle database?",
        "ImageURL": "",
        "Options": [
            {"label": "A", "text": "The DBTIMEZONE function can return an offset from Universal Coordinated Time(UTC)."},
            {"label": "B", "text": "A TIMESTAMP data type column contains information about year,month,and day."},
            {"label": "C", "text": "A TIMESTAMP WITH LOCAL TIMEZONE data type column is stored in the database using the time zone of the session that inserted the row."},
            {"label": "D", "text": "The SESSIONTIMEZONE function can return an offset from Universal Coordinated Time(UTC)."},
            {"label": "E", "text": "The CURRENT_TIMESTAMP function returns data without time zone information."}
        ],
        "CorrectAnswer": ["B","C","D"],
        "Explanation": ""
    },
    {
        "QuestionID": 99,
        "QuestionType": "multiple",
        "QuestionText": "Which three statements are true about CURRENT_TIMESTAMP?",
        "ImageURL": "",
        "Options": [
            {"label": "A", "text": "The value varies depending on the setting of SESSIONTIMEZONE."},
            {"label": "B", "text": "The date is in the time zone of DBTIMEZONE."},
            {"label": "C", "text": "It returns a value of data type TIMESTAMP."},
            {"label": "D", "text": "The time is in the time zone of DBTIMEZONE."},
            {"label": "E", "text": "It returns the same date as CURRENT_DATE."},
            {"label": "F", "text": "It always returns the same value as SYSTIMESTAMP."},
            {"label": "G", "text": "It returns the same time as CURRENT_DATE."}
        ],
        "CorrectAnswer": ["A","C","E"],
        "Explanation": ""
    },
    {
        "QuestionID": 100,
        "QuestionType": "multiple",
        "QuestionText": "Which three statements are true about inner and outer joins?",
        "ImageURL": "",
        "Options": [
            {"label": "A", "text": "A full outer join returns matched and unmatched rows"},
            {"label": "B", "text": "An inner join returns matched rows"},
            {"label": "C", "text": "Outer joins can only be used between two tables per query"},
            {"label": "D", "text": "A full outer join must use Oracle syntax"},
            {"label": "E", "text": "Outer joins can be used when there are multiple join conditions on two tables"},
            {"label": "F", "text": "A left or right outer join returns only unmatched rows"}
        ],
        "CorrectAnswer": ["A","B","E"],
        "Explanation": "1.INNER -- 取交集 2.LEFT/RIGHT OUTER --保留某一边所有行 3.FULL OUTER-- 保留所有行"
    },
    {
        "QuestionID": 101,
        "QuestionType": "multiple",
        "QuestionText": "Which two SQL statements execute successfully?",
        "ImageURL": "images/q101.png",
        "Options": [
            {"label": "A", "text": "SELECT customer_id AS “CUSTOMER-ID”, transaction_date AS DATE, amount + 100 “DUES” FROM transactions;"},
            {"label": "B", "text": "SELECT customer_id AS “CUSTOMER-ID”, transaction_date AS “DATE”, amount +100 DUES FROM transactions;"},
            {"label": "C", "text": "SELECT customer_id AS CUSTOMER-ID, transaction_date AS TRANS_DATE, amount +100 “DUES AMOUNT” FROM transactions;"},
            {"label": "D", "text": "SELECT customer_id CUSTID, transaction_date TRANS_DATE, amount + 100 DUES FROM transactions;"},
            {"label": "E", "text": "SELECT customer_id AS 'CUSTOMER-ID', transaction_date AS DATE, amount + 100'DUES AMOUNT' FROM transactions;"}
        ],
        "CorrectAnswer": ["B","D"],
        "Explanation": ""
    },
    {
        "QuestionID": 102,
        "QuestionType": "multiple",
        "QuestionText": "The CUSTOMERS table has a CUST_CREDIT_LIMIT column of data type NUMBER. Which two queries execute successfully? (Choose two.)",
        "ImageURL": "",
        "Options": [
            {"label": "A","text": "SELECT NVL(cust_credit_limit * .15, 'Not Available') FROM customers;"},
            {"label": "B","text": "SELECT NVL2(cust_credit_limit * .15, 'Not Available') FROM customers;"},
            {"label": "C","text": "SELECT NVL(TO_CHAR(cust_credit_limit * .15), 'Not Available') FROM customers;"},
            {"label": "D","text": "SELECT TO_CHAR(NVL(cust_credit_limit * .15, 'Not Available')) FROM customers;"},
            {"label": "E","text": "SELECT NVL2(cust_credit_limit, TO_CHAR(cust_credit_limit * .15), 'Not Available') FROM customers;"}
        ],
        "CorrectAnswer": ["C", "E"],
        "Explanation": "1.NVL(expr1, expr2)必须两个参数。返回值的数据类型与第一个参数(expr1) 保持一致。数据库会尝试把 expr2 转换成 expr1 的类型(如果类型不同),如果不能转换则报错。2.NVL2(expr1,expr2, expr3) 含义是:如果第一个参数为空,则返回第三个参数;如果第一个参数不为空那么显示第二个参数的值。expr2 与 expr3 的数据类型应该互相兼容（通常都为字符串或都为数字等）。"
    },
    {
        "QuestionID": 103,
        "QuestionType": "single",
        "QuestionText": "Which SQL statement would produce the required result?",
        "ImageURL": "images/q103.png",
        "Options": [
            {"label": "A", "text": "SELECT NVL (TO_CHAR(cust_credit_limit*.15), ‘Not Available’) “NEW CREDIT” FROM customers"},
            {"label": "B", "text": "SELECT TO_CHAR(NVL(cust_credit_limit*.15), ‘Not Available’)) “NEW CREDIT” FROM customers"},
            {"label": "C", "text": "SELECT NVL (cust_credit_limit*.15, ‘Not Available’) “NEW CREDIT” FROM customers"},
            {"label": "D", "text": "SELECT NVL (cust_credit_limit, ‘Not Available’)*.15 “NEW CREDIT” FROM customers"}
        ],
        "CorrectAnswer": ["A"],
        "Explanation": "NVL(expr1, expr2)必须两个参数。返回值的数据类型与第一个参数(expr1) 保持一致。数据库会尝试把 expr2 转换成 expr1 的类型(如果类型不同),如果不能转换则报错。"
    },
    {
        "QuestionID": 104,
        "QuestionType": "single",
        "QuestionText": "Which statement is true about aggregate functions?",
        "ImageURL": "",
        "Options": [
            {"label": "A", "text": "Aggregate functions can be nested to any number of levels"},
            {"label": "B", "text": "The AVG function implicitly converts NULLS to zero"},
            {"label": "C", "text": "Aggregate functions can be used in any clause of a SELECT statement"},
            {"label": "D", "text": "Types MAX and MIN functions can be used on columns with character data"}
        ],
        "CorrectAnswer": ["D"],
        "Explanation": "A.聚合函数不可以无限嵌套，单行函数可以嵌套无穷 B.AVG 计算平均值时，NULL 值会被忽略，并不是当作 0 参与计算。C.聚合函数不能在任意子句中使用，例如 WHERE 子句 中是不允许的（因为 WHERE 是在聚合前过滤数据），只能在 SELECT 列表、HAVING 子句 或 ORDER BY 中使用。D.max 和 min 可以用在数字、字符、和日期型的数据类型上"
    },
    {
  "QuestionID": 105,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true regarding the WHERE and HAVING clauses in a SELECT statement? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The WHERE and HAVING clauses can be used in the same statement only if they are applied to different columns in the table."},
    {"label": "B", "text": "The aggregate functions and columns used in the HAVING clause must be specified in the SELECT list of the query."},
    {"label": "C", "text": "The WHERE clause can be used to exclude rows after dividing them into groups."},
    {"label": "D", "text": "The HAVING clause can be used with aggregate functions in subqueries."},
    {"label": "E", "text": "The WHERE clause can be used to exclude rows before dividing them into groups."}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "A.where 和 having 子句中用到的列没有相关联性 B.HAVING 可以使用未在 SELECT 中显示的聚合函数 C.WHERE 是在分组 前 执行的，不能用于分组后的数据。分组后筛选必须用 HAVING "
},
{
  "QuestionID": 106,
  "QuestionType": "multiple",
  "QuestionText": "Your database instance was shut down normally and then started in NOMOUNT state. You then execute this command: ALTER DATABASE MOUNT; Which two actions are performed? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The online redo logs are opened"},
    {"label": "B", "text": "The online data files are opened"},
    {"label": "C", "text": "The alert log records the execution details"},
    {"label": "D", "text": "The Oracle background processes are started"},
    {"label": "E", "text": "The initialization parameter file is read"},
    {"label": "F", "text": "The control file is read"}
  ],
  "CorrectAnswer": ["C", "F"],
  "Explanation": "1.NOMOUNT:实例启动，但数据库还没有挂载。读取 初始化参数文件(SPFILE 或 PFILE)。启动Oracle后台进程(如 SMON、PMON、DBWR 等)。不读控制文件。不打开数据文件和重做日志。2.MOUNT:使用 ALTER DATABASE MOUNT 或 STARTUP MOUNT。读取 控制文件。可以进行数据库恢复和修改操作(例如修改表空间)。不打开数据文件。不打开在线重做日志(redo log)。3.OPEN:使用 ALTER DATABASE OPEN。数据库可以正常访问。打开数据文件和 redo log。"
},
{
  "QuestionID": 107,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about shrinking a segment online? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is not possible to shrink either indexes or Index Organized Tables (IOTs)"},
    {"label": "B", "text": "It always eliminates all migrated rows if any exist in the table"},
    {"label": "C", "text": "To shrink a table it must have a PRIMARY KEY constraint"},
    {"label": "D", "text": "To shrink a table it must have a UNIQUE KEY constraint"},
    {"label": "E", "text": "To shrink a table it must have row movement enabled"},
    {"label": "F", "text": "It must be in a tablespace that uses Automatic Segment Space Management (ASSM)"}
  ],
  "CorrectAnswer": ["E", "F"],
  "Explanation": "在 Oracle 中，ALTER TABLE ... SHRINK SPACE 可以用来释放表或索引占用的空间，同时整理表中的行，使它们尽量紧凑地存储。它可以 在线（online） 执行，也就是在收缩表的同时，应用仍然可以对表进行 DML 操作（INSERT、UPDATE、DELETE）Online shrink 只能在使用 ASSM 的表空间中执行，因为 ASSM 才能管理空闲空间并允许在线段收缩。必须启用行移动（row movement）。A.在线收缩 不能直接收缩 IOT（Index Organized Table），但普通表的索引是可以收缩的（ALTER INDEX ... SHRINK SPACE）。"
},
{
  "QuestionID": 108,
  "QuestionType": "single",
  "QuestionText": "What must you do before executing it?",
  "ImageURL": "images/q108.png",
  "Options": [
    {"label": "A", "text": "Ensure there are no pending transactions on the table."},
    {"label": "B", "text": "Disable all indexes on the table."},
    {"label": "C", "text": "Ensure free space that is approximately equal to the space used by the table should be available."},
    {"label": "D", "text": "Enable row movement is enabled."}
  ],
  "CorrectAnswer": ["D"],
  "Explanation": "SHRINK SPACE 是 Oracle 用来回收表的空闲空间 的命令。COMPACT 表示 仅整理行，使行紧凑，不立即收回空间。COMPACT 只是重排行，把空闲空间集中到段的末尾，但不会立即减少段大小。如果想最终释放空间，需要执行 SHRINK SPACE（不带 COMPACT）或再执行 SHRINK SPACE 不带 COMPACT。"
},
{
  "QuestionID": 109,
  "QuestionType": "single",
  "QuestionText": "You want to reduce fragmentation and reclaim unused space for the sales table but not its dependent objects. During this operation, you want to ensure the following:\ni. Long-running queries are not affected.\nii. No extra space is used.\niii. Data manipulation language (DML) operations on the table succeed at all times throughout the process\niv. Unused space is reclaimed both above and below the high water mark.\nWhich ALTER TABLE option would you recommend?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "DEALLOCATE UNUSED"},
    {"label": "B", "text": "SHRINK SPACE CASCADE"},
    {"label": "C", "text": "SHRINK SPACE COMPACT"},
    {"label": "D", "text": "ROW STORE COMPRESS BASIC"}
  ],
  "CorrectAnswer": ["C"],
  "Explanation": "(high water mark)HWM = 表空间使用的“最高标记”，不是实际数据量，而是已分配过的最高位置.A.只会释放表尾的未使用块。不能释放 HWM 以下的空间，也不能处理表中间的碎片 B.可以收回表和依赖的对象（索引）的空间。但题目要求不要影响 dependent objects，而 CASCADE 会同时移动索引等依赖对象。D.这是表压缩选项，主要用来减少存储占用，提高查询性能,不是专门用来回收碎片，也可能需要额外空间,SHRINK SPACE → 回收碎片、释放空间ROW STORE COMPRESS BASIC → 压缩数据，提高存储利用率"
},
{
  "QuestionID": 110,
  "QuestionType": "multiple",
  "QuestionText": "Which four actions are possible during an Online Datafile Move operation?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Creating and dropping tables in the datafile being moved"},
    {"label": "B", "text": "Performing file shrink of the data file being moved"},
    {"label": "C", "text": "Querying tables in the datafile being moved"},
    {"label": "D", "text": "Performing Block Media Recovery for a data block in the datafile being moved"},
    {"label": "E", "text": "Flashing back the database"},
    {"label": "F", "text": "Executing DML statements on objects stored in the datafile being moved"}
  ],
  "CorrectAnswer": ["A", "C", "D", "F"],
  "Explanation": "Online Datafile Move可以在表空间在线（不需要关闭数据库）的情况下，把数据文件从一个位置移动到另一个位置或不同的磁盘卷上。表和索引在移动期间仍然可以访问。移动过程尽量不阻塞用户操作。移动是在线进行的，但有些操作是受限的。A.在线数据文件移动不会阻止对该文件中表的 DDL（创建、删除表等）操作 B.File shrink是收缩文件空间的操作，需要对文件本身做结构性调整。在线移动期间，数据文件正在被 Oracle 系统操作，无法同时执行收缩操作。D.Block Media Recovery (BMR) 是针对单个数据块的恢复操作。在线数据文件移动不影响 BMR，可以在需要的时候修复特定数据块。"
},
{
  "QuestionID": 111,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the SQL*Loader (sqlldr) execution? (Choose two.)",
  "ImageURL": "images/q111.png",
  "Options": [
    {"label": "A", "text": "It overwrites data in EMP with data in EMP.DAT"},
    {"label": "B", "text": "It uses the database buffer cache to load data"},
    {"label": "C", "text": "It generates a log that contains control file entries, which can be used with normal SQL*Loader operations"},
    {"label": "D", "text": "It generates a SQL script that it uses to load data from EMP.DAT to EMP"},
    {"label": "E", "text": "It appends data from EMP.DAT to EMP"}
  ],
  "CorrectAnswer": ["C", "E"],
  "Explanation": "SQL*Loader(sqlldr) 可以有三种模式来加载数据：1.INSERT插入数据到表中。表必须为空，如果表已经存在数据，会报错。2.APPEND（默认模式）在现有数据基础上追加数据。3.REPLACE删除表中原有数据，然后加载新数据。如果没有在命令中指定，默认模式是APPEND。B.SQL*Loader 默认使用 直接路径（direct path）或常规路径（conventional path）。直接路径加载会绕过数据库缓冲区。常规路径加载会使用 SQL 插入操作，但不等同于直接操作缓存。"
},
{
  "QuestionID": 112,
  "QuestionType": "single",
  "QuestionText": "A script abc.sql must be executed to perform a job. A database user HR, who is defined in this database, executes this command:\n$ sqlplus hr/hr@orcl @abc.sql\nWhat will happen upon execution?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The command succeeds and HR will be connected to the orcl and abc.sql databases"},
    {"label": "B", "text": "The command succeeds and HR will be connected to the orcl database instance, and the abc.sql script will be executed"},
    {"label": "C", "text": "The command fails because the script must refer to the full path name"},
    {"label": "D", "text": "The command fails and reports an error because @ is used twice"}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "命令行提示符 $（普通用户）或 #（root 用户）来表示可以输入命令。sqlplus 是启动 Oracle SQL*Plus 客户端的命令。hr/hr@orcl表示:用户名hr,密码hr,数据库实例orcl（TNS alias，表示要连接的数据库）,所以执行这个命令后，SQL*Plus会尝试连接到orcl数据库，使用 HR 用户。@abc.sql在 SQL*Plus 中，@filename 用于执行SQL脚本文件,这里的 abc.sql 可以是：当前目录下的文件或者指定完整路径（如 /home/oracle/abc.sql）。SQL*Plus会读取这个文件，并执行里面的SQL命令。"
},
{
  "QuestionID": 113,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true regarding indexes? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A UNIQUE index can be altered to be non-unique"},
    {"label": "B", "text": "A SELECT statement can access one or more indexes without accessing any tables"},
    {"label": "C", "text": "A table belonging to one user can have an index that belongs to a different user"},
    {"label": "D", "text": "An update to a table can result in updates to any or all of the table’s indexes"},
    {"label": "E", "text": "When a table is dropped and is moved to the RECYCLE BIN, all indexes built on that table are permanently dropped"},
    {"label": "F", "text": "An update to a table can result in no updates to any of the table’s indexes"}
  ],
  "CorrectAnswer": ["C", "D", "F"],
  "Explanation": "索引在数据库中主要作用是提高查询效率，并在某些情况下维护数据完整性（如 UNIQUE 或 PRIMARY KEY）。A.UNIQUE 索引本身不能直接改成非唯一索引。你需要先删除索引，然后重新创建为非唯一索引。B.如果查询中需要的列 不在索引里，数据库仍然需要回表。并不是所有索引都是覆盖索引，只有当索引包含查询所需的所有列时才是。E.当表被放入 RECYCLE BIN 时，表和它的索引都暂时保留在回收站中，可以用 FLASHBACK TABLE 恢复。DF.对表的更新可能导致对表的任何或所有索引的更新,例如:更新表的列是索引的列,也可能不会导致对表索引的任何更新,例如:更新表的列不是索引的列"
},
{
  "QuestionID": 114,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about Oracle synonyms? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A synonym cannot be created for a PL/SQL package"},
    {"label": "B", "text": "A synonym can be available to all users"},
    {"label": "C", "text": "A SEQUENCE can have a synonym"},
    {"label": "D", "text": "A synonym created by one user can refer to an object belonging to another user"},
    {"label": "E", "text": "Any user can drop a PUBLIC synonym"}
  ],
  "CorrectAnswer": ["B", "C", "D"],
  "Explanation": "Synonym相当于是一个别名，用来引用数据库中的其他对象（表、视图、序列、存储过程、函数、包等）。简化了对象访问（不用写完整的schema.object）。屏蔽对象实际所属 schema 或位置。Private synonym（私有同义词）：只能由创建它的用户访问。Public synonym（公共同义词）：所有用户都可以访问。只有属主和有drop public synonym权限的用户才能够删除public同义词。C.SEQUENCE（序列）是一个独立的数据库对象，用来生成唯一的、按顺序递增或递减的数字"
},
{
  "QuestionID": 115,
  "QuestionType": "multiple",
  "QuestionText": "Which two tasks can be performed on an external table?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Partitioning the table"},
    {"label": "B", "text": "Creating an invisible index"},
    {"label": "C", "text": "Updating the table by using an UPDATE statement"},
    {"label": "D", "text": "Creating a public synonym"},
    {"label": "E", "text": "Creating a view"}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "外部表（External Table）是 Oracle 提供的一种功能，让你可以 像查询普通表一样访问数据库外部的文件（比如 CSV、文本文件等）。数据存储在数据库外部，Oracle 只是“读取”它。可以用 SELECT 查询数据。不能进行 DML 操作（INSERT、UPDATE、DELETE），因为数据不在数据库里。E.视图 = 一张“查询结果表”，用来看数据，但不存数据本身"
},
{
  "QuestionID": 116,
  "QuestionType": "single",
  "QuestionText": "Which is true?",
  "ImageURL": "images/q116.png",
  "Options": [
    {"label": "A", "text": "It performs the export successfully."},
    {"label": "B", "text": "It throws an error as the table test_employees is empty and CONTENT=data_only is specified."},
    {"label": "C", "text": "It throws an error as the QUERY parameter is not supported on an empty table."},
    {"label": "D", "text": "It throws an error as Data Pump cannot find a table called TEST.EMP."}
  ],
  "CorrectAnswer": ["D"],
  "Explanation": "Oracle Data Pump 是 Oracle 提供的一种高速数据导入/导出工具，用来在数据库之间迁移数据或备份表、模式、表空间等。它的命令行工具有两个：expdp → Export Data Pump：导出数据（生成 .dmp 文件）。impdp → Import Data Pump：导入数据（从 .dmp 文件恢复数据）。比传统 exp/imp 快，支持并行导出/导入，支持导出表、视图、模式、表空间。支持通过 查询过滤导出部分数据。可以导出到服务器上指定的目录，而不是客户端。本题:创建了DIRECTORY dumpdir一个物理目录，给了所有用户读写public权限，创建了一个新用户TEST密码是test，TEST创建了一个test_employees表格，为 test_employees 表创建了一个 同义词 emp。最后指令TABLES=emp 指定了要导出的对象是emp。但emp是同义词，不是表，Data Pump 不直接支持导出同义词，它只能导出 表、视图、模式等真实对象。即使emp指向test_employees，Data Pump仍然会报错：“找不到表 TEST.EMP”。"
},
{
  "QuestionID": 117,
  "QuestionType": "multiple",
  "QuestionText": "You issue the following command to drop the PRODUCTS table:\nSQL > DROP TABLE products;\nWhich three statements are true about the implication of this command?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "All data along with the table structure is deleted."},
    {"label": "B", "text": "A pending transaction in the session is committed."},
    {"label": "C", "text": "All indexes on the table remain but they are invalidated."},
    {"label": "D", "text": "All views and synonyms on the table remain but they are invalidated."},
    {"label": "E", "text": "All data in the table is deleted but the table structure remains."}
  ],
  "CorrectAnswer": ["A", "B", "D"],
  "Explanation": "B.Oracle 中 DDL 自动提交，Oracle在执行DROP TABLE前，会隐式提交当前会话里的所有未提交事务。"
},
{
  "QuestionID": 118,
  "QuestionType": "multiple",
  "QuestionText": "Which two tasks require subqueries? (Choose two.)",
  "ImageURL": "images/q118.png",
  "Options": [
    {"label": "A", "text": "Display the number of products whose PROD_LIST_PRICE is more than the average PROD_LIST_PRICE"},
    {"label": "B", "text": "Display suppliers whose PROD_LIST_PRICE is less than 1000"},
    {"label": "C", "text": "Display products whose PROD_MIN_PRICE is more than the average PROD_LIST_PRICE of all products, and whose status is orderable"},
    {"label": "D", "text": "Display the total number of products supplied by supplier 102 which have a product status of obsolete"},
    {"label": "E", "text": "Display the minimum PROD_LIST_PRICE for each product status"}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": ""
},
{
  "QuestionID": 119,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements must be true so that the SALES user can create tables in SALES_Q1? (Choose three.)",
  "ImageURL": "images/q119.png",
  "Options": [
    {"label": "A", "text": "The sales user must have a quota on the TEMP tablespace"},
    {"label": "B", "text": "The sales user must have a quota on the SALES_Q1 tablespace to hold the initial extends of all tables they plan to create in their schema"},
    {"label": "C", "text": "The sales user must have been granted the CREATE SESSION privilege"},
    {"label": "D", "text": "The sales user must have their quota on the users tablespace removed"},
    {"label": "E", "text": "The sales user must have a quota on the SALES_Q1 tablespace to hold all the rows to be inserted into any table in their schema"},
    {"label": "F", "text": "The sales user must have been granted the CREATE TABLE privilege"}
  ],
  "CorrectAnswer": ["B", "C", "F"],
  "Explanation": "命令解析:先创建了个用户和密码，但是没给权限。用户创建后，如果没有其他权限，他还不能登录数据库，因为缺少登录权限（CREATE SESSION）。DEFAULT TABLESPACE sales_q1指定该用户的默认表空间为 sales_q1。这意味着：当该用户创建表或索引时，如果不指定 TABLESPACE 子句，这些对象会默认保存在 sales_q1 表空间中。但是要在这个表空间中存储数据，还必须有配额 (quota)。TEMPORARY TABLESPACE temp指定该用户使用的临时表空间。临时表空间用于排序、哈希连接、创建索引等操作的临时数据。普通用户不需要配额使用临时表空间（临时空间不算 quota 限制）。QUOTA 5M ON users;给sales用户在users表空间上分配5MB的使用额度。A.临时表空间不需要配额。它只是用来放排序或中间结果，Oracle自动管理。"
},
{
  "QuestionID": 120,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about table data storage in an Oracle Database? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Data block headers contain their own Data Block Address (DBA)"},
    {"label": "B", "text": "A table row piece can be chained across several database blocks"},
    {"label": "C", "text": "Multiple row pieces from the same row may be stored in different database blocks"},
    {"label": "D", "text": "Multiple row pieces from the same row may be stored in the same block"},
    {"label": "E", "text": "Data block free space is always contiguous in the middle of the block"},
    {"label": "F", "text": "Index block free space is always contiguous in the middle of the block"}
  ],
  "CorrectAnswer": ["A", "B", "C"],
  "Explanation": "A.每个数据块（Data Block）是最小的存储单位。每个数据块由三个主要部分组成：1.Block Header（块头）2.Table Directory / Row Directory（表和行目录）3.Free space + Row data（空闲区和行数据）块头 (Header) 存放元信息，例如：该块的类型（数据块、索引块等）,块所属的段（segment）信息,事务信息（事务槽）,DBA（Data Block Address） — 数据块的物理地址（数据文件号 + 块号）B.一个“行（row）”的数据可能太大，无法完全放进一个数据块,Oracle会将该行拆成多个row piece（行片段）。如果这些行片段分布在不同的数据块中，就叫做 chained row（行链式存储）。"
},
{
  "QuestionID": 121,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true? (Choose two.)",
  "ImageURL": "images/q121.png",
  "Options": [
    {"label": "A", "text": "The second ROLLBACK command does nothing"},
    {"label": "B", "text": "The second ROLLBACK command replays the delete"},
    {"label": "C", "text": "The first ROLLBACK command restores the 101 rows that were deleted, leaving the inserted row still to be committed"},
    {"label": "D", "text": "The second ROLLBACK command undoes the insert"},
    {"label": "E", "text": "The first ROLLBACK command restores the 101 rows that were deleted and commits the inserted row"}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": "1.初始状态(已提交)100行 → 2.INSERT 101行(未提交) → 3.SAVEPOINT a 101行 → 4.DELETE 0行 → 5.ROLLBACK TO a 101行 → 6.ROLLBACK 100行,最后一个rollback指整个事务回滚"
},
{
  "QuestionID": 122,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about external tables in Oracle 18c and later releases? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "External table files can be used for other external tables in a different database"},
    {"label": "B", "text": "The ORACLE_LOADER access driver can be used to unload data from a database into an external table"},
    {"label": "C", "text": "The ORACLE_DATAPUMP access driver can be used to unload data from a database into an external table"},
    {"label": "D", "text": "They cannot be partitioned"},
    {"label": "E", "text": "The ORACLE_DATAPUMP access driver can be used to load data into a database from an external table"},
    {"label": "F", "text": "They support UPDATEs but not INSERTs and DELETEs"}
  ],
  "CorrectAnswer": ["A", "C", "E"],
  "Explanation": "A.外部表只在定义时绑定数据库，实际数据文件可以跨数据库共享。\nB.ORACLE_LOADER 是用于读取文本/CSV 文件作为外部表的驱动，不支持“从数据库导出到外部表”.它只支持 读取（LOAD）文件到查询，而不用于写出（UNLOAD）数据.\nC.ORACLE_DATAPUMP支持 Data Pump 文件的读写。它可以将数据库表数据导出到 Data Pump 文件，从而实现外部表“卸出（unload）数据”.E一样，也可以load\nD.从 12c 开始，外部表是支持分区（partitioned external table）。\nF.外部表本质上是只读的（除非使用特殊的可写外部表），默认 不支持 UPDATE、INSERT、DELETE"
},
{
  "QuestionID": 123,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about the Oracle join and ANSI join syntax? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The Oracle join syntax supports creation of a Cartesian product of two tables"},
    {"label": "B", "text": "The Oracle join syntax performs better than the SQL:1999 compliant ANSI join syntax"},
    {"label": "C", "text": "The SQL:1999 compliant ANSI join syntax supports natural joins"},
    {"label": "D", "text": "The SQL:1999 compliant ANSI join syntax supports creation of a Cartesian product of two tables"},
    {"label": "E", "text": "The Oracle join syntax only supports right outer joins"},
    {"label": "F", "text": "The Oracle join syntax supports natural joins"},
    {"label": "G", "text": "The Oracle join syntax performs less well than the SQL:1999 compliant ANSI join syntax"}
  ],
  "CorrectAnswer": ["A", "C", "D"],
  "Explanation": "Oracle join syntax(旧式):\n-1.使用 (+) 表示外连接\n-2.可以产生 Cartesian product\n-3.不支持 NATURAL JOIN\n-4.LEFT/RIGHT OUTER JOIN都支持\nANSI join syntax(SQL-1999):\n-1.使用 INNER/LEFT/RIGHT/FULL JOIN ... ON ...\n-2.支持 NATURAL JOIN 和 CROSS JOIN\n-3.可读性更高,标准 SQL\n-4.性能与 Oracle join 语法相同,由优化器决定\n笛卡尔积:\n-1.没有连接条件时,表 A 的每行与表 B 的每行组合\n-2.行数 = 表 A 行数 × 表 B 行数\nA.如果使用 Oracle 的旧式连接语法（没有 WHERE 条件或 ON 条件），两张表会生成笛卡尔积（Cartesian product）。\nB.现代 Oracle 优化器对 ANSI join 和 Oracle join 的性能几乎一样。性能取决于执行计划，而不是语法本身\nE.Oracle join 语法支持 LEFT OUTER JOIN 和 RIGHT OUTER JOIN，并不仅限于右外连接\nF.NATURAL JOIN 属于ANSI标准语法，而非Oracle传统语法"
},
{
  "QuestionID": 124,
  "QuestionType": "multiple",
  "QuestionText": "Which two tasks can you perform using DBCA for databases? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Configure a nonstandard block size for a new database"},
    {"label": "B", "text": "Register a new database with an available Enterprise Manager Management server"},
    {"label": "C", "text": "Change the standard block size of an existing database"},
    {"label": "D", "text": "Configure incremental backups for a new database"},
    {"label": "E", "text": "Enable flashback database for an existing database"}
  ],
  "CorrectAnswer": ["A", "B"],
  "Explanation": "DBCA（Database Configuration Assistant） 是 Oracle 提供的图形化或命令行工具，用于创建、配置和删除数据库，以及注册数据库到 Oracle Enterprise Manager（OEM）。\nA.DBCA 可以在创建新数据库时配置非标准数据块大小（nonstandard block size），比如 8KB、16KB、32KB 等，满足特定应用需求。标准数据块大小通常是 8KB；\nC.数据库创建完成后，标准块大小无法修改，这是数据库结构的一部分。\nD.DBCA本身不负责配置备份策略。备份需要使用 RMAN（Recovery Manager）进行配置和管理\nE.DBCA可以在创建新数据库时选择启用 Flashback Database，但不支持对已存在的数据库启用，这需要通过SQL命令或RMAN配置。"
},
{
  "QuestionID": 125,
  "QuestionType": "single",
  "QuestionText": "You plan to create a database by using the Database Configuration Assistant (DBCA), with the following specifications:\n- Applications will connect to the database via a middle tier.\n- The number of concurrent user connections will be high.\n- The database will have mixed workload, with the execution of complex BI queries scheduled at night.\nWhich DBCA option must you choose to create the database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A General Purpose database template with default memory allocation"},
    {"label": "B", "text": "A Data Warehouse database template, with the dedicated server mode option and AMM enabled"},
    {"label": "C", "text": "A General Purpose database template, with the shared server mode option and Automatic Memory Management (AMM) enabled"},
    {"label": "D", "text": "A default database configuration"}
  ],
  "CorrectAnswer": ["C"],
  "Explanation": "1.中间层连接:\n应用程序不会直接连接数据库,而是通过中间层(Middle Tier)连接。中间层通常使用共享服务器(Shared Server)模式来处理大量并发连接\n2.高并发用户连接:表明数据库可能有成百上千个连接\n3.混合工作负载:白天有OLTP(Online Transaction Processing,联机事务处理操作:插入INSERT、更新UPDATE、删除DELETE、查询SELECT),晚上有复杂BI(Complex Business Intelligence复杂商业智能分析)查询(批量分析/报表).数据库需要灵活的内存管理来适应不同负载\nA.General Purpose模板适合小到中型OLTP应用,默认内存分配通常比较保守。对于高并发和混合负载的情况可能性能不足\nB.Data Warehouse模板适合大规模批量处理和分析(ETL/BI),优化为复杂查询性能。但题目中白天有大量中间层并发用户连接，使用 Dedicated Server 模式会消耗过多资源,不适合高并发OLTP场景。"
},
{
  "QuestionID": 126,
  "QuestionType": "multiple",
  "QuestionText": "Which two options can be configured for an existing database by using the Database Configuration Assistant (DBCA)?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Database Resident Connection Pooling"},
    {"label": "B", "text": "Oracle Suggested Backup Strategy"},
    {"label": "C", "text": "Database Vault in ORACLE_HOME"},
    {"label": "D", "text": "Non default block size tablespaces"},
    {"label": "E", "text": "Configure Label Security"}
  ],
  "CorrectAnswer": ["C", "E"],
  "Explanation": "A.DRCP是Oracle提供的轻量级连接池，用于中间层应用的高并发场景。配置DRCP不能通过DBCA，需要使用SQL/PLSQL或DBMS_CONNECTION_POOL包手动配置。\nB.DBCA不配置备份策略。备份策略需要使用RMAN（Recovery Manager）或其他工具手动配置。\nC.DBCA 可以为现有数据库启用或配置Database Vault（安全策略模块）,Database Vault提供访问控制、管理隔离和多重安全策略。配置路径通常位于 ORACLE_HOME 中。\nD.数据库创建后，标准块大小无法修改."
},
{
  "QuestionID": 127,
  "QuestionType": "single",
  "QuestionText": "You execute this query:\nSELECT TO_CHAR(NEXT_DAY(LAST_DAY(SYSDATE), ‘MON’), ‘dd “Monday for” fmMonthrrrr’)\nWhat is the result?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It executes successfully but does not return any result"},
    {"label": "B", "text": "It returns the date for the first Monday of the next month"},
    {"label": "C", "text": "It generates an error"},
    {"label": "D", "text": "It returns the date for the last Monday of the current month"}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "LAST_DAY(SYSDATE)返回当前月的最后一天。\n‘dd “Monday for” fmMonthrrrr’ → dd是天，“Monday for”是string不变，fmMonth表示月名全称，fm去掉前导空格rrrr表示年份。例如:03 Monday for November2025"
},
{
  "QuestionID": 128,
  "QuestionType": "multiple",
  "QuestionText": "Examine this command:\nCREATE UNDO TABLESPACE undotbs01\nDATAFILE ‘undotbs_01.dbf’\nSIZE 100M\nAUTOEXTEND ON;\nWhich two actions must you take to ensure UNDOTBS01 is used as the default UNDO tablespace? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Add the SEGMENT SPACE MANAGEMENT AUTO clause"},
    {"label": "B", "text": "Set UNDO_TABLESPACE to UNDOTBS01"},
    {"label": "C", "text": "Add the NOLOGGING clause"},
    {"label": "D", "text": "Make certain that the database operates in automatic undo management mode"},
    {"label": "E", "text": "Add the ONLINE clause"}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "UNDO 表空间用于存储回滚信息（undo data）Oracle 有两种 Undo 管理模式：1.手动 Undo 管理（Manual Undo Management）：通过回滚段（rollback segment）2.自动 Undo 管理（Automatic Undo Management, AUM）：通过UNDO表空间.要使用默认UNDO表空间，数据库必须处于AUM模式\nA.SEGMENT SPACE MANAGEMENT AUTO 是为表空间的段空间管理,提供自动管理功能,对UNDO表空间不是必须的\nC.NOLOGGING 用于减少日志生成，通常用于临时表或大批量导入,对 UNDO 表空间默认选择没有影响\nE.ONLINE 表示表空间立即可用对默认 UNDO 表空间选择不是必须的"
},
{
  "QuestionID": 129,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about views in an Oracle database? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Views can be updated without the need to re-grant privileges on the view"},
    {"label": "B", "text": "Tables in the defining query of a view must always exist in order to create the view"},
    {"label": "C", "text": "The WITH CHECK clause prevents certain rows from being displayed when querying the view"},
    {"label": "D", "text": "Data Manipulation Language (DML) can always be used on views"},
    {"label": "E", "text": "Inserting one or more rows using a view whose defining query contains a GROUP BY clause will cause an error"},
    {"label": "F", "text": "Deleting one or more rows using a view whose defining query contains a GROUP BY clause will cause an error"},
    {"label": "G", "text": "The WITH CHECK clause prevents certain rows from being updated or inserted"}
  ],
  "CorrectAnswer": ["E", "F", "G"],
  "Explanation": "视图（View）虚拟表，不存储数据可基于一个或多个表或视图\n可更新条件（可使用DML）：1.单表视图 2.不含 GROUP BY、DISTINCT、聚合函数 3.不含子查询或连接 \n不可更新视图：聚合视图、复杂连接视图、含 DISTINCT 的视图\nA.如果使用 CREATE OR REPLACE VIEW 修改视图，之前授予的权限会被删除。\nB.如果使用 CREATE VIEW ... FORCE，即使表不存在也能创建视图,默认的 CREATE VIEW ... 需要表存在\nC.WITH CHECK OPTION 并不限制查询结果的显示，它限制 通过视图插入或更新的数据，确保插入/更新的数据符合视图的条件\nD.如果视图包含 GROUP BY、DISTINCT、JOIN、聚合函数等，一般不能直接执行 INSERT/UPDATE/DELETE"
},
{
  "QuestionID": 130,
  "QuestionType": "single",
  "QuestionText": "In the SALES database, DEFERRED_SEGMENT_CREATION is TRUE. Examine this command:\nSQL> CREATE TABLE T1(c1 INT PRIMARY KEY, c2 CLOB);\nWhich segment or segments, if any, are created as a result of executing the command?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "T1, an index segment for the primary key, a LOB segment, and a lobindex segment"},
    {"label": "B", "text": "No segments are created"},
    {"label": "C", "text": "T1 only"},
    {"label": "D", "text": "T1 and an index segment created for the primary key only"},
    {"label": "E", "text": "T1, an index segment for the primary key, and a LOB segment only"}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "因为段创建延迟设置为 true，建表时只要没有数据，段是不会创建的。"
},
{
  "QuestionID": 131,
  "QuestionType": "single",
  "QuestionText": "Choose the best answer. Which statement is true about database links?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A public database link can be created only by SYS."},
    {"label": "B", "text": "A database link created in a database allows a connection from that database's instance to the target database's instance, but not vice versa."},
    {"label": "C", "text": "A public database link can be used by a user connected to the local database instance to connect to any schema in the remote database instance."},
    {"label": "D", "text": "Private database link creation requires the same user to exist in both the local and the remote databases."},
    {"label": "E", "text": "A database link can be created only between two Oracle databases."}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "数据库链接DB Link用于在一个数据库实例中访问另一个远程数据库实例的数据\n1.数据库链接类型:Private DB Link只对创建它的用户可见。Public DB Link对所有用户可见。\n2.连接方向DB Link允许从本地数据库访问远程数据库,不自动允许远程数据库访问本地数据库\n3.目标数据库访问权限:用户需要在远程数据库中有对应的账户或使用远程用户名和密码\nA.公共数据库链接必须由拥有CREATE PUBLIC DATABASE LINK权限的用户创建\nB.DB Link使用远程数据库的指定用户名,即使是 Public DB Link，也只能访问该远程用户名有权限访问的对象\nD.私有DB Link不要求本地和远程用户同名。关键是:创建链接时指定远程用户名和密码即可\nE.可以创建指向自已DBLINK连接"
},
{
  "QuestionID": 132,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about views in an Oracle Database? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Rows inserted into a table using a view are retained in the table if the view is dropped."},
    {"label": "B", "text": "A view can be created that refers to a non-existent table in its defining query."},
    {"label": "C", "text": "Views have no object number."},
    {"label": "D", "text": "Views have no segment."},
    {"label": "E", "text": "A SELECT statement cannot contain a WHERE clause when querying a view containing a WHERE clause in its defining query."},
    {"label": "F", "text": "Views can join tables only if they belong to the same schema."}
  ],
  "CorrectAnswer": ["A", "B", "D"],
  "Explanation": "A.视图 不存储数据，只是查询定义,通过视图插入的数据最终存储在 底层表 中,如果删除视图，数据仍然保存在表中\nB.CREATE VIEW ... FORCE 可以创建指向不存在表的视图,CREATE VIEW ... 默认要求表必须存在,FORCE 允许先创建视图，稍后再创建表\nC.视图也是数据库对象，在 USER_OBJECTS或ALL_OBJECTS中有OBJECT_ID,所以视图是有对象编号的\nF.视图可以引用不同 schema 的表,使用 schema_name.table_name 即可"
},
{
  "QuestionID": 133,
  "QuestionType": "multiple",
  "QuestionText": "Which two tasks can be performed in the NOMOUNT state?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Full database recovery"},
    {"label": "B", "text": "Re-creating control files"},
    {"label": "C", "text": "Renaming data files"},
    {"label": "D", "text": "Creating a database"},
    {"label": "E", "text": "Enabling online redo log archiving"}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "NOMOUNT 状态特点:SGA 已启动，后台进程已启动,控制文件未装入.适合：1.创建数据库 2.重新创建控制文件 3.修改初始化参数（如 DB_NAME）\nMOUNT 状态特点:控制文件已装入,数据文件未打开. 适合：1.数据库恢复 2.数据文件（重命名，添加数据文件）或日志文件操作3.启用归档模式\nOPEN 状态特点:数据库完全可用,可以执行普通查询、DML、DCL 等"
},
{
  "QuestionID": 134,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about dynamic performance views?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "They are owned by the SYSTEM user."},
    {"label": "B", "text": "V$FIXED_TABLE can be queried to display the name of all dynamic performance views."},
    {"label": "C", "text": "Data displayed by querying dynamic performance views is derived from metadata in the data dictionary."},
    {"label": "D", "text": "Data displayed by querying dynamic performance views is derived from memory structures."},
    {"label": "E", "text": "They can be queried only when the database is open."},
    {"label": "F", "text": "Read consistency is not guaranteed."}
  ],
  "CorrectAnswer": ["B", "D", "F"],
  "Explanation":"动态性能视图（通常以 V$ 开头）用于监控数据库实例的运行状态，提供关于 内存结构、锁、会话、缓冲区、性能统计 等信息。1.数据来源：SGA/PGA 内存结构，而非数据字典表2.用户权限：通常通过 PUBLIC权限访问3.使用场景：数据库性能诊断、调优\nA.动态性能视图实际 物理拥有者是SYS用户,系统中对普通用户开放的是 PUBLIC synonym\nB.V$FIXED_TABLE 是 V$视图的目录视图,可以列出所有动态性能视图及其对应的底层固定表（fixed tables）\nE.V$视图中部分视图在 NOMOUNT 或 MOUNT 状态也可以访问,并非必须数据库 OPEN,例如 V$PARAMETER 可在 NOMOUNT 状态查询初始化参数\nF.动态性能视图反映的是运行时内存状态,数据可能在查询过程中发生变化,因此不保证读一致性"
},
{
  "QuestionID": 135,
  "QuestionType": "multiple",
  "QuestionText": "Which two are benefits of external tables?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The results of a complex join or aggregating function or both can be unloaded to a file for transportation to another database."},
    {"label": "B", "text": "They can be queried while the database is in the MOUNT state like dynamic performance views."},
    {"label": "C", "text": "They support DELETES which transparently deletes records in the file system as if they were table rows."},
    {"label": "D", "text": "They support UPDATES which transparently updates records in the file system as if they were table rows."},
    {"label": "E", "text": "They can be queried, transformed, and joined with other tables without having to load the data first."}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": "E.外部表最大优势之一：无需先把文件数据加载到表中就能用 SQL 查询支持 JOIN、WHERE、GROUP BY、ORDER BY 等操作"
},
{
  "QuestionID": 136,
  "QuestionType": "multiple",
  "QuestionText": "DATADIR1 and DATADIR2 are database directory objects. Examine this command:\n[oracle@host01 ~] expdp system/oracle \\\n> FULL=Y \\\n> DUMPFILE=datadir1:full%U.dmp, datadir2:full%U.dmp \\\n> FILESIZE=2G \\\n> PARALLEL=4 \\\n> LOGFILE=datadir1:/expfull.log \\\n> JOB_NAME=expfull\nWhich two statements are true about the expdp operation?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It starts only when four worker processes are available."},
    {"label": "B", "text": "It fails if the total size of the dump file is more than 2GB."},
    {"label": "C", "text": "It creates dump files only for objects in the SYSTEM schema."},
    {"label": "D", "text": "It creates dump files for the entire database."},
    {"label": "E", "text": "It creates a master table to store details of the export operation."}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "使用 Data Pump Export（expdp） 工具导出数据库。\n•用户是 system。\n•FULL=Y → 导出整个数据库。\n•DUMPFILE 指定多个目录和文件模板%U（自动编号：full01.dmp、full02.dmp…）。\n•FILESIZE=2G → 每个转储文件最大 2GB，超过则生成新文件。\n•PARALLEL=4 → 并行 4 个 worker 进程。\n•LOGFILE 指定日志输出文件。\n•JOB_NAME=expfull → 任务名称。A.Oracle Data Pump 会尽量分配并行度（PARALLEL）指定的 worker 数。但如果一开始没有足够 worker，任务也会启动，只是会动态分配或等待。并不是“等 4 个进程都空闲才开始”。\nB.FILESIZE=2G 限制的是 每个文件的最大大小，不是整个导出总量。当文件到达 2GB 时，Data Pump 自动创建下一个文件（full02.dmp, full03.dmp, …）。\nC.FULL=Y 表示导出整个数据库中 所有 schema\nE.每个 Data Pump 任务都会在执行时，在导出用户的 schema 下创建一个 master table（主表）。用于记录导出的元信息（对象名、文件名、进度等）。作业完成后默认删除"
},
{
  "QuestionID": 137,
  "QuestionType": "multiple",
  "QuestionText": "Which three actions are ways to apply the principle of least privilege?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Revoking execute privilege on UTL_SMTP, UTL_TCP, UTL_HTTP, and UTL_FILE from the PUBLIC user"},
    {"label": "B", "text": "Setting the REMOTE_OS_AUTHENT parameter to true"},
    {"label": "C", "text": "Using Access Control Lists (ACLs)"},
    {"label": "D", "text": "Enabling Unified Auditing"},
    {"label": "E", "text": "Revoking execute privilege on UTL_SMTP, UTL_TCP, UTL_HTTP, and UTL_FILE from the SYSTEM user"},
    {"label": "F", "text": "Setting the 07_DICTIONARY_ACCESSIBILITY parameter to true"}
  ],
  "CorrectAnswer": ["A", "C", "D"],
  "Explanation": "Principle of Least Privilege（最小权限原则） 是数据库安全的基本原则之一：每个用户、进程、应用程序都只能获得完成任务所需的最小权限，不多也不少。\nA.这些包 (UTL_HTTP:HTTP请求,UTL_SMTP:发邮件,UTL_TCP:低层TCP通信,UTL_FILE:操作文件系统)能让 PL/SQL 程序访问外部资源,默认情况下，这些包可能对 PUBLIC（所有用户）可执行。这意味着任何用户都能发HTTP请求、访问文件、甚至外部系统 → 潜在安全风险。所以撤销对 PUBLIC 的 EXECUTE 权限，限制谁能访问这些网络或文件资源，就是典型的“最小权限”做法。\nB.REMOTE_OS_AUTHENT 允许使用 远程操作系统认证。若为 TRUE，则 Oracle 信任来自远程系统的 OS 用户身份（即远程用户可不输入密码直接登录数据库）。这严重削弱安全性，相当于扩大权限而非最小化。\nC.Access Control Lists (ACLs) 可细化控制哪些数据库用户/角色能：发 HTTP 请求;使用 UTL_SMTP、UTL_TCP、UTL_HTTP 等包;访问外部网络资源。通过 ACL，只允许特定用户访问特定主机/端口 → 精确授权 → 完全符合“最小权限原则”。\nD.Unified Auditing 是 Oracle 的统一审计框架。它帮助 DBA 监控谁在用什么权限做什么操作。虽然“审计”本身不是减少权限，但它是实现最小权限原则的重要一环，因为：审计提供监督和可追踪性，帮助发现过度授权并进行调整。审计是最小权限控制的重要辅助手段。\nE.SYSTEM 是 DBA 级别用户，管理数据库必然需要这些访问能力。撤销 SYSTEM 的权限反而会阻止必要的管理操作，不合逻辑。\nF.如果设为 TRUE，则让非-SYS 用户可以直接访问数据字典（SYS schema 下的表视图）。这会 放宽访问控制，导致安全风险增加。"
},
{
  "QuestionID": 138,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the configuration and use of UNDO_RETENTION with no GUARANTEED RETENTION?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Unexpired UNDO is always retained."},
    {"label": "B", "text": "UNDO_RETENTION specifies for how long Oracle attempts to keep expired and unexpired UNDO."},
    {"label": "C", "text": "UNDO_RETENTION specifies how long all types of UNDO are retained."},
    {"label": "D", "text": "Active UNDO is always retained."},
    {"label": "E", "text": "UNDO_RETENTION specifies for how long Oracle attempts to keep unexpired UNDO."}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "UNDO 表空间 保存事务的“旧值”（Undo 数据），主要作用是：回滚未提交事务；支持一致性读（consistent read）；支持闪回查询（flashback）.UNDO_RETENTION:保留undo数据的时间（以秒为单位）。\nA.在 NOGUARANTEE模式下，不一定能保留。如果 undo 空间不够，Oracle 可能覆盖unexpired undo数据。\nB.UNDO_RETENTION 只影响 unexpired undo 的最小保留时间。“expired” undo 已经过期，可以随时重用。\nC.“all types of UNDO” 不准确。1.活跃（active）undo 永远保留直到事务结束。2.过期（expired）undo 可以随时重用。3.未过期（unexpired）undo 是 UNDO_RETENTION 控制的重点。"
},
{
  "QuestionID": 139,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about a full outer join?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It returns only unmatched rows from both tables being joined."},
    {"label": "B", "text": "It returns matched and unmatched rows from both tables being joined."},
    {"label": "C", "text": "The Oracle join operator (+) must be used on both sides of the join condition in the WHERE clause."},
    {"label": "D", "text": "It includes rows that are returned by an inner join."},
    {"label": "E", "text": "It includes rows that are returned by a Cartesian product."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "FULL OUTER JOIN = LEFT OUTER JOIN + RIGHT OUTER JOIN,它返回两张表中 所有匹配行 + 所有不匹配行.\nC.(+ ) 是 Oracle 的旧式语法（Oracle proprietary join syntax），只支持 左外连接 和 右外连接。Full outer join 不支持 (+ ) 语法，只能使用 ANSI 标准语法\nD.因为 inner join 的结果（匹配行）包含在 full outer join 结果集中\nE.笛卡尔积（Cartesian product） 是没有任何连接条件时的结果（A×B）。full outer join 仍然基于连接条件，只是补齐未匹配的行，不会产生全部组合。"
},
{
  "QuestionID": 140,
  "QuestionType": "multiple",
  "QuestionText": "Examine these SQL statements which execute successfully:\nCREATE TABLE emp \n  (emp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY KEY, \n  ename VARCHAR2(15), \n  salary NUMBER(8,2), \n  mgr_no NUMBER(2));\n\nALTER TABLE emp ADD CONSTRAINT emp_mgr_fk \n  FOREIGN KEY (mgr_no) \n  REFERENCES emp (emp_no) \n  ON DELETE SET NULL;\n\nALTER TABLE emp \n  DISABLE CONSTRAINT emp_emp_no_pk \n  CASCADE;\n\nALTER TABLE emp \n  ENABLE CONSTRAINT emp_emp_no_pk;\n\nWhich two statements are true after execution?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The primary key constraint will be enabled and DEFERRED."},
    {"label": "B", "text": "The primary key constraint will be enabled and IMMEDIATE."},
    {"label": "C", "text": "The foreign key constraint will be enabled and IMMEDIATE."},
    {"label": "D", "text": "The foreign key constraint will be disabled."},
    {"label": "E", "text": "The foreign key constraint will be enabled and DEFERRED."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "主键约束和外键约束默认：1.ENABLED（启用）2.IMMEDIATE（立即检查约束）3.NOT DEFERRABLE（不可延迟）\nDISABLE CASCADE禁用主键时，同时禁用引用该主键的外键约束\nENABLE 不传播 → 启用主键不会自动启用外键"
},
{
  "QuestionID": 141,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about row chaining and row migration done by Oracle database block space management?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Update statements can result in one or more migrated rows."},
    {"label": "B", "text": "Insert statements can result in a migrated row."},
    {"label": "C", "text": "A migrated row results in an update to any index on the table to point the rowid in the index to the row's new location."},
    {"label": "D", "text": "Row pieces of a chained row must always reside in different blocks."},
    {"label": "E", "text": "Insert statements can result in a chained row."},
    {"label": "F", "text": "Update statements can result in one or more chained rows."}
  ],
  "CorrectAnswer": ["A", "E", "F"],
  "Explanation": "行迁移（Row Migration）发生条件：UPDATE 导致行在原来所在块无法完全存放,Oracle 会把整行搬到同一表的另一块,原来的数据块只保留一条指向新位置的指针（ROWID）\n行链（Row Chaining）发生条件：INSERT 语句,插入的行太大，无法在一个数据块中存放,或者 分布式数据库 或 多块表空间设置 导致行跨块存储。原始行被拆成多段（row pieces）存放在不同块,ROWID 仍然能指向行的第一段,不仅 UPDATE，INSERT 也会产生行链"
},
{
  "QuestionID": 142,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true regarding Oracle database space management within blocks managed by Automatic Segment Space Management (ASSM)?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Update operations always relocate rows into blocks with free space appropriate to the length of the row being updated."},
    {"label": "B", "text": "Insert operations always insert new rows into blocks with free space appropriate to the length of the row being inserted."},
    {"label": "C", "text": "PCTFREE defaults to 10% for all blocks in all segments for all compression methods."},
    {"label": "D", "text": "The first block with enough free space to accommodate a row being inserted will always be used for that row."},
    {"label": "E", "text": "ASSM assigns blocks to one of four fullness categories based on what percentage of the block is allocated for rows."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "ASSM 的核心作用：自动跟踪哪些块有多少可用空间,自动决定新行要插入哪个块,提升并发性能(多个会话可同时插入),每当执行 INSERT 或 UPDATE，Oracle 都会：查找对应“空闲空间组”的位图（bitmap）；自动选择一个合适的块来放新行或更新后的行\nA.UPDATE 并不会总是搬移行。如果当前块仍有足够空间 → 就地更新；如果空间不够 → 才会行迁移（row migration）\nC.在未指定 PCTFREE 时，Oracle 默认值是 10%。表示每个块预留 10% 空间给 UPDATE 使用。无论是否压缩（compression），PCTFREE 默认都为 10%。可手动改为其他值（如 PCTFREE 20）。\nE.四个“满度等级”fullness categories:full,75%full,50%full,empty/25%full"
},
{
  "QuestionID": 143,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the PMON background process?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It registers database services with all local and remote listeners known to the database instance."},
    {"label": "B", "text": "It frees resources held by abnormally terminated processes."},
    {"label": "C", "text": "It frees unused temporary segments."},
    {"label": "D", "text": "It rolls back transactions when a process fails."},
    {"label": "E", "text": "It records checkpoint information in the control file."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "PMON(Process Monitor)清理异常终止的用户进程，回滚未提交事务，释放锁和资源。清理失败进程的内存。会话异常终止时自动回滚。\nSMON(System Monitor)实例恢复（crash recovery），合并空闲区（coalescing free space），清理临时段。\nLREG(Listener Registration Process)向本地和远程监听器注册实例和服务信息。\nCKPT(Checkpoint)更新控制文件和数据文件头中的 checkpoint 信息。不负责写数据块（写数据的是 DBWR）。负责同步 checkpoint 位置。"
},
{
  "QuestionID": 144,
  "QuestionType": "multiple",
  "QuestionText": "A script abc.sql must be executed to perform a certain task. User HR with password HR exists in the target database and the account is unlocked. The TNSNAMES.ORA file is up to date. Examine this command attempted by the user:\n\n$ sqlplus hr/hr@orc1 @abc\n\nWhat will happen and why?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The command succeeds and HR will be connected to the orcl database instance, and the abc script will be executed."},
    {"label": "B", "text": "The command fails because the script must refer to the full path name."},
    {"label": "C", "text": "The command succeeds and HR will be connected to the orcl database and after logging out to the abc database."},
    {"label": "D", "text": "The command succeeds and HR will be connected to the orcl database instance, and the abc script will be executed."},
    {"label": "E", "text": "The command fails and reports an error because @ is used twice."}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": ""
},
{
  "QuestionID": 145,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about global temporary tables?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Backup and recovery operations are available for these tables."},
    {"label": "B", "text": "Their data is always stored in the default temporary tablespace of the user who created them."},
    {"label": "C", "text": "If the ON COMMIT clause is transaction specific, all rows in the table are deleted after each COMMIT or ROLLBACK."},
    {"label": "D", "text": "Indexes can be created on them."},
    {"label": "E", "text": "They can be created only by a user with the DBA role, but can be accessed by all users who can create a session."},
    {"label": "F", "text": "If the ON COMMIT clause is session specific, the table is dropped when the session is terminated."}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": "全局临时表GTT:表结构是永久的，但数据是临时的。数据只对当前会话（session）可见，不同会话的数据相互隔离。适合存储临时计算结果、会话级数据等。\nON COMMIT DELETE ROWS（事务级Transaction-specific）每次 COMMIT 或 ROLLBACK 都会清空该会话中的表数据数据只在 事务内有效\nON COMMIT PRESERVE ROWS（会话级Session-specific）数据在 事务提交后仍然保留,直到会话结束才删除表数据\nA.GTT 的数据是临时的，不参与常规备份和恢复。\nB.数据确实存放在临时表空间（TEMP tablespace），但可以显式指定表空间，不一定是默认的。\nE.普通用户只要有 CREATE TABLE 权限 就可以创建自己的 GTT"
},
{
  "QuestionID": 146,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about GLOBAL TEMPORARY TABLES?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A GLOBAL TEMPORARY TABLE cannot have PUBLIC SYNONYM."},
    {"label": "B", "text": "A GLOBAL TEMPORARY TABLE can have multiple indexes."},
    {"label": "C", "text": "A GLOBAL TEMPORARY TABLE can be referenced in the defining query of a view."},
    {"label": "D", "text": "Data Manipulation Language (DML) on GLOBAL TEMPORARY TABLES generates no REDO."},
    {"label": "E", "text": "A GLOBAL TEMPORARY TABLE can have only one index."},
    {"label": "F", "text": "A trigger can be created on a GLOBAL TEMPORARY TABLE."}
  ],
  "CorrectAnswer": ["B", "C", "F"],
  "Explanation": "A.GTT 可以创建 PUBLIC SYNONYM，让其他用户通过同一个名字访问表结构（但访问的数据依然是各自会话的）。\nB.全局临时表跟普通表一样，可以创建索引、视图、触发器等等，dml 操作同样也会产生 redo"
},
{
  "QuestionID": 147,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about GLOBAL TEMPORARY TABLES?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "GLOBAL TEMPORARY TABLE space allocation occurs at session start."},
    {"label": "B", "text": "A GLOBAL TEMPORARY TABLE's definition is available to multiple sessions."},
    {"label": "C", "text": "A DELETE command on a GLOBAL TEMPORARY TABLE cannot be rolled back."},
    {"label": "D", "text": "A TRUNCATE command issued in a session causes all rows in a GLOBAL TEMPORARY TABLE for the issuing session to be deleted."},
    {"label": "E", "text": "GLOBAL TEMPORARY TABLE rows inserted by a session are available to any other session whose user has been granted SELECT on the table."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "A.普通表进行第一次DML 操作时，会为表段分配空间;临时表则在创建临时表空间分配"
},
{
  "QuestionID": 148,
  "QuestionType": "multiple",
  "QuestionText": "You execute these commands successfully:\n\nCREATE GLOBAL TEMPORARY TABLE invoices_gtt (\ncustomer_id INTEGER,\ninvoice_total NUMBER(10,2)\n) ON COMMIT PRESERVE ROWS;\nINSERT INTO invoices_gtt VALUES (1, 100);\nCOMMIT;\n\nWhich two are true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "To drop the table in this session, you must first truncate it."},
    {"label": "B", "text": "When you terminate your session, the row will be deleted."},
    {"label": "C", "text": "Other sessions can view the committed row."},
    {"label": "D", "text": "You can add a foreign key to the table."},
    {"label": "E", "text": "You can add a column to the table in this session."}
  ],
  "CorrectAnswer": ["A", "B"],
  "Explanation": "A.会话级 GTT 的表存在会话级数据。为了 DROP TABLE，必须先删除该会话的数据（通常通过 TRUNCATE）。\nD.外键是跨表约束，需要保证数据一致性,GTT 数据是临时的，跨会话不可见，无法保证约束的完整性.GTT 表结构修改前，确保表中无数据；索引可以，但外键不允许；事务级数据提交后消失，会话级数据存在期间不能修改表。\nE.表结构修改（ALTER TABLE ADD COLUMN） 对 GTT 是 永久的，作用于表定义对当前会话生效与否不相关，题目选项的表述不正确ALTER TABLE 可以增加列，但不是“只在本会话生效"
},
{
  "QuestionID": 149,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about GLOBAL TEMPORARY TABLES?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A DELETE command on GLOBAL TEMPORARY TABLE cannot be rolled back."},
    {"label": "B", "text": "GLOBAL TEMPORARY TABLE rows inserted by a session are available to any other session whose user has been granted SELECT on the table."},
    {"label": "C", "text": "Any GLOBAL TEMPORARY TABLE rows existing at session termination will be deleted."},
    {"label": "D", "text": "A GLOBAL TEMPORARY TABLE's definition is available to multiple sessions."},
    {"label": "E", "text": "GLOBAL TEMPORARY TABLE space allocation occurs at session start."},
    {"label": "F", "text": "A TRUNCATE command issued in a session causes all rows in a GLOBAL TEMPORARY TABLE for the issuing session to be deleted."}
  ],
  "CorrectAnswer": ["C", "D", "F"],
  "Explanation": ""
},
{
  "QuestionID": 150,
  "QuestionType": "single",
  "QuestionText": "Examine these statements and results:\n\nSQL> SELECT COUNT(*) FROM emp;\nCOUNT (*)\n--------------------\n14\nSQL> CREATE GLOBAL TEMPORARY TABLE t_emp AS SELECT * FROM emp;\nTable created.\nSQL> INSERT INTO t_emp SELECT * FROM emp;\n14 rows created.\nSQL> COMMIT;\nCommit complete.\nSQL> INSERT INTO t_emp SELECT * FROM emp;\n14 rows created.\nSQL> SELECT COUNT(*) FROM t_emp;\n\nHow many rows are retrieved by the last query?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "0"},
    {"label": "B", "text": "14"},
    {"label": "C", "text": "28"},
    {"label": "D", "text": "42"}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "GTT 默认是事务级（transaction-specific）只有显式指定 ON COMMIT PRESERVE ROWS 才是会话级（session-specific）"
},
{
  "QuestionID": 151,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about Enterprise Manager Database Express?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The same port number can be used for Database Express configurations for databases on different hosts."},
    {"label": "B", "text": "It can be used to switch a database into ARCHIVELOG MODE."},
    {"label": "C", "text": "It can be used to perform database recovery when the database is mounted."},
    {"label": "D", "text": "The same port number can be used for multiple Database Express configurations for multiple databases on the same host."},
    {"label": "E", "text": "It can be used to perform database recovery when the database is opened."},
    {"label": "F", "text": "It is available only when the database is open."}
  ],
  "CorrectAnswer": ["A", "F"],
  "Explanation": "Enterprise Manager Database Express（简称 EM Express）:轻量级 Web 管理工具,内嵌在数据库中，无需额外安装,用于单实例数据库的管理和监控\n主要功能：启动/关闭数据库,性能监控,用户管理,配置数据库参数\n访问方式：浏览器通过 HTTPS（默认端口 5500）访问\nEMDE 就是一个阉割版的 oem(Oracle Enterprise Manager)，很多功能都没有，但是使用起来很方便，只能做为简单的监视作用。\nB.EM Express 无法进行数据库模式切换（ARCHIVELOG / NOARCHIVELOG）这些操作需要 SQL*Plus 或 RMAN 执行\nC.EM Express 不能进行恢复操作"
},
{
  "QuestionID": 152,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the Oracle Data Dictionary?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "All data dictionary view join base tables to dynamic performance views."},
    {"label": "B", "text": "Data dictionary base tables can be queried directly."},
    {"label": "C", "text": "It is owned by the SYS user."},
    {"label": "D", "text": "It is owned by the SYSTEM user."},
    {"label": "E", "text": "Data dictionary views are always created with queries that join two or more base tables."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "数据字典（Data Dictionary）：是 Oracle 数据库内部管理数据库对象的元数据集合,包含数据库结构信息，如表、索引、用户、视图、约束等,存储在SYS schema下的表中,通过数据字典视图（Data Dictionary Views） 访问，不直接操作底层数据字典表.数据字典基表可以直接查询，并且属于基表，只能够在数据库 open 的时候看到\nA.动态性能视图是虚拟表,存在于SGA中,数据字典视图是基于基表,以ALL_,USER_,DBA_开头\nE.数据字典视图只查询 一张 SYS 表，不一定要join多张表"
},
{
  "QuestionID": 153,
  "QuestionType": "multiple",
  "QuestionText": "You execute this command:\n\nCREATE SMALLFILE TABLESPACE sales\nDATAFILE '/u01/app/oracle/sales01.dbf'\nSIZE 5G\nSEGMENT SPACE MANAGEMENT AUTO;\n\nWhich two statements are true about the SALES tablespace?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is a locally managed tablespace."},
    {"label": "B", "text": "It must be smaller than the smallest BIGFILE tablespace."},
    {"label": "C", "text": "Free space is managed using freelists."},
    {"label": "D", "text": "It uses the database default blocksize."},
    {"label": "E", "text": "Any data files added to the tablespace must have a size of 5 gigabytes."}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": "A.默认创建 SMALLFILE 表空间时为 LMT（Locally Managed Tablespace使用位图（bitmap）管理空闲区，效率高，支持自动扩展和大表空间）\nE.SIZE 5G 只是 初始数据文件大小以后添加数据文件可以指定任意大小，或者使用 AUTOEXTEND ON 自动增长"
},
{
  "QuestionID": 154,
  "QuestionType": "multiple",
  "QuestionText": "One of your database instances was shut down normally and then started in NOMOUNT state. You then executed this command:\n\nALTER DATABASE MOUNT;\n\nWhich two of these actions are performed?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Online redo logs are opened."},
    {"label": "B", "text": "Oracle background processes are started."},
    {"label": "C", "text": "The initialization parameter file is read."},
    {"label": "D", "text": "Control files are read."},
    {"label": "E", "text": "Online data files are opened."},
    {"label": "F", "text": "Oracle shared memory structures are allocated."},
    {"label": "G", "text": "The alert log has instance startup details written to it."}
  ],
  "CorrectAnswer": ["D", "G"],
  "Explanation": "MOUNT 阶段主要做两件事：1.读取控制文件2.记录 alert log 中实例启动信息"
},
{
  "QuestionID": 155,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about advanced connection options supported by Oracle Net for connection to Oracle Database instances?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Source Routing requires the use of encrypted connections."},
    {"label": "B", "text": "Connect Time Failover requires the use of Transparent Application Failover (TAF)."},
    {"label": "C", "text": "Connect Time Failover requires the connect string to have two or more listener addresses configured."},
    {"label": "D", "text": "Load Balancing requires the use of a name server."},
    {"label": "E", "text": "Load Balancing can balance the number of connections to dispatchers when using a Shared Server configuration."}
  ],
  "CorrectAnswer": ["C", "E"],
  "Explanation": "A.源路由：你自己画好路线图 → Source Routing,与加密无关，不要求加密连接.普通路由：出门随便走，网络自动选最优路线 → TCP/IP 默认路由.\nB.Connect Time Failover (CTF)在客户端连接数据库时，如果第一个监听器不可用，可以尝试第二个监听器，实现连接的高可用性,只在建立连接时生效,不依赖 TAF（Transparent Application Failover）,需要在connect string 中配置多个 listener地址.Transparent Application Failover (TAF)主要用于已经建立的会话,如果会话所在实例失败，TAF 可以尝试在另一个实例上重建会话与Connect Time Failover不同，CTF 是在连接阶段生效，TAF是在会话运行阶段生效\nD.Load Balancing (负载均衡)在使用 RAC 或共享服务器（Shared Server）时，将客户端连接请求分配到多个实例或多个 dispatcher,可以在 Shared Server 模式下对 dispatcher 连接数进行均衡,不依赖 name server(DNS 也可用),与 TAF 无关"
},
{
  "QuestionID": 156,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about external tables in Oracle 18c and later releases?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The ORACLE_LOADER access driver can be used to unload data from a database into an external table."},
    {"label": "B", "text": "External table files can be used for other external tables in a different database."},
    {"label": "C", "text": "They cannot be partitioned."},
    {"label": "D", "text": "The ORACLE_DATAPUMP access driver can be used to unload data from a database into an external table."},
    {"label": "E", "text": "They support UPDATEs but not INSERTs and DELETEs."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "A.ORACLE_LOADER从文本文件（CSV、固定宽度等）读取数据到外部表,只能读取.ORACLE_DATAPUMP使用 Data Pump dump 文件进行数据导入/导出,可以读写，即可以用来unload数据到外部表或load数据到数据库\nC.Oracle 18c及以后，外部表支持分区。\nE.外部表通常 不支持 DML，即 INSERT/UPDATE/DELETE 都不行"
},
{
  "QuestionID": 157,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about single-row functions?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "They return a single result row per table."},
    {"label": "B", "text": "They can be used only in the WHERE clause of a SELECT statement."},
    {"label": "C", "text": "They can accept only one argument."},
    {"label": "D", "text": "The argument can be a column name, variable, literal, or an expression."},
    {"label": "E", "text": "The data type returned can be different from the data type of the argument."}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "A.单行函数 每行返回一个值,如果表有 10 行，函数执行 10 次，返回 10 个结果,聚合函数（SUM, AVG）才是 每表一行\nB.单行函数可以用在 SELECT、WHERE、ORDER BY、GROUP BY 等子句\nC.单行函数可以接受多个参数,如decode,nvl2等函数\nD.单行函数参数可以是：列名：UPPER(ename)变量：ROUND(:sal,2)字面值：TO_DATE('2025-10-25','YYYY-MM-DD')表达式：ROUND(salary*1.1,0)\nE.如to_char()"
},
{
  "QuestionID": 158,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true regarding single row subqueries?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "They can be used in the WHERE clause."},
    {"label": "B", "text": "They must be placed on the right side of the comparison operator or condition."},
    {"label": "C", "text": "They must return a row to prevent errors in the SQL statement."},
    {"label": "D", "text": "They must be placed on the left side of the comparison operator or condition."},
    {"label": "E", "text": "A SQL statement may have multiple single row subquery blocks."},
    {"label": "F", "text": "They can be used in the HAVING clause."}
  ],
  "CorrectAnswer": ["A", "E", "F"],
  "Explanation": "B.单行子查询通常放在 比较符号右边，但也可以用在 FROM 列表、SELECT 列表，或与 IN、EXISTS 等组合\nC.单行子查询可以返回 NULL（零行）返回零行不会报错，但如果使用 = 比较符号，结果可能是空集,单行子查询只允许返回一行，返回多行才会报错"
},
{
  "QuestionID": 159,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about single-row functions?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "They can accept only one argument."},
    {"label": "B", "text": "They can be nested to any level."},
    {"label": "C", "text": "They return a single result row per table."},
    {"label": "D", "text": "The data type returned can be different from the data type of the argument."},
    {"label": "E", "text": "The argument can be a column name, variable, literal, or an expression."},
    {"label": "F", "text": "They can be used only in the WHERE clause of a SELECT statement."}
  ],
  "CorrectAnswer": ["B", "D", "E"],
  "Explanation": ""
},
{
  "QuestionID": 160,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the Automatic Diagnostic Repository (ADR)?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It supports diagnostics for Automatic Storage Management (ASM)."},
    {"label": "B", "text": "It supports diagnostics for Oracle Clusterware."},
    {"label": "C", "text": "It is held inside an Oracle database schema."},
    {"label": "D", "text": "It supports diagnostics for Oracle based applications."},
    {"label": "E", "text": "It is held in an Oracle database data dictionary."}
  ],
  "CorrectAnswer": ["A", "B"],
  "Explanation": "ADR（Automatic Diagnostic Repository）集中存储 Oracle 数据库和相关组件的诊断信息.\n存储内容：\n1.日志文件（alert log、trace files）\n2.Dump 文件\n3.栈跟踪信息（stack traces）\n4.健康报告（Health Monitor）\n5.incident 信息\n特点：\n1.独立于数据库schema\n2.目录结构在文件系统上，而不是存储在数据库内部\n3.可通过工具访问：ADRCI、Enterprise Manager\nADR支持的组件:\n1.数据库实例\n2.SM（Automatic Storage Management）ASM的trace文件、alert log 都存储在ADR中\n3.Oracle Clusterware:集群的 CRS（Cluster Ready Services）日志也可以存放在 ADR.\nD.ADR 主要用于数据库和集群组件的诊断，不直接存储应用日志，数据库/集群日志关注系统健康，应用日志关注业务操作\nE.数据字典只存数据库对象元数据，ADR是文件系统目录"
},
{
  "QuestionID": 161,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the Automatic Diagnostic Repository (ADR)?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The ADR base is shared across multiple instances."},
    {"label": "B", "text": "The ADR base keeps all diagnostic information in binary format."},
    {"label": "C", "text": "The ADR can be used to store statspack snapshots to diagnose database performance issues."},
    {"label": "D", "text": "The ADR can be used for problem diagnosis even when the database instance is down."},
    {"label": "E", "text": "The ADR is used to store Automatic Workload Repository (AWR) snapshots."}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": "A.ADR base是一个主目录，可以被同一主机上的多个数据库实例共享,每个实例有自己的 ADR home，但都存放在同一个ADR base下\nB.ADR 中大部分信息是 文本格式（alert log、trace）也有部分 dump 或 incident 文件是二进制，但不是全部\nC.Statspack 是传统性能诊断工具,Statspack snapshot 存在 数据库表空间，不是 ADR 文件系统\nD.ADR 是文件系统目录，诊断文件可在数据库关闭时访问,使用工具：adrci\nE.AWR snapshots存储在数据库表空间中的SYSAUX(SYSTEM辅助表空间（Auxiliary Tablespace）) ，不在ADR,ADR 可辅助分析AWR相关问题，但不存AWR数据"
},
{
  "QuestionID": 162,
  "QuestionType": "multiple",
  "QuestionText": "Which are two of the account management capabilities that can be configured using Oracle profiles?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The maximum amount of CPU time allowed for a user's sessions before their account is locked."},
    {"label": "B", "text": "The number of days for which an account may be inactive before it is locked."},
    {"label": "C", "text": "The maximum number of sessions permitted for a user before the password must be changed."},
    {"label": "D", "text": "The ability to prevent a password from ever being reused."},
    {"label": "E", "text": "The number of days for which an account may be logged in to one or more sessions before it is locked."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation":"账户管理能力Account Management:\n1. 密码管理Password Management\n--PASSWORD_LIFE_TIME:密码有效期(多少天后必须更改密码)\n--PASSWORD_REUSE_MAX:防止密码重复使用\n--PASSWORD_VERIFY_FUNCTION:密码复杂度\n--FAILED_LOGIN_ATTEMPTS:失败登录尝试次数\n2.账户锁定/失效策略Account Lock / Expiry\n--PASSWORD_GRACE_TIME:密码过期前的宽限期\n--INACTIVE_ACCOUNT_TIME:账户在多少天不被使用后被锁定\n\nProfile 参与 Resource Limit:它定义了限制规则实际执行 Resource Limit:由数据库内核Kernel在运行时强制"
},
{
  "QuestionID": 163,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about SQL*Loader Express Mode in an Oracle 12c database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It can load data in parallel."},
    {"label": "B", "text": "No data file needs to be specified."},
    {"label": "C", "text": "It loads data faster than conventional SQL*Loader."},
    {"label": "D", "text": "It loads data more efficiently than conventional SQL*Loader."},
    {"label": "E", "text": "It requires Enterprise Manager Express to be configured."}
  ],
  "CorrectAnswer": ["A", "B"],
  "Explanation": "Oracle SQL*Loader 有两种主要加载模式:\n1.Conventional Path（传统路径）:将数据逐行解析并插入表。适合小量或复杂的数据转换。\n2.Express Mode（快速加载/Express 模式）主要特点是无需提供控制文件，自动识别数据文件和目标表。使用方式更简单，适合快速、轻量级的数据加载任务。\n\nCD.不一定总是比传统 SQL*Loader 快。Express Mode 的设计目标是简化操作，而不是绝对性能优化。对于大规模数据，传统路径（conventional path）或者直接路径（direct path）可能更快\nF.Express Mode 完全独立于 Enterprise Manager Express,可以在命令行直接使用 sqlldr 命令启动 Express Mode"
},
{
  "QuestionID": 164,
  "QuestionType": "multiple",
  "QuestionText": "On your Oracle 19c database, you invoke SQL*Loader to load data into the employees table in the HR schema by issuing the command:\n\n$> sqlldr hr/hr@pdb table=employees\n\nWhich two statements are true about the command?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It succeeds with default settings if the employees table exists in the HR schema."},
    {"label": "B", "text": "It fails because no SQL*Loader data file location is specified."},
    {"label": "C", "text": "It fails if the HR user does not have the CREATE ANY DIRECTORY privilege."},
    {"label": "D", "text": "It fails because no SQL*Loader control file location is specified."},
    {"label": "E", "text": "It succeeds and creates the employees table in the HR schema."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "SQL*Loader 有 Express Mode。在 Express Mode 下：只需指定表名 (table=employees)。\n默认情况下:\n--数据文件会默认在当前目录下，文件名为 <table>.csv 或 <table>.dat\n--控制文件不需要显式提供，系统会自动生成控制逻辑。\n所以命令可以工作 前提条件是:\n--1.表 employees已存在\n--2.用户有访问数据文件的权限。\n--3.对外部目录的访问权限符合要求。\n\nC.SQL*Loader 在后台需要创建临时目录对象来读取数据文件。如果用户没有 CREATE ANY DIRECTORY 权限，Express Mode 会报错"
},
{
  "QuestionID": 165,
  "QuestionType": "multiple",
  "QuestionText": "In an Oracle 12c database, you attempt to load data into the HR.EMPLOYEES table in a pluggable database (PDB):\n\n$> sqlldr hr/hr@pdb table=employees\n\nWhich three are true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It creates the HR.EMPLOYEES table in the PDB and loads data into it if the table does not exist in the PDB to which HR connects."},
    {"label": "B", "text": "It loads data into HR.EMPLOYEES if the table exists in CDB$ROOT."},
    {"label": "C", "text": "It succeeds if HR is a local user in the PDB to which HR connects."},
    {"label": "D", "text": "It succeeds if HR is a common user."},
    {"label": "E", "text": "It loads data into HR.EMPLOYEES if the table exists in the PDB to which HR connects."}
  ],
  "CorrectAnswer": ["C", "D", "E"],
  "Explanation": "在 Oracle 12c 的多租户架构中:\n--1.Common User（通用用户）:在 CDB$ROOT 创建，可以访问所有 PDB。用户名前通常有 C## 前缀（如果使用默认设置）。\n--2.Local User（本地用户）:只存在于某个 PDB 内。只能访问创建所在 PDB 的对象\n一个容器数据库（CDB, Container Database） 可以包含 多个可插拔数据库（PDB, Pluggable Database）.CDB$ROOT = 容器数据库的核心“根”，主要存储系统和管理信息。PDB = 独立的可插拔数据库，用于存放具体业务数据。数据加载工具（如 SQL*Loader）只作用于你连接的 PDB，而不是 CDB$ROOT，除非你用 common user 并在 CDB$ROOT 执行管理操作"
},
{
  "QuestionID": 166,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about table data storage in an Oracle Database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Data block free space is always contiguous in the middle of the block."},
    {"label": "B", "text": "A table row can be chained across several database blocks."},
    {"label": "C", "text": "Multiple row pieces from the same row may be stored in same database blocks."},
    {"label": "D", "text": "Index block free space is always contiguous in the middle of the block."},
    {"label": "E", "text": "Multiple row pieces from the same row must be stored in different database blocks."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": ""
},
{
  "QuestionID": 167,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about views?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Views can be updated without the need to re-grant privileges on the view."},
    {"label": "B", "text": "Views can be indexed."},
    {"label": "C", "text": "A view must only refer to tables in its defining query."},
    {"label": "D", "text": "The WITH CHECK clause prevents certain rows from being displayed when querying the view."},
    {"label": "E", "text": "The WITH CHECK clause prevents certain rows from being updated or inserted in the underlying table through the view."}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": "B.普通视图（普通 SELECT）不能直接建立索引。只有物化视图（Materialized View） 才能建立索引，以提高查询性能"
},
{
  "QuestionID": 168,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about views?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Views can be updated without the need to re-grant privileges on the view."},
    {"label": "B", "text": "Views can be indexed."},
    {"label": "C", "text": "The WITH CHECK clause prevents certain rows from being updated or inserted in the underlying table through the view."},
    {"label": "D", "text": "The WITH CHECK clause prevents certain rows from being displayed when querying the view."},
    {"label": "E", "text": "Tables in the defining query of a view must always exist in order to create the view."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": ""
},
{
  "QuestionID": 169,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about undo segments and the use of undo by transactions in an Oracle database instance?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A single transaction may use multiple undo segments simultaneously."},
    {"label": "B", "text": "Undo segments can wrap around to the first extent when a transaction fills the last extent of the undo segment."},
    {"label": "C", "text": "Undo segments can extend when a transaction fills the last extent of the undo segment."},
    {"label": "D", "text": "Undo segments can be stored in the SYSTEM tablespace."},
    {"label": "E", "text": "Undo segments can be stored in the SYSAUX tablespace."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "Undo Segment（撤销段） 是 Oracle 用来：实现 事务回滚（ROLLBACK）；支持 读一致性（Read Consistency）；支持 闪回查询（Flashback Query）。每个事务在开始时，会被分配一个 undo segment，用于存储该事务的撤销信息（undo records）。\n\nBC.如果能循环利用 → wrap around；如果不能 → 自动扩展新的 extent。\nDE.撤销段应存放在 独立的 UNDO 表空间"
},
{
  "QuestionID": 170,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about date/time functions in a session where NLS_DATE_FORMAT is set to DD-MON-YYYY HH24:MI:SS?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "SYSDATE can be queried only from the DUAL table."},
    {"label": "B", "text": "SYSDATE and CURRENT_DATE return the current date and time set for the operating system of the client."},
    {"label": "C", "text": "CURRENT_TIMESTAMP returns the same date and time as SYSDATE with additional details of fractional seconds."},
    {"label": "D", "text": "CURRENT_DATE returns the current date and time as per the session time zone."},
    {"label": "E", "text": "SYSDATE can be used in expressions only if the default date format is DD-MON-RR."},
    {"label": "F", "text": "CURRENT_TIMESTAMP returns the same date as CURRENT_DATE."}
  ],
  "CorrectAnswer": ["D", "F"],
  "Explanation": "A.SYSDATE 可以在任何 SQL 表达式或查询中使用，不限于 DUAL"
},
{
  "QuestionID": 171,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the tools used to configure Oracle Net Services?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The lsnrctl utility requires a listener.ora file to exist before it is started."},
    {"label": "B", "text": "Enterprise Manager Cloud Control can be used to centrally configure net service names for any database server target."},
    {"label": "C", "text": "The Oracle Net Configuration Assistant is only used when running the Oracle installer."},
    {"label": "D", "text": "Oracle Net Manager can be used to locally configure naming methods on a database server."},
    {"label": "E", "text": "Oracle Net Manager can be used to centrally configure listeners on any database server target."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation":"Oracle Net Services 负责客户端与数据库服务器之间的网络通信，主要配置内容包括:\n--Listener（监听器）：监听客户端连接请求\n--TNS名称解析（Naming methods）\n--Service Name / SID 映射\nOracle 提供了几种配置工具：\n--Oracle Net Manager (netmgr):图形化配置监听器、命名方法、服务名称等(本地);本地配置服务器网络参数\n--Oracle Net Configuration Assistant (netca):向导式配置（安装时或独立运行）;安装数据库时或后续手动配置\n--lsnrctl命令行控制监听器（启动/停止/状态）;管理监听器\n--Enterprise Manager (EM Cloud Control)集中式图形化管理多个数据库的网络配置;企业集中管理\n\nA.lsnrctl 可以在没有 listener.ora 文件时启动默认监听器，默认名称是LISTENER，默认端口1521。→ 如果 listener.ora 不存在，它会使用默认配置启动监听器。"
},
{
  "QuestionID": 172,
  "QuestionType": "multiple",
  "QuestionText": "You currently have an active transaction in your session and have been granted SELECT access to V$TRANSACTION.\nExecuting: \n\nSELECT xid, status FROM v$transaction; \n\nin your session returns: \n\nXID                   STATUS \n--------------------------- --------------\n 0A0007000A070000        ACTIVE \n\nIn which three situations will re-executing this query still return a row but with a different XID, indicating a new transaction has started?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "after successfully executing a CREATE TABLE AS SELECT statement followed by a SELECT FOR UPDATE statement"},
    {"label": "B", "text": "after successfully executing a COMMIT or ROLLBACK followed by a DML statement"},
    {"label": "C", "text": "after successfully executing a TRUNCATE statement followed by a DML statement"},
    {"label": "D", "text": "after successfully executing a DML statement following a failed DML statement"},
    {"label": "E", "text": "after successfully executing a COMMIT or ROLLBACK followed by a SELECT statement"},
    {"label": "F", "text": "after successfully executing a CREATE TABLE statement followed by a CREATE INDEX statement"}
  ],
  "CorrectAnswer": ["A", "B", "C"],
  "Explanation": "XID (Transaction ID) 全称是 Transaction Identifier（事务标识符），是 Oracle 数据库为每个活动事务（active transaction）分配的一个唯一编号，新事务的开始 才会导致XID变化\n事务开始与结束:\n--DML（INSERT/UPDATE/DELETE/MERGE）启动事务;不结束\n--COMMIT / ROLLBACK结束事务\n--SELECT不启动、不结束\n--CREATE TABLE / CREATE INDEX（DDL）自动启动事务;自动提交（结束）\n--TRUNCATE自动启动事务;自动提交（结束）\n\nA.CREATE TABLE AS SELECT是一个 DDL，会启动一个事务并自动提交;结束后事务已结束（没有活动事务）。SELECT FOR UPDATE是一个特殊的 SELECT，会锁定行，启动一个新的事务。\n"
},
{
  "QuestionID": 173,
  "QuestionType": "single",
  "QuestionText": "What is true about non-equijoin statement performance?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The BETWEEN condition used with a non-equijoin always performs better than when using the >= and <= conditions."},
    {"label": "B", "text": "The join syntax used makes no difference to performance."},
    {"label": "C", "text": "The BETWEEN condition used with a non-equijoin sometimes performs better than using the >= and <= conditions."},
    {"label": "D", "text": "The Oracle join syntax performs less well than the SQL:1999 compliant ANSI join syntax."},
    {"label": "E", "text": "The Oracle join syntax performs better than the SQL:1999 compliant ANSI join syntax."}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": ""
},
{
  "QuestionID": 174,
  "QuestionType": "multiple",
  "QuestionText": "You want to apply the principle of Least Privilege in all your live databases. One of your requirements is to revoke unnecessary privileges from all users who have them using Privilege Analysis.\n Which two are types of analyses that can be done using the DBMS_PRIVILEGE_CAPTURE package?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "analysis of privileges granted indirectly to a role that are then used by a user who has been granted that role"},
    {"label": "B", "text": "analysis of privileges that a user has on other schema's objects"},
    {"label": "C", "text": "analysis of privileges that a user has on their own schema objects"},
    {"label": "D", "text": "analysis of privileges granted directly to a role that are then used by a user who has been granted that role"},
    {"label": "E", "text": "analysis of all privileges used by the SYS user."}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": "DBMS_PRIVILEGE_CAPTURE 是Oracle提供的一个包，用于：收集用户和角色使用的权限情况;分析哪些权限被真正使用，哪些权限没用;帮助安全团队撤销冗余权限，实现最小权限原则\nB.Privilege Capture主要分析用户使用的权限，不局限schema\nC.用户对自己 schema 的权限一般不需要分析（因为默认拥有）\nE.SYS 是超级用户，权限永远被使用，不适合分析最小权限，也不在 Privilege Capture 的范围"
},
{
  "QuestionID": 175,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true regarding indexes?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The RECYCLE BIN never contains indexes."},
    {"label": "B", "text": "An update to a table can result in updates to any or all of the table's indexes."},
    {"label": "C", "text": "A non-unique index can be altered to be unique."},
    {"label": "D", "text": "An update to a table can result in no updates to any of the table's indexes."},
    {"label": "E", "text": "A table belonging to one user cannot have an index that belongs to a different user."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "C.要从非唯一变为唯一，必须：删除非唯一索引;创建一个新的唯一索引.不能直接 ALTER INDEX 改变唯一性。\nE.索引必须属于与表相同的用户"
},
{
  "QuestionID": 176,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true concerning logical and physical database structures?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A segment might have only one extent."},
    {"label": "B", "text": "A segment's blocks can be of different sizes."},
    {"label": "C", "text": "Segments can span multiple tablespaces."},
    {"label": "D", "text": "All tablespaces may have one or more data files."},
    {"label": "E", "text": "A segment can span multiple data files in some tablespaces."}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": ""
},
{
  "QuestionID": 177,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the Oracle join and ANSI join syntax?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The Oracle join syntax performs less well than the SQL:1999 compliant ANSI join syntax."},
    {"label": "B", "text": "The Oracle join syntax supports creation of a Cartesian product of two tables."},
    {"label": "C", "text": "The Oracle join syntax lacks the ability to do outer joins."},
    {"label": "D", "text": "The SQL:1999 compliant ANSI join syntax supports creation of a Cartesian product of two tables."},
    {"label": "E", "text": "The Oracle join syntax performs better than the SQL:1999 compliant ANSI join syntax."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "A.Oracle join 语法支持 外连接，通过 (+) 实现"
},
{
  "QuestionID": 178,
  "QuestionType": "multiple",
  "QuestionText": "Which three relationships between instances and Oracle databases are possible without using Multi-tenant?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "One instance on one server that has no database mounted."},
    {"label": "B", "text": "One instance on one server mounting and opening one database."},
    {"label": "C", "text": "One instance on one server mounting and opening multiple databases."},
    {"label": "D", "text": "Two or more instances on separate servers all mounting and opening the same database."},
    {"label": "E", "text": "One instance on one server mounting multiple databases."}
  ],
  "CorrectAnswer": ["A", "B", "D"],
  "Explanation": ""
},
{
  "QuestionID": 179,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true?",
  "ImageURL": "images/q179.png",
  "Options": [
    {"label": "A", "text": "SALES1 is created with 55,000 rows."},
    {"label": "B", "text": "SALES1 is created with no rows."},
    {"label": "C", "text": "SALES1 has NOT NULL constraints on any selected columns which had those constraints in the SALES table."},
    {"label": "D", "text": "SALES1 has PRIMARY KEY and UNIQUE constraints on any selected columns which had those constraints in the SALES table."},
    {"label": "E", "text": "SALES1 is created with 1 row."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "A.WHERE 1 = 1对所有行都成立，所以SELECT会选中SALES的所有55,000行\nC.CTAS会继承 NOT NULL 约束。但是CTAS不会继承PRIMARY KEY、UNIQUE、FOREIGN KEY等约束，也不会继承索引"
},
{
  "QuestionID": 180,
  "QuestionType": "multiple",
  "QuestionText": "Examine this query: \n\nSELECT * FROM bricks, colors;\n\n Which two statements are true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "You can add a WHERE clause with filtering criteria."},
    {"label": "B", "text": "It returns the same rows as SELECT * FROM bricks CROSS JOIN colors;."},
    {"label": "C", "text": "You can add a USING clause with a join condition."},
    {"label": "D", "text": "It returns the number of rows in BRICKS plus the number of rows in COLORS."},
    {"label": "E", "text": "You can add an ON clause with a join condition."}
  ],
  "CorrectAnswer": ["A", "B"],
  "Explanation": " Oracle的旧式逗号连接语法（comma join）如果没有 WHERE 条件，它会生成 笛卡尔积（Cartesian product）笛卡尔积的结果行数 = bricks 表的行数 × colors 表的行数\nA.旧式逗号连接允许在WHERE子句中添加条件,进行过滤或模拟连接,相当于INNER JOIN\nC.USING是ANSI join（JOIN … ON / JOIN … USING）语法 的一部分,逗号旧式连接不能直接用USING\nE.ON 也是 ANSI join（JOIN … ON） 的语法,旧式逗号连接只能用 WHERE"
},
{
  "QuestionID": 181,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about unused columns?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "You can query the data dictionary to see the names of unused columns."},
    {"label": "B", "text": "CASCADE CONSTRAINTS must be specified when setting a column to unused if that column is referenced in a constraint on another column."},
    {"label": "C", "text": "Setting an indexed column to unused results in an error."},
    {"label": "D", "text": "If you set all the columns of a table to unused, the table is automatically dropped."},
    {"label": "E", "text": "You can specify multiple column names in an ALTER TABLE... SET UNUSED statement."}
  ],
  "CorrectAnswer": ["B", "E"],
  "Explanation": "A.只能看见计数\nB.如果列被约束（例如 FOREIGN KEY 或 CHECK 约束）引用，必须使用 CASCADE CONSTRAINTS,这样会自动删除引用该列的约束，否则会报错\nD.设置所有列为 UNUSED 只是标记列未使用，表仍然存在;需要显式执行 DROP TABLE 或 DROP UNUSED COLUMNS 来物理删除"
},
{
  "QuestionID": 182,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about virtual columns?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "They can be referenced in the WHERE clause of an UPDATE or DELETE statement."},
    {"label": "B", "text": "They cannot have a data type explicitly specified."},
    {"label": "C", "text": "They can be indexed."},
    {"label": "D", "text": "They can be referenced in the SET clause of an UPDATE statement as the name of the column to be updated."},
    {"label": "E", "text": "They can be referenced in the column expression of another virtual column."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "虚拟列是表中不实际存储数据的列，它的值是由表达式计算得到的,可以像普通列一样使用（但不能直接更新），虚拟列可以用在 select，update，delete 语句的where条件中，但是不能用于DML语句;可以基于虚拟列来做分区;可以在虚拟列上建索引。可以在虚拟列上建约束\nA.虚拟列只是参与筛选WHERE，而不是被更新的目标\nB.虚拟列可以显式指定数据类型\nD.虚拟列是只读的，不能被更新\nE.一个虚拟列不能引用另一个虚拟列，否则会导致依赖循环问题"
},
{
  "QuestionID": 183,
  "QuestionType": "multiple",
  "QuestionText": "Which two are SQL features?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "providing graphical capabilities"},
    {"label": "B", "text": "providing variable definition capabilities"},
    {"label": "C", "text": "providing database transaction control"},
    {"label": "D", "text": "processing sets of data"},
    {"label": "E", "text": "providing update capabilities for data in external files"}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": "SQL 是一种声明式语言declarative language,用于:\n--定义数据结构DDL(Data Definition Language):CREATE TABLE ...ALTER TABLE ...DROP TABLE ...TRUNCATE TABLE ...RENAME;\n--操作和查询数据DML(Data Manipulation Language):SELECT ...INSERT INTO ...UPDATE ...DELETE ...MERGE ...;\n--控制事务TCL(Transaction Control Language):COMMIT;ROLLBACK;SAVEPOINT;SET TRANSACTION;\n--控制访问DCL(Data Control Language):GRANT ...REVOKE .... \n它不会编程逻辑、不会做图形显示，也不是像 PL/SQL 那样的过程语言\nB.变量定义、控制语句(如 IF、LOOP)属于 PL/SQL(过程语言)的特性,而纯 SQL 不支持变量定义\nD.SQL 的核心思想是基于集合（set-based）处理数据"
},
{
  "QuestionID": 184,
  "QuestionType": "single",
  "QuestionText": "Choose the best answer.\nExamine this statement:\nSELECT 1 AS id, 'John' AS first_name, NULL AS commission FROM DUAL\nINTERSECT\nSELECT 1, 'John', NULL FROM DUAL\nORDER BY 3;\nWhat is returned upon execution?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "2 rows"},
    {"label": "B", "text": "1 row"},
    {"label": "C", "text": "0 rows"},
    {"label": "D", "text": "an error"}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "INTERSECT 运算符返回两个查询结果中完全相同的行（即交集）；会自动去除重复行（与 DISTINCT 类似）。\nNULL 的比较:在 SQL 中，NULL 不等于 NULL（NULL = NULL 为 UNKNOWN）。如果换成 WHERE 比较,SELECT 1 WHERE NULL = NULL;就不会返回结果（因为 NULL ≠ NULL）。但在 INTERSECT 里就会视作相等。但是，在集合操作（INTERSECT / UNION / MINUS）中,Oracle 把两个 NULL 当作相等的 来处理。"
},
{
  "QuestionID": 185,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements will do an implicit conversion?",
  "ImageURL": "images/q185.png",
  "Options": [
    {"label": "A", "text": "SELECT * FROM customers WHERE customer_id = '0001';"},
    {"label": "B", "text": "SELECT * FROM customers WHERE TO_CHAR(customer_id) = '0001';"},
    {"label": "C", "text": "SELECT * FROM customers WHERE customer_id = 0001;"},
    {"label": "D", "text": "SELECT * FROM customers WHERE insert_date = '01-JAN-19';"},
    {"label": "E", "text": "SELECT * FROM customers WHERE insert_date = DATE '2019-01-01';"}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": ""
},
{
  "QuestionID": 186,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about CURRENT_TIMESTAMP?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The time is in the time zone of DBTIMEZONE."},
    {"label": "B", "text": "It always returns the same value as SYSTIMESTAMP."},
    {"label": "C", "text": "The date is in the time zone of DBTIMEZONE."},
    {"label": "D", "text": "The value varies depending on the setting of SESSIONTIMEZONE."},
    {"label": "E", "text": "It returns the same date as CURRENT_DATE."},
    {"label": "F", "text": "It returns a value of data type TIMESTAMP."}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation":"F.CURRENT_TIMESTAMP 返回 TIMESTAMP WITH TIME ZONE，而不是普通的 TIMESTAMP。"
},
{
  "QuestionID": 187,
  "QuestionType": "multiple",
  "QuestionText": "Which two queries will result in an error?",
  "ImageURL": "images/q187.png",
  "Options": [
    {"label": "A", "text": "SELECT first_name last_name FROM employees;"},
    {"label": "B", "text": "SELECT first_name, last_name FROM employees;"},
    {"label": "C", "text": "SELECT last_name, 12 * salary AS annual_salary FROM employees WHERE annual_salary > 100000 ORDER BY 12 * salary;"},
    {"label": "D", "text": "SELECT last_name, 12 * salary AS annual_salary FROM employees WHERE annual_salary > 100000 ORDER BY annual_salary;"},
    {"label": "E", "text": "SELECT last_name, 12 * salary AS annual_salary FROM employees WHERE 12 * salary > 100000 ORDER BY annual_salary;"},
    {"label": "F", "text": "SELECT last_name, 12 * salary AS annual_salary FROM employees WHERE 12 * salary > 100000 ORDER BY 12 * salary;"}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": "WHERE 子句无法直接使用 SELECT 中定义的列别名。ORDER BY子句可以使用列别名、表达式或者列序号"
},
{
  "QuestionID": 188,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true?",
  "ImageURL": "images/q188.png",
  "Options": [
    {"label": "A", "text": "The PROD_NAME column cannot have a DEFAULT clause added to it."},
    {"label": "B", "text": "The EXPIRY_DATE column data type can be changed to TIMESTAMP."},
    {"label": "C", "text": "The PROD_ID column can be renamed."},
    {"label": "D", "text": "The PROD_ID column data type can be changed to VARCHAR2(2)."},
    {"label": "E", "text": "The EXPIRY_DATE column cannot be dropped."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "A.在 Oracle 中，可以给已有列添加默认值\nD.主键列或者已有数据的列，如果缩小长度，可能导致数据截断。如果 PROD_ID 当前是数字类型或长度大于 2 的 VARCHAR2，直接改成 VARCHAR2(2) 会报错。所以一般不能直接缩小长度\nE.除非列上有约束（比如主键或外键），一般列都是可以删除的"
},
{
  "QuestionID": 189,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about transactions in the Oracle Database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "An uncommitted transaction is automatically committed when the user exits SQL*Plus."},
    {"label": "B", "text": "A DDL statement issued by a session with an uncommitted transaction automatically commits that transaction."},
    {"label": "C", "text": "DDL statements automatically commit only data dictionary updates caused by executing the DDL."},
    {"label": "D", "text": "A session can see uncommitted updates made by the same user in a different session."},
    {"label": "E", "text": "DML statements always start new transactions."}
  ],
  "CorrectAnswer": ["A", "B"],
  "Explanation": "事务通常由 DML 语句（INSERT、UPDATE、DELETE、MERGE）开始;提交（COMMIT）将事务的修改写入数据库，使其他会话可见;DDL（CREATE、ALTER、DROP）在执行时，会 自动提交当前事务\nA.如果有未提交的事务并正常退出（EXIT 或 QUIT），Oracle 会自动提交未提交的事务。如果使用 EXIT ROLLBACK，则会回滚\nC.DDL 不只提交数据字典更新，它也会提交当前事务的 DML 修改，所以不只是“数据字典\nE.DML 会 加入当前未提交事务，而不是每条 DML 都新建事务。一个事务可能包含多条 DML"
},
{
  "QuestionID": 190,
  "QuestionType": "single",
  "QuestionText": "Choose the best answer.\nExamine these statements:\nCREATE TABLE alter_test (\nc1 VARCHAR2(10),\nc2 NUMBER(10));\nINSERT INTO alter_test VALUES ('123', 123);\nCOMMIT;\nWhich is true about modifying the columns in ALTER_TEST?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "C1 can be changed to NUMBER(10) but C2 cannot be changed to VARCHAR2(10)."},
    {"label": "B", "text": "C1 can be changed to VARCHAR2(5) and C2 can be changed to NUMBER(12,2)."},
    {"label": "C", "text": "C1 can be changed to NUMBER(10) and C2 can be changed to VARCHAR2(10)."},
    {"label": "D", "text": "C2 can be changed to VARCHAR2(10) but C1 cannot be changed to NUMBER(10)."},
    {"label": "E", "text": "C2 can be changed to NUMBER(5) but C1 cannot be changed to VARCHAR2(5)."}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": ""
},
{
  "QuestionID": 191,
  "QuestionType": "single",
  "QuestionText": "Choose the best answer.\nExamine this statement which returns the name of each employee and their manager:\nSELECT e.last_name AS emp, m.last_name AS mgr\nFROM employees e\nJOIN managers m\nON e.manager_id = m.employee_id\nORDER BY emp;\nYou want to extend the query to include employees with no manager. \nWhat must you add before JOIN to do this?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "LEFT OUTER"},
    {"label": "B", "text": "RIGHT OUTER"},
    {"label": "C", "text": "CROSS"},
    {"label": "D", "text": "FULL OUTER"}
  ],
  "CorrectAnswer": ["A"],
  "Explanation": "左表全保留 → LEFT OUTER；右表全保留 → RIGHT OUTER；全保留 → FULL OUTER。\nINNER JOIN：只保留有匹配的行"
},
{
  "QuestionID": 192,
  "QuestionType": "single",
  "QuestionText": "Choose the best answer.\nExamine this statement, which executes successfully:\nSELECT d.department_name, ROUND(AVG(NULLIF(e.salary,0))) AS avgsal, MAX(e.salary) AS maxsal\nFROM employees e\nJOIN departments d\nON (e.department_id = d.department_id)\nGROUP BY d.department_name\nORDER BY 2;\nIn which order are the rows displayed?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "sorted by DEPARTMENT_NAME"},
    {"label": "B", "text": "sorted by MAXSAL"},
    {"label": "C", "text": "sorted by DEPARTMENT_NAME and AVGSAL"},
    {"label": "D", "text": "sorted by DEPARTMENT_NAME and MAXSAL"},
    {"label": "E", "text": "sorted by AVGSAL"}
  ],
  "CorrectAnswer": ["E"],
  "Explanation": ""
},
{
  "QuestionID": 193,
  "QuestionType": "single",
  "QuestionText": "Choose the best answer.\nYou have the privileges to create any type of synonym.\nWhich statement will create a synonym called EMP for the HCM.EMPLOYEE_RECORDS table that is accessible to all users?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "CREATE SYNONYM PUBLIC.emp FOR hcm.employee_records;"},
    {"label": "B", "text": "CREATE PUBLIC SYNONYM emp FOR hcm.employee_records;"},
    {"label": "C", "text": "CREATE GLOBAL SYNONYM emp FOR hcm.employee_records;"},
    {"label": "D", "text": "CREATE SYNONYM SYS.emp FOR hcm.employee_records;"},
    {"label": "E", "text": "CREATE SYNONYM emp FOR hcm.employee_records;"}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "正确语法 CREATE PUBLIC SYNONYM <name> FOR <object>."
},
{
  "QuestionID": 194,
  "QuestionType": "multiple",
  "QuestionText": "Which two queries will execute successfully?",
  "ImageURL": "images/q194.png",
  "Options": [
    {"label": "A", "text": "SELECT dept_id, MAX(SUM(salary)) FROM employees GROUP BY dept_id;"},
    {"label": "B", "text": "SELECT AVG(MAX(salary)) FROM employees GROUP BY salary;"},
    {"label": "C", "text": "SELECT dept_id, AVG(MAX(salary)) FROM employees GROUP BY dept_id, salary;"},
    {"label": "D", "text": "SELECT dept_id, SUM(salary) FROM employees WHERE hire_date > '01-JAN-19' GROUP BY dept_id;"},
    {"label": "E", "text": "SELECT dept_id, AVG(MAX(salary)) FROM employees GROUP BY dept_id HAVING hire_date > '01-JAN-19';"}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "Oracle 不允许直接在同一级 SELECT 中嵌套聚合函数→ 用子查询解决\nA.跨组聚合,因为sum()产生了一组新的数值,MAX()要在这组新的数值进行聚合,属于跨组聚合,需要子查询\nB.GROUP BY salary,然后MAX(),其实还是原来的salary的数值,AVG()聚合还属于同组，所以合法"
},
{
  "QuestionID": 195,
  "QuestionType": "single",
  "QuestionText": "Which statement increases each employee's SALARY by the minimum SALARY for their DEPARTMENT_ID?",
  "ImageURL": "images/q195.png",
  "Options": [
    {"label": "A", "text": "UPDATE employees e1 \nSET salary = salary + \n(SELECT MIN(salary) \nFROM employees e2);"},
    {"label": "B", "text": "UPDATE employees e1 \nSET salary = \n(SELECT e2.salary + MIN(e2.salary) \nFROM employees e2 \nWHERE e1.department_id = e2.department_id \nGROUP BY e2.department_id);"},
    {"label": "C", "text": "UPDATE employees e1 \nSET salary = salary + \n(SELECT MIN(e1.salary) \nFROM employees e2 \nWHERE e1.department_id = e2.department_id);"},
    {"label": "D", "text": "UPDATE employees e1 \nSET salary = \n(SELECT e1.salary + MIN(e2.salary) \nFROM employees e2 \nWHERE e1.department_id = e2.department_id);"}
  ],
  "CorrectAnswer": ["D"],
  "Explanation": "B.UPDATE子查询必须返回 单个值"
},
{
  "QuestionID": 196,
  "QuestionType": "multiple",
  "QuestionText": "In which three situations will re-executing this query still return a row but with a different XID, indicating a new transaction has started?",
  "ImageURL": "images/q196.png",
  "Options": [
    {"label": "A", "text": "after successfully executing a DML statement following a failed DML statement"},
    {"label": "B", "text": "after successfully executing a CREATE TABLE statement followed by a CREATE INDEX statement"},
    {"label": "C", "text": "after successfully executing a TRUNCATE statement followed by a DML statement"},
    {"label": "D", "text": "after successfully executing a CREATE TABLE AS SELECT statement followed by a SELECT FOR UPDATE statement"},
    {"label": "E", "text": "after successfully executing a COMMIT or ROLLBACK followed by a SELECT statement"},
    {"label": "F", "text": "after successfully executing a COMMIT or ROLLBACK followed by a DML statement"}
  ],
  "CorrectAnswer": ["C", "D", "F"],
  "Explanation": ""
},
{
  "QuestionID": 197,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about indexes and their administration in an Oracle database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The same table column can be part of a unique and non-unique index."},
    {"label": "B", "text": "If a query filters on an indexed column then it will always be used during execution of the query."},
    {"label": "C", "text": "A descending index is a type of function-based index."},
    {"label": "D", "text": "An INVISIBLE index is not maintained when DML is performed on its underlying table."},
    {"label": "E", "text": "An UNUSABLE index is maintained when DML is performed on its underlying table."},
    {"label": "F", "text": "An index can be created as part of a CREATE TABLE statement."}
  ],
  "CorrectAnswer": ["A", "C", "F"],
  "Explanation": "索引就像书的目录，可以快速找到数据，而不必全表扫描;DML（INSERT/UPDATE/DELETE）会更新索引，除非索引是 UNUSABLE;INVISIBLE 索引仍然被维护，只是不被优化器默认使用\n查询优化器（Optimizer）是 Oracle 的“大脑”，决定 SQL 如何执行,作用\n--选择访问路径（Access Path）：全表扫描、索引扫描、位图索引等\n--选择连接方法（Join Method）：嵌套循环、哈希连接、排序合并\n--决定执行顺序和是否使用索引\n\nA.Oracle 允许一个列同时在唯一索引（UNIQUE INDEX） 和非唯一索引（NON-UNIQUE INDEX） 中出现\nB.Oracle 优化器会决定是否使用索引,并不是索引列每次都一定被用,如果表很小或索引选择性低，可能全表扫描更快\nC.降序索引DESCENDING INDEX:索引列按降序存储Oracle 内部实现类似函数索引（存储排序信息），可以视为特殊类型的 function-based inde\nD.INVISIBLE INDEX 只是查询优化器默认不使用,DML（INSERT/UPDATE/DELETE）仍然会维护索引\nF.在创建表时，可以直接创建索引"
},
{
  "QuestionID": 198,
  "QuestionType": "single",
  "QuestionText": "If LOCALTIMESTAMP was selected at the same time, what would it return?",
  "ImageURL": "images/q198.png",
  "Options": [
    {"label": "A", "text": "11-JUL-2019 6.00.00.00000000 AM"},
    {"label": "B", "text": "11-JUL-2019 11.00.00.00000000 AM"},
    {"label": "C", "text": "11-JUL-2019 11.00.00.0000000 AM -05:00"},
    {"label": "D", "text": "11-JUL-2019 6.00.00.00000000 AM -05:00"}
  ],
  "CorrectAnswer": ["A"],
  "Explanation": ""
},
{
  "QuestionID": 199,
  "QuestionType": "single",
  "QuestionText": "Which queries generate the same output?",
  "ImageURL": "images/q199.png",
  "Options": [
    {"label": "A", "text": "2 and 3"},
    {"label": "B", "text": "1 and 2"},
    {"label": "C", "text": "1 and 3"},
    {"label": "D", "text": "1, 2, and 3"}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "ANY = OR，IN = OR → 同义；ALL = AND → 全部匹配，单列永远难满足。"
},
{
  "QuestionID": 200,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "LAST_DAY returns the date of the last day of the month for the date argument passed to the function."},
    {"label": "B", "text": "CEIL returns the largest integer less than or equal to a specified number."},
    {"label": "C", "text": "LAST_DAY returns the date of the last day of the current month only."},
    {"label": "D", "text": "LAST_DAY returns the date of the last day of the previous month only."},
    {"label": "E", "text": "ADD_MONTHS adds a number of calendar months to a date."},
    {"label": "F", "text": "CEIL requires an argument which is a numeric data type."}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": ""
},
{
  "QuestionID": 201,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about scalar subquery expressions?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "You must enclose them in parentheses."},
    {"label": "B", "text": "You cannot correlate them with a table in the parent statement."},
    {"label": "C", "text": "They can return at most one row."},
    {"label": "D", "text": "They can return two columns."},
    {"label": "E", "text": "You can use them as a default value for a column."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "标量子查询Scalar Subquery是返回单个值的子查询，用于在 SELECT、WHERE、或者表达式中;特点:\n--1.必须用圆括号括起来\n--2.只能返回一行一列\n--3.可以与外层查询关联（correlated subquery）\nE.列默认值是指在创建表时，如果插入数据时没有为某个列提供值，就自动使用的默认值;可以是常量（数字、字符串、日期）;可以是函数（如 SYSDATE、SYSTIMESTAMP）;不能是子查询或 SELECT 语句"
},
{
  "QuestionID": 202,
  "QuestionType": "multiple",
  "QuestionText": "Which two can replace <clause> so the query completes successfully?",
  "ImageURL": "images/q202.png",
  "Options": [
    {"label": "A", "text": "product_id"},
    {"label": "B", "text": "quantity, unit_price"},
    {"label": "C", "text": "quantity"},
    {"label": "D", "text": "total_paid"},
    {"label": "E", "text": "quantity * unit_price"}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "Oracle 允许在 ORDER BY 中使用以下几种:\n--输出列的别名（例如 total_paid）\n--与 SELECT 列相同的表达式（例如 quantity * unit_price）\n--列序号（例如 ORDER BY 1）\n但不能直接使用那些 没出现在 SELECT 列表里的原始列（如 quantity、unit_price），否则会报错"
},
{
  "QuestionID": 203,
  "QuestionType": "multiple",
  "QuestionText": "Which two queries return rows where QUANTITY is a multiple of ten?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "SELECT * FROM order_items WHERE quantity / 10 = TRUNC (quantity);"},
    {"label": "B", "text": "SELECT * FROM order_items WHERE quantity = ROUND (quantity, 1);"},
    {"label": "C", "text": "SELECT * FROM order_items WHERE MOD (quantity, 10) = 0;"},
    {"label": "D", "text": "SELECT * FROM order_items WHERE quantity = TRUNC (quantity, -1);"},
    {"label": "E", "text": "SELECT * FROM order_items WHERE FLOOR (quantity / 10) = TRUNC (quantity / 10);"}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": "RUNC(number, n)：若 n 为负数，则会在小数点左边进行截断。TRUNC(25, -1) → 20; TRUNC(20, -1) → 20"
},
{
  "QuestionID": 204,
  "QuestionType": "multiple",
  "QuestionText": "You have been granted the CREATE ANY INDEX system privilege.\n You want to create an index, owned by you, on a table in another schema to which you have been granted only the SELECT privilege. \n\nWhich two are true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "You must have either the UNLIMITED TABLESPACE system privilege, or sufficient quota on the tablespace where the index will be created."},
    {"label": "B", "text": "You additionally require the INSERT, UPDATE, DELETE, and INDEX privileges on the table."},
    {"label": "C", "text": "You do not require any further object privileges on the table."},
    {"label": "D", "text": "You additionally require only the INDEX privilege on the table."},
    {"label": "E", "text": "The owner of the table must also have the CREATE ANY INDEX system privilege."},
    {"label": "F", "text": "The owner of the table must have either the UNLIMITED TABLESPACE system privilege, or sufficient quota on the tablespace where the index will be created."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "索引将由你自己拥有，即索引对象属于你的 schema，而不是表所属的 schema。因此，你不需要对表有 DML 权限（INSERT/UPDATE/DELETE），也不需要 INDEX 权限。索引本质上是你的对象，表只是被引用.\n创建索引需要在某个表空间上分配存储。因此，你必须有足够的表空间配额，或者拥有 UNLIMITED TABLESPACE 系统权限。这与表所属的 schema 无关,只跟索引所属 schema 有关。\n索引是属于某个 schema 的对象，默认放在创建它的用户名下。索引必须基于表的列创建。如果表属于别人的 schema，你需要满足两个条件：1.系统权限：你必须有 CREATE ANY INDEX 系统权限，允许在任何表上建索引。如果你没有这个权限，你只能在自己的表上建索引。2.表对象权限:对表必须至少有 SELECT 权限。你不需要 INSERT/UPDATE/DELETE 权限，因为索引本身不修改表数据。"
},
{
  "QuestionID": 205,
  "QuestionType": "multiple",
  "QuestionText": "Examine this statement which executes successfully:\n\nINSERT ALL\nWHEN SAL > 20000 THEN\nINTO special_sal VALUES (EMP_ID, SAL)\nELSE\nINTO sal_history VALUES (EMP_ID, HIREDATE, SAL)\nINTO mgr_history VALUES (EMP_ID, MGR, SAL)\nSELECT employee_id EMP_ID, hire_date HIREDATE, salary SAL, manager_id MGR\nFROM employees\nWHERE employee_id < 125;\n\nWhich is true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Only if the salary is 20000 or less and the employee id is 125 or higher, insert EMPLOYEE_ID, MANAGER_ID, and SALARY into the MGR_HISTORY table."},
    {"label": "B", "text": "Only if the salary is 20000 or less and the employee id is less than 125, insert EMPLOYEE_ID, MANAGER_ID, and SALARY into the MGR_HISTORY table."},
    {"label": "C", "text": "Regardless of salary and employee id, insert EMPLOYEE_ID, MANAGER_ID, and SALARY into the MGR_HISTORY table."},
    {"label": "D", "text": "Regardless of salary, only if the employee id is less than 125, insert EMPLOYEE_ID, MANAGER_ID, and SALARY into the MGR_HISTORY table."}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": ""
},
{
  "QuestionID": 206,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true regarding non-equijoins?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The USING clause can be used."},
    {"label": "B", "text": "Table aliases must be used."},
    {"label": "C", "text": "The Oracle join syntax can be used."},
    {"label": "D", "text": "The SQL:1999 compliant ANSI join syntax must be used."},
    {"label": "E", "text": "The ON clause can be used."}
  ],
  "CorrectAnswer": ["C", "E"],
  "Explanation": "A.USING 只能用于等值连接，并且列名相同的情况。非等值连接的条件不是简单等号，所以不能用 USING。\nSELECT EMP_ID, DEPT_NAME\nFROM EMPLOYEE\nJOIN DEPARTMENT\nUSING (DEPT_ID);"
},
{
  "QuestionID": 207,
  "QuestionType": "multiple",
  "QuestionText": "Which two object privileges can be restricted to a subset of columns in a table?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "ALTER"},
    {"label": "B", "text": "UPDATE"},
    {"label": "C", "text": "DELETE"},
    {"label": "D", "text": "INSERT"},
    {"label": "E", "text": "INDEX"}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "A.ALTER 是修改表结构的权限，不能限制到部分列，只能作用于整个表。\nC.DELETE 是删除整行的权限，不涉及列，因此不能限制到部分列\nE.INDEX 权限是创建索引的权限，作用于表，而不是列"
},
{
  "QuestionID": 208,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about the USING clause when joining tables?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It can never be used with a natural join."},
    {"label": "B", "text": "It is used to specify an explicit join condition involving operators."},
    {"label": "C", "text": "It can never be used with a full outer join."},
    {"label": "D", "text": "All column names in a USING clause must be qualified with a table name or table alias."},
    {"label": "E", "text": "It is used to specify an equijoin of columns that have the same name in both tables."}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": "USING 子句用于 等值连接（equijoin），而且只能用于两个表中具有相同列名的列，在 USING 子句中，这个公共列在结果集中只显示一次，而且不能加表别名\nB.USING 只能做 等值比较（=），不能写诸如 >, <, BETWEEN 或者函数调用。如果你想用运算符，就必须使用 ON\nCSELECT *\nFROM employees\nFULL OUTER JOIN departments\nUSING (department_id);\nD.在 USING子句里，列名不能加表名或别名"
},
{
  "QuestionID": 209,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about Oracle Managed Files (OMF)?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "If DB_RECOVERY_FILE_DEST is specified but DB_CREATE_ONLINE_LOG_DEST_n is not, the redo logs and control files are placed in DB_RECOVERY_FILE_DEST by default."},
    {"label": "B", "text": "If DB_RECOVERY_FILE_DEST is specified, at least two different locations must be specified for DB_CREATE_ONLINE_LOG_DEST_n."},
    {"label": "C", "text": "If only DB_CREATE_FILE_DEST is specified, only data files and temp files are Oracle managed."},
    {"label": "D", "text": "If DB_CREATE_ONLINE_LOG_DEST_1 is specified but DB_CREATE_FILE_DEST is not, new data files and temp files are stored in DB_CREATE_ONLINE_LOG_DEST_1 by default."},
    {"label": "E", "text": "If DB_CREATE_FILE_DEST is specified but DB_CREATE_ONLINE_LOG_DEST_n is not, new redo logs and control files are stored in DB_CREATE_FILE_DEST by default."},
    {"label": "F", "text": "If only DB_CREATE_ONLINE_LOG_DEST_1 is specified, only redo logs and control files are Oracle managed."}
  ],
  "CorrectAnswer": ["A", "E", "F"],
  "Explanation": "OMF（Oracle Managed Files）创建、命名、管理 数据库文件（Datafile、Tempfile、Redo log、Control file）\nDB_CREATE_FILE_DEST:控制Datafiles、Tempfiles，用于:表空间、临时表空间,指定数据文件默认目录\nDB_CREATE_ONLINE_LOG_DEST_n:控制Redo Logs、Control Files,用于在线日志与控制文件（最多5个路径）可用于日志多路复用\nDB_RECOVERY_FILE_DEST控制归档日志、闪回日志、备份片等，用于快速恢复区（FRA）也可能存放日志与控制文件(若未指定 log dest)\nFile（DB_CREATE_FILE_DEST） → 管 数据文件（data/temp）; Log（DB_CREATE_ONLINE_LOG_DEST_n） → 管 日志与控制文件; Recovery（DB_RECOVERY_FILE_DEST） → 底线兜底目录，如果上面两个没设，就放这"
},
{
  "QuestionID": 210,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about segment types in an Oracle Database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Index segments always have two or more extents."},
    {"label": "B", "text": "Undo segments are only stored in an undo tablespace."},
    {"label": "C", "text": "Temporary segments are only stored in a temporary tablespace."},
    {"label": "D", "text": "Cluster segments may contain data from multiple tables."},
    {"label": "E", "text": "Table segments always have two or more extents."}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": "B.系统undo 段是放在 system 表空间,undo 段也会放在临时表空间。\n D.Cluster（簇）允许将多张表按相同的列值放在同一物理存储区，以减少 I/O。因此 Cluster Segment会存储多张表的数据。"
},
{
  "QuestionID": 211,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about the Oracle Database server during and immediately after SHUTDOWN TRANSACTIONAL?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Uncommitted transactions are allowed to continue to the next ROLLBACK."},
    {"label": "B", "text": "New connection requests made to the database instance are refused."},
    {"label": "C", "text": "Instance recovery occurs at the next restart."},
    {"label": "D", "text": "Instance recovery occurs automatically during the shutdown."},
    {"label": "E", "text": "Sessions remain connected even if they are not running a transaction."},
    {"label": "F", "text": "Uncommitted transactions are allowed to continue to the next COMMIT."}
  ],
  "CorrectAnswer": ["A", "B", "F"],
  "Explanation": "SHUTDOWN NORMAL:等待所有用户断开连接后关闭实例；不会强制回滚事务\nSHUTDOWN IMMEDIATE立刻断开所有会话，回滚未提交事务，关闭实例\nSHUTDOWN TRANSACTIONAL等待当前活动事务完成（COMMIT 或 ROLLBACK）后，再关闭；拒绝新连接\nSHUTDOWN ABORT立刻终止所有会话，未提交事务丢失；不等待写入磁盘\nD.SHUTDOWN TRANSACTIONAL 主要 允许已启动事务继续，空闲会话（没有活动事务）一般会立即断开或等待事务启动后处理，所以不能说“所有空闲会话保持连接”"
},
{
  "QuestionID": 212,
  "QuestionType": "multiple",
  "QuestionText": "Which four statements are true about the Oracle Server architecture?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A person or program can have more than one session with an instance by logging in with different usernames."},
    {"label": "B", "text": "A person or program can have more than one session with an instance by logging in with the same username."},
    {"label": "C", "text": "A connection represents the state of a user's login to an instance."},
    {"label": "D", "text": "Each server process and background process has their own Program Global Area (PGA)."},
    {"label": "E", "text": "The buffer cache and the redo log buffer are held in the large pool."},
    {"label": "F", "text": "The entire data dictionary is always cached in the shared pool to improve performance."},
    {"label": "G", "text": "A session represents the state of a user's login to an instance."}
  ],
  "CorrectAnswer": ["A", "B", "D", "G"],
  "Explanation": "Oracle Server架构基础:\n--1.进程（Processes）:Server Process（服务器进程）：处理用户请求;Background Processes（后台进程）：如 SMON、PMON、DBWn、LGWR等\n--2.内存结构（Memory Structures）:\n*****SGA（System Global Area）：实例共享内存，包括：Shared Pool（共享池：Shared Pool就是Oracle的高速缓存区，用来存储常用SQL、PL/SQL、数据字典信息，避免每次都去硬盘读取）Database Buffer Cache（缓冲池）Redo Log Buffer（重做日志缓冲区）\n*****PGA（Program Global Area）：每个用户进程或后台进程独有的内存区域\n--3.逻辑单位:Session（会话）：用户登录实例后的状态信息; Connection（连接）：表示客户端与 Oracle 实例的物理连接\nC.Connection 是客户端与服务器之间的物理连接，不包含用户事务的状态。Session才表示用户登录的状态，包括事务、变量、游标等。\nE.large pool是shared pool中的子区域，主要是大型 I/O、并行查询、RMAN 备份等使用（非核心部分）\nF.数据字典对象（如表、列定义）按需缓存在 Shared Pool 中，不可能全部缓存。Oracle 会根据 LRU（最近最少使用）策略动态管理缓存。"
},
{
  "QuestionID": 213,
  "QuestionType": "multiple",
  "QuestionText": "Examine this command:\n\nALTER DATABASE MOVE DATAFILE '/u01/sales01.dbf' TO '/u02/sales02.dbf';\n\nWhich two statements are true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Compressed objects in SALES01.DBF will be uncompressed in SALES02.DBF after the move."},
    {"label": "B", "text": "DML may be performed on tables with one or more extents in this data file during the execution of this command."},
    {"label": "C", "text": "Tables with one or more extents in this data file may be queried during the execution of this command."},
    {"label": "D", "text": "The 'TO' clause containing the new file name must be specified even if Oracle Managed Files (OMF) is used."},
    {"label": "E", "text": "It overwrites any existing file with the name SALES02.DBF in /u02 by default."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "A.数据文件移动不会改变表或索引的存储格式\nD.如果使用 OMF，Oracle 会自动管理文件名和路径，可以不写 TO，Oracle 会生成默认路径\nE.Oracle 不会默认覆盖已有文件，如果目标位置已有同名文件，会报错"
},
{
  "QuestionID": 214,
  "QuestionType": "single",
  "QuestionText": "Your database instance is started with an SPFILE. A PFILE is also available. You execute this command:\n\nALTER SYSTEM SET DB_CACHE_SIZE=100K;\n\nWhere is the value changed?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "in the SPFILE and PFILE"},
    {"label": "B", "text": "in the SPFILE and in memory"},
    {"label": "C", "text": "only in memory"},
    {"label": "D", "text": "only in the SPFILE"},
    {"label": "E", "text": "in the SPFILE, PFILE, and memory"}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "没有指定 SCOPE，Oracle 默认规则：如果 实例启动使用 SPFILE → 默认修改内存 + SPFILE; 如果 实例启动使用PFILE → 默认修改内存（PFILE 是静态的，不会自动修改）"
},
{
  "QuestionID": 215,
  "QuestionType": "multiple",
  "QuestionText": "Which two Oracle database space management features require the use of locally managed tablespaces?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Automatic data file extension (AUTOEXTEND)"},
    {"label": "B", "text": "Online segment shrink"},
    {"label": "C", "text": "Free space management with bitmaps"},
    {"label": "D", "text": "Oracle Managed Files (OMF)"},
    {"label": "E", "text": "Server-generated tablespace space alerts"}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "Locally Managed Tablespace (LMT)使用 位图 (Bitmap) 管理空闲空间,在线收缩 + 位图自由 = LMT 必备"
},
{
  "QuestionID": 216,
  "QuestionType": "single",
  "QuestionText": "Which compression method is recommended for Direct-Path Insert operations?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "COLUMN STORE COMPRESS ADVANCED"},
    {"label": "B", "text": "ROW STORE COMPRESS BASIC"},
    {"label": "C", "text": "COLUMN STORE COMPRESS BASIC"},
    {"label": "D", "text": "ROW STORE COMPRESS ADVANCED"}
  ],
  "CorrectAnswer": ["D"],
  "Explanation": "ROW STORE COMPRESS BASIC;用于常规 DML 操作;压缩插入前的行，节省存储空间\nROW STORE COMPRESS ADVANCED 用于OLTP / Direct-Path Insert;支持直接路径插入（Direct-Path Insert），压缩率更高，性能优化\nCOLUMN STORE COMPRESS BASIC用于OLAP / Columnar；基于列存储，节省存储，适合分析查询\nCOLUMN STORE COMPRESS ADVANCED;用于OLAP / Columnar;高级列存储压缩，适合混合分析场景"
},
{
  "QuestionID": 217,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about the naming methods and their features supported by Oracle database used to resolve connection information?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Directory Naming can be used if Connect-Time Failover is required."},
    {"label": "B", "text": "A client can connect to an Oracle database instance even if no client side network admin has been configured."},
    {"label": "C", "text": "Directory Naming requires setting the TNS_ADMIN environment variable on the client side."},
    {"label": "D", "text": "Local Naming requires setting the TNS_ADMIN environment variable on the client side."},
    {"label": "E", "text": "Easy Connect supports TCP/IP and SSL."},
    {"label": "F", "text": "Local naming can be used if Connect-Time Failover is required."}
  ],
  "CorrectAnswer": ["A", "B", "F"],
  "Explanation": "--Local Naming:使用 tnsnames.ora 文件，客户端解析服务名;可支持Connect-Time Failover;需要配置 tnsnames.ora\n--Directory Naming:使用 LDAP（Oracle Internet Directory, OID）存储服务名;可支持Connect-Time Failover;需要客户端指向 LDAP，设置 TNS_ADMIN / LDAP_ADMIN\n--Easy Connect:简单方式，直接用 hostname:port/service_name;不支持复杂 Connect-Time Failover;无需 tnsnames.ora; Easy Connect 主要是 TCP/IP 直连，不原生支持SSL(Secure Sockets Layer是一种安全传输协议)\n--External Naming:OS 级别名称解析;可选Connect-Time Failover;依赖操作系统\nConnect-Time Failover（在客户端重试另一节点）只有 Local Naming 和 Directory Naming 支持\n\nB.使用 Easy Connect，客户端无需 tnsnames.ora 或 LDAP，即可通过\nD.TNS_ADMIN 是可选的，用于指定 tnsnames.ora 的位置，如果放在默认路径下（$ORACLE_HOME/network/admin），不必设置"
},
{
  "QuestionID": 218,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about using SQL*Plus?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It can run Recovery Manager (RMAN) commands."},
    {"label": "B", "text": "It can run scripts passed to it by a shell script."},
    {"label": "C", "text": "It can run scripts entered at the SQL prompt."},
    {"label": "D", "text": "It has its own commands that are separate from any SQL statements."},
    {"label": "E", "text": "It has both command-line and graphical user interfaces (GUI)."},
    {"label": "F", "text": "It must be downloaded from the Oracle Technology Network (OTN)."}
  ],
  "CorrectAnswer": ["B", "C", "D"],
  "Explanation": "SQL*Plus 是 Oracle 提供的命令行工具，用于执行 SQL、PL/SQL 语句，同时有自己独立的命令（如 SET, SPOOL, SHOW）。它可以运行脚本、交互式执行 SQL，也可以通过操作系统的 shell 脚本批量执行 SQL 脚本\nA.RMAN 有自己的客户端工具（rman），不能通过 SQL*Plus 直接执行 RMAN 命令。SQL*Plus 只能执行 SQL、PL/SQL 和自身命令\nF.SQL*Plus 已经随 Oracle Database 或 Oracle Client 安装包一起提供，无需单独下载"
},
{
  "QuestionID": 219,
  "QuestionType": "multiple",
  "QuestionText": "Which three activities are recorded in the database alert log?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "session logins and logouts"},
    {"label": "B", "text": "deadlock errors"},
    {"label": "C", "text": "block corruption errors"},
    {"label": "D", "text": "non-default database parameters"},
    {"label": "E", "text": "Data Definition Language (DDL) statements"}
  ],
  "CorrectAnswer": ["B", "C", "D"],
  "Explanation": "Alert Log（警告日志）记“大事”:记录实例级重大事件和错误;Trace File（跟踪文件）查“细节”:记录后台进程或用户会话的详细诊断信息;Audit Log（审计日志）管“人事”:记录用户行为，用于安全审计\nalert log 会记录的内容:1.启动与关闭信息:实例启动、关闭\n2.重大错误事件:ORA-600、ORA-7445、block corruption\n3.后台进程错误:SMON、DBWn、LGWR、ARCn 等进程错误\n4.参数更改:修改了非默认参数（例如 ALTER SYSTEM SET）\n5.结构性变更:表空间或数据文件增加/移动\n6.警告或告警信息:空间不足、归档失败等"
},
{
  "QuestionID": 220,
  "QuestionType": "multiple",
  "QuestionText": "You must create a tablespace of non-standard block size in a new file system and plan to use this command:\n\nCREATE TABLESPACE ns_tbs\nDATAFILE '/u02/oracle/data/nstbs_f01.dbf'\nSIZE 100G\nBLOCKSIZE 32K;\n\nThe standard block size is 8K but other non-standard block sizes will also be used.\n\nWhich two are requirements for this command to succeed?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "DB_32K_CACHE_SIZE must be set to a value that can be accommodated in the SGA."},
    {"label": "B", "text": "DB_32K_CACHE_SIZE must be less than DB_CACHE_SIZE."},
    {"label": "C", "text": "DB_32K_CACHE_SIZE should be set to a value greater than DB_CACHE_SIZE."},
    {"label": "D", "text": "The operating system must use a 32K block size."},
    {"label": "E", "text": "The /u02 file system must have at least 100G space for the datafile."},
    {"label": "F", "text": "DB_CACHE_SIZE must be set to a size that is smaller than DB_32K_CACHE_SIZE."}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": "Oracle 数据库允许在同一个数据库中使用多个块大小（multi-block size），但必须满足以下条件：\n1.每种非标准块大小都要有对应的 buffer cache。例如：对于 2K 块：DB_2K_CACHE_SIZE对于; 4K 块：DB_4K_CACHE_SIZE\n2.每个非标准块缓存参数必须在 SGA 中预先分配内存，否则 Oracle 无法缓存这种块大小的数据页，会报错。\nA.因为你要创建一个 BLOCKSIZE 32K 的表空间，Oracle 需要在内存中有一个相应的 32K 缓存区（buffer cache）来缓存这些块。所以你必须在初始化参数文件（spfile/pfile）里设置：ALTER SYSTEM SET DB_32K_CACHE_SIZE = 128M;并且这块内存必须能放入 SGA（系统全局区）。"
},
{
  "QuestionID": 221,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about connection strings and service names used to connect to an Oracle database instance?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A connection string must include the SID of a database instance."},
    {"label": "B", "text": "A single connection string can refer to multiple database instances."},
    {"label": "C", "text": "A connection string including a service name must be defined in the tnsnames.ora file."},
    {"label": "D", "text": "A service name is created by a listener."},
    {"label": "E", "text": "Different connection strings in the same tnsnames.ora file can contain the same service name, host and port parameters."},
    {"label": "F", "text": "A single database instance can support connections for multiple service names."}
  ],
  "CorrectAnswer": ["B", "E", "F"],
  "Explanation": "Connection string就是用来告诉客户端如何连接到数据库的一串信息。数据库的地址（host/IP）端口号（port，Oracle 默认 1521）服务名或 SID（指定要连接哪个数据库实例）有时还包括用户名和密码（可选）\n在 Oracle 中，连接数据库有两种常用方式：1.使用 SID：直接指定某个实例的系统标识符（SID）。2.使用 Service Name：更灵活，允许一个实例提供多个服务或支持 RAC 环境。\nB.在 RAC（Real Application Clusters） 环境下，一个 service name 可以对应多个实例。\nD.服务名由数据库实例通过动态注册或静态配置（listener.ora）提供给监听器，而非由监听器创建。"
},
{
  "QuestionID": 222,
  "QuestionType": "multiple",
  "QuestionText": "Examine this command:\n\nSQL> ALTER TABLE ORDERS SHRINK SPACE COMPACT\n\nWhich two statements are true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The high-water mark (HWM) of ORDERS is adjusted."},
    {"label": "B", "text": "Only queries are allowed on ORDERS while the SHRINK is executing."},
    {"label": "C", "text": "Dependent indexes become UNUSABLE."},
    {"label": "D", "text": "The SHRINK operation causes rows to be moved to empty space starting from the beginning of the ORDERS segment."},
    {"label": "E", "text": "Queries and DML statements are allowed on ORDERS while the SHRINK is executing."},
    {"label": "F", "text": "The SHRINK operation causes rows to be moved to empty space starting toward the end of the ORDERS segment."}
  ],
  "CorrectAnswer": ["E", "F"],
  "Explanation": "A.使用 COMPACT 只是压缩数据，不会立即调整 HWM。HWM 只有在执行 SHRINK SPACE（不加 COMPACT）或者执行 SHRINK SPACE 后的第二步时才会下降;SHRINK SPACE COMPACT = “先压缩，不回收”;SHRINK SPACE= “压缩 + 回收空间（降低 HWM）”\nB.SHRINK SPACE COMPACT 允许查询和DML，所以不仅仅是查询。\nC.SHRINK SPACE对索引是透明的，表的索引不会被破坏，也不会变为不可用，你不需要对索引做任何额外操作；SHRINK SPACE 会移动表里的数据行（从段尾向前压缩空闲空间），但 Oracle 会自动维护索引指向行的 OWID，保证索引依然正确指向对应的行。SHRINK SPACE CASCADE索引段也收缩，释放空间\nD.行是从 段的末尾往前移动，以压缩尾部空闲空间\n"
},
{
  "QuestionID": 223,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about Database Instances and Real Application Clusters (RAC)?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A RAC database can have instances on separate servers."},
    {"label": "B", "text": "A RAC database must have two or more instances."},
    {"label": "C", "text": "A RAC database must have three or more instances."},
    {"label": "D", "text": "A RAC database can have one instance."},
    {"label": "E", "text": "Two RAC databases can share their instances."}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": "A.RAC 的核心就是 多实例、多节点，每个实例运行在不同的服务器上，但访问同一个数据库（共享存储）。\nE.一个实例只能属于一个数据库，不同 RAC 数据库不能共享实例。"
},
{
  "QuestionID": 224,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about Deferred Segment Creation in Oracle databases?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is supported for Index Organized Tables (IOTs) contained in locally managed tablespaces."},
    {"label": "B", "text": "It is supported for sys-owned tables contained in locally managed tablespaces."},
    {"label": "C", "text": "Sessions may dynamically switch back and forth from DEFERRED to IMMEDIATE segment creation."},
    {"label": "D", "text": "It is the default behavior for tables and indexes."},
    {"label": "E", "text": "Indexes inherit the DEFERRED or IMMEDIATE segment creation attribute from their parent table."}
  ],
  "CorrectAnswer": ["C", "D", "E"],
  "Explanation": "延迟段创建不支持的表类型包括：\n① 索引组织表（Index-Organized Tables）、簇表（Clustered Tables）、全局临时表（Global Temporary Tables）、会话级临时表（Session-Specific TemporaryTables）、内部表（Internal Tables）、Typed表（Typed Tables）、AQ表（AQ Tables）和外部表（External Tables）。\n② 用户SYS、SYSTEM、PUBLIC、OUTLN和XDB下的表不支持延迟段创建。\n③ 延迟段创建不支持位图连接索引（Bitmap Join Indexes）和域索引（DomainIndexes）。\n④ 延迟段创建不支持字典管理表空间（Dictionary-Managed Tablespace，DMT）。\n⑤ 延迟段创建不支持SYSTEM表空间。\n⑥ 延迟段创建从Oracle 11.2.0.2版本开始才开始支持分区和子分区。\n\nC.ALTER SESSION SET deferred_segment_creation = FALSE(TRUE → 默认 DEFERRED;FALSE → 默认 IMMEDIATE)\nD.从 Oracle 12c 开始，延迟段创建是 新表和索引的默认行为。\nE.索引在创建时会继承父表的段创建策略，除非显式指定。"
},
{
  "QuestionID": 225,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about the Automatic Diagnostic Repository (ADR)?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is a file-based repository held outside any database."},
    {"label": "B", "text": "It is held inside an Oracle database schema."},
    {"label": "C", "text": "The ADR base is specified in the DIAGNOSTIC_DEST database parameter."},
    {"label": "D", "text": "It is only used for Oracle Database diagnostic information."},
    {"label": "E", "text": "It can be used for problem diagnosis of a database when that database's instance is down."}
  ],
  "CorrectAnswer": ["A", "C", "E"],
  "Explanation": "ADR 是 Oracle 用来存储诊断信息（如 警报日志、跟踪文件、核心转储）的统一文件系统仓库。ADR独立于数据库，不在数据库schema 内。ADR 支持数据库实例即使未启动时的故障诊断；ADR根目录 = DIAGNOSTIC_DEST，每个实例一个子目录，里面有 alert log、trace、incident 等\nD.ADR 还可以存储 Oracle ASM、Listener等其他Oracle 产品的诊断信息。"
},
{
  "QuestionID": 226,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about User Authentication in an Oracle Database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Password File authentication is supported for any type of database user."},
    {"label": "B", "text": "REMOTE_LOGIN_PASSWORDFILE must be set to exclusive to permit password changes for system-privileged administrative users."},
    {"label": "C", "text": "Operating System authentication may be used for system-privileged administrative users."},
    {"label": "D", "text": "Password authentication must be used for system-privileged administrative users."},
    {"label": "E", "text": "Password File authentication must be used for system-privileged administrative users."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "Oracle 数据库支持几种认证方式：\n--1.Password File Authentication（密码文件认证）:用于远程管理员连接（如 SYSDBA、SYSOPER）;需要 REMOTE_LOGIN_PASSWORDFILE 参数配置;只支持系统管理员用户（SYSDBA、SYSOPER），普通数据库用户不能通过密码文件认证;\n--2.Operating System Authentication（操作系统认证）:通过操作系统用户身份验证数据库管理员;适用于本地登录（如 / as sysdba）\n--3.Database Password Authentication（数据库密码认证）:数据库内部用户使用自己的密码登录\nB.只有 EXCLUSIVE 模式允许系统管理员用户更新密码并管理密码文件。\nD.系统管理员可以使用 操作系统认证 或 密码文件认证，不一定非要数据库密码。"
},
{
  "QuestionID": 227,
  "QuestionType": "single",
  "QuestionText": "Which set operator generates the required output?",
  "ImageURL": "images/q227.png",
  "Options": [
    {"label": "A", "text": "SUBTRACT"},
    {"label": "B", "text": "UNION ALL"},
    {"label": "C", "text": "INTERSECT"},
    {"label": "D", "text": "UNION"},
    {"label": "E", "text": "MINUS"}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": ""
},
{
  "QuestionID": 228,
  "QuestionType": "multiple",
  "QuestionText": "Which three resource limits can be configured using Oracle profiles?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "limiting connect time for user sessions"},
    {"label": "B", "text": "limiting CPU used by a user"},
    {"label": "C", "text": "limiting idle time for user sessions only when blocking other sessions"},
    {"label": "D", "text": "limiting idle time for user sessions only when not blocking other sessions"},
    {"label": "E", "text": "limiting idle time for user sessions"},
    {"label": "F", "text": "limiting CPU used by a session"}
  ],
  "CorrectAnswer": ["A", "E", "F"],
  "Explanation": "IDLE_TIME → 只看会话空闲时间，不关心是否阻塞其他会话。"
},
{
  "QuestionID": 229,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about unexpired undo?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is required when a transaction issues a ROLLBACK statement."},
    {"label": "B", "text": "It is the first type of UNDO overwritten when trying to avoid out-of-space errors."},
    {"label": "C", "text": "It may be used to support flashback queries."},
    {"label": "D", "text": "It is retained if possible for the time specified in UNDO_RETENTION."},
    {"label": "E", "text": "It consists of UNDO only for uncommitted transactions."}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": "A.ROLLBACK当事务发现错误;需要撤销自己做的修改;只能撤销当前事务未提交的修改,依赖active undo;FLASHBACK回溯历史数据，修复已提交的数据错误;可以查看表、行在某一时间点的状态;不影响其他会话事务,依赖Unexpired Undo / Flashback日志\nB.Oracle 优先覆盖 Expired Undo，而不是未过期 Undo\nC.Flashback 查询依赖 未过期 Undo 来重建过去的表数据。"
},
{
  "QuestionID": 230,
  "QuestionType": "multiple",
  "QuestionText": "Which three are benefits of using temp UNDO when performing DML on global temporary tables?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It reduces I/Os to the SYSTEM tablespace."},
    {"label": "B", "text": "It reduces the amount of redo generated."},
    {"label": "C", "text": "It reduces the amount of UNDO stored in the UNDO tablespace."},
    {"label": "D", "text": "It permits DML on Global temporary tables even if the database is opened read only."},
    {"label": "E", "text": "It reduces I/Os to the SYSAUX tablespace."}
  ],
  "CorrectAnswer": ["B", "C", "D"],
  "Explanation": "A.GTT数据和临时Undo不涉及SYSTEM表空间\nB.对临时表的DML通常不会生成redo（或只生成最少 redo），提高性能\nC.使用临时Undo，GTT的DML不占用普通Undo表空间。、D.当temp UNDO被启用时，在物理备用数据库（standby）场景下，对GTT的DML是允许的。\nE.SYSAUX 表空间和GTT临时Undo无关"
},
{
  "QuestionID": 231,
  "QuestionType": "multiple",
  "QuestionText": "You start your database instance in NOMOUNT state. Which two actions are performed?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The control files are opened."},
    {"label": "B", "text": "Memory is allocated for the SGA."},
    {"label": "C", "text": "SYS can access the database."},
    {"label": "D", "text": "All required background processes are started."},
    {"label": "E", "text": "The consistency of the database is checked."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": ""
},
{
  "QuestionID": 232,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about UNDO and REDO?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "UNDO is used for some flashback operations."},
    {"label": "B", "text": "Both REDO and UNDO can be multiplexed."},
    {"label": "C", "text": "UNDO is used for read consistency."},
    {"label": "D", "text": "REDO is used for ROLLBACK."},
    {"label": "E", "text": "REDO is used for read consistency."},
    {"label": "F", "text": "REDO is used for instance recovery."}
  ],
  "CorrectAnswer": ["A", "C", "F"],
  "Explanation": "B.只有 Redo Log 可以 multiplex（多路复用，多份备份、同时写入多个文件），即保存多份副本来防止丢失。"
},
{
  "QuestionID": 233,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about Resumable Space Allocation in Oracle databases?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "All sessions must have the same timeout value when waiting for resumable space allocations."},
    {"label": "B", "text": "A user's session may be suspended and resumed multiple times."},
    {"label": "C", "text": "A user's session may be suspended even if the user has the UNLIMITED TABLESPACE system privilege."},
    {"label": "D", "text": "Resumable space allocation is only possible with locally managed tablespaces."},
    {"label": "E", "text": "The AFTER SUSPEND event trigger can itself be suspended due to space conditions."},
    {"label": "F", "text": "Resumable space allocation may be enabled for some sessions and not others."}
  ],
  "CorrectAnswer": ["B", "C", "F"],
  "Explanation": "Resumable Space Allocation可恢复空间分配:就是 Oracle 在执行 DML 时，遇到“空间不够”的情况不会立刻报错中断，而是暂停（suspend）一会儿，等你处理完问题（比如加表空间）再自动继续执行（resume）。\nA.超时值（TIMEOUT）通过 ALTER SESSION 单独设置，各会话可不同\nB.同一个会话可能在不同时间点多次暂停再恢复。比如：1.第一次空间满了 → 暂停 → DBA 加表空间 → 恢复。2.过一会儿又满了 → 再次暂停 → 再加空间 → 又恢复。\nC.就算用户有 UNLIMITED TABLESPACE（无限表空间权限），也可能因为其他资源（比如临时表空间 temp、UNDO 表空间）满了而被暂停。所以这个 privilege 不保证永远不会suspend。\nD.可恢复空间分配与表空间管理方式无关，支持字典管理和本地管理表空间。\nE.该触发器执行时若空间不足，会直接失败（报错），而非被暂停\nF.这个特性是按会话启用的，不是全局强制"
},
{
  "QuestionID": 234,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about Private Temporary Tables (PTTs) in an Oracle Database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Concurrent sessions may have PTTS with the same name and the same column definitions."},
    {"label": "B", "text": "It is possible to preserve the private table definition but remove the rows when a session with a PTT issues a COMMIT."},
    {"label": "C", "text": "Creating a PTT is DDL and commits any active transaction for the session."},
    {"label": "D", "text": "Concurrent sessions may have PTTS with the same name but different column definitions."},
    {"label": "E", "text": "Concurrent sessions may have PTTS with different names but same column definitions."}
  ],
  "CorrectAnswer": ["A", "D", "E"],
  "Explanation": "Private Temporary Table (PTT)只对创建它的会话可见（Session-private）;结构在 会话结束后自动消失;数据存储在 临时表空间，使用类似 Global Temporary Table 的机制;允许同一个数据库不同会话创建 同名或不同名的 PTT，互不干扰;PTT 是 DDL 操作（CREATE TABLE），但它在会话结束时自动消失，不需要手动 DROP\nB.PTT的数据行为取决于 ON COMMIT 子句，但和 GTT 有点不同：ON COMMIT PRESERVE DEFINITION（默认行为）:表结构会保留,数据也会保留,COMMIT 后表依然存在，数据不丢失; ON COMMIT DROP DEFINITION:表结构和数据都会在事务 COMMIT 时消失相当于提交就自动 DROP\nC.PTT 确实是 DDL，但在 Oracle 中 CREATE PRIVATE TEMPORARY TABLE 不会提交当前事务，这与普通 CREATE TABLE 不同（普通 CREATE TABLE 会隐式提交）。"
},
{
  "QuestionID": 235,
  "QuestionType": "single",
  "QuestionText": "Choose the best answer. Why would you use the TNSPING hr command?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "to verify if a requested service is available"},
    {"label": "B", "text": "to determine if the listener for the HR net service name can be reached"},
    {"label": "C", "text": "to verify if the HR database instance is up"},
    {"label": "D", "text": "to check and list multiple ORACLE_HOME locations on the server"},
    {"label": "E", "text": "to validate the network connectivity between a client and the database instance"}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "TNSPING 是 Oracle 提供的一个网络诊断工具，用来检查 Oracle Net 服务是否可达。它不会尝试连接数据库实例，只检查 Listener是否可以访问。常用于排查网络问题或Listener 配置问题"
},
{
  "QuestionID": 236,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the UNLIMITED TABLESPACE system privilege and space quotas?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is overridden by a space quota specified for the user."},
    {"label": "B", "text": "It allows a user to have unlimited space in any tablespace in the database."},
    {"label": "C", "text": "By default, users have no quota on their default permanent tablespace."},
    {"label": "D", "text": "It allows a user to have unlimited space only in their default permanent tablespace."},
    {"label": "E", "text": "It allows a role to have unlimited space in any tablespace in the database."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "UNLIMITED TABLESPACE 系统权限用于控制用户在数据库中能使用的空间量。空间配额（space quota） 用于限制用户在某个特定表空间中能使用的空间。\nC.默认情况下，如果没有显式分配配额，用户在默认永久表空间 没有配额限制。注意：这并不是“无限”，只是“未分配配额”，可能依赖于表空间剩余空间\nE.UNLIMITED TABLESPACE是授予用户的权限，不是直接授予角色的"
},
{
  "QuestionID": 237,
  "QuestionType": "multiple",
  "QuestionText": "Which three files are used by conventional path SQL*Loader when the TABLE option is not specified?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "password files"},
    {"label": "B", "text": "dump files"},
    {"label": "C", "text": "input files"},
    {"label": "D", "text": "control files"},
    {"label": "E", "text": "bad files"}
  ],
  "CorrectAnswer": ["C", "D", "E"],
  "Explanation": "SQL*Loader 是 Oracle 提供的 批量加载工具，用来把外部数据文件（比如 CSV、文本文件）快速导入数据库表。它主要有两种路径:\n--1.Conventional Path：使用 INSERT 语句逐行加载数据，适用于大多数情况。\n--2.Direct Path：直接将数据写入数据文件，绕过 SQL 层，更快，但有一些限制。\nconventional path会生成大量INSERT语句，每条都走SQL引擎。Direct path 直接把数据写入表数据块，不走SQL语句。\n\nC.就是你要加载的数据文件。例如：data.csv 或 data.txt\nD.告诉 SQL*Loader 如何解析数据文件和插入数据的规则\nE.记录加载失败的行（格式错误、违反约束等）。默认生成：*.bad 文件，用于排查错误"
},
{
  "QuestionID": 238,
  "QuestionType": "multiple",
  "QuestionText": "Which four activities can be performed using SQL Developer?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It must be configured to allow SQLcl to be used."},
    {"label": "B", "text": "It can be used to develop server-side java programs."},
    {"label": "C", "text": "It can be used to back up and recover databases using RMAN."},
    {"label": "D", "text": "It can be used to administer database security."},
    {"label": "E", "text": "It can run SQL statements and SQL scripts."},
    {"label": "F", "text": "It can be used to debug PL/SQL programs."},
    {"label": "G", "text": "It can be used to develop client-side java programs."}
  ],
  "CorrectAnswer": ["C", "D", "E", "F"],
  "Explanation": "A.SQLcl是 Oracle的命令行SQL工具，可以和SQL Developer配合，但SQL Developer本身不依赖 SQLcl。\nB.SQL Developer的 Java 功能主要是 客户端辅助工具，而不是完整的服务器端开发环境。\nC.SQL Developer可以集成RMAN（Recovery Manager），允许可视化地执行备份和恢复任务。\nD.通过 SQL Developer 管理用户、角色、权限和安全策略"
},
{
  "QuestionID": 239,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about Enterprise Manager Cloud Control?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is available to manage a database only when that database is open."},
    {"label": "B", "text": "It is integrated with My Oracle Support."},
    {"label": "C", "text": "It provides management for Oracle middleware."},
    {"label": "D", "text": "It provides management for Oracle-engineered systems."},
    {"label": "E", "text": "It uses a web-based console built into the Oracle database using XML DB."}
  ],
  "CorrectAnswer": ["B", "C", "D"],
  "Explanation": "A.EM可以管理 开/关状态的数据库，但通常只能监控已打开的数据库实例\nB.EM Cloud Control 内置与 My Oracle Support (MOS) 集成;可以直接在控制台查看补丁信息、错误单、建议等\nC.EM可以管理 Oracle 中间件产品（如 WebLogic、Fusion Middleware、SOA 等;中间件 = 应用程序和操作系统/数据库之间的“中间层”软件,连接前端和后端：比如 Web 页面（前端）要访问数据库（后端），中间件负责传输请求和结果;提供公共服务：事务管理、安全认证、消息队列、负载均衡等;让应用开发更方便：开发者不用每次都从零处理网络通信、数据库连接、事务管理等\nE.EM Cloud Control 使用独立的 Web 控制台,通常部署在OMS:Oracle Management Server 上），不是内置在数据库里。内置 XML DB 控制台属于 Database Express (DB Express)，与 Cloud Control 不同。"
},
{
  "QuestionID": 240,
  "QuestionType": "multiple",
  "QuestionText": "Which three are types of segments in an Oracle Database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "tables"},
    {"label": "B", "text": "stored procedures"},
    {"label": "C", "text": "sequences"},
    {"label": "D", "text": "views"},
    {"label": "E", "text": "undo"},
    {"label": "F", "text": "clusters"}
  ],
  "CorrectAnswer": ["A", "E", "F"],
  "Explanation": "常见的 Segment 类型：\n--1.表段（Table Segment）：存储表数据\n--2.索引段（Index Segment）：存储索引数据\n--3.Undo 段（Undo Segment）：存储撤销信息（用于事务回滚）\n--4.集群段（Cluster Segment）：多个表共享的数据块\n--5.临时段（Temporary Segment）：临时表或排序操作使用\n段是数据库中 物理存储的最小单位之一，与表、索引等对象密切相关。"
},
{
  "QuestionID": 241,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true regarding indexes?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A table belonging to one user cannot have an index that belongs to a different user."},
    {"label": "B", "text": "When a table is dropped and is moved to the RECYCLE BIN, all indexes built on that table are permanently dropped."},
    {"label": "C", "text": "An update to a table can result in updates to any or all of the table's indexes."},
    {"label": "D", "text": "An update to a table can result in no updates to any of the table's indexes."},
    {"label": "E", "text": "A UNIQUE index can be altered to be non-unique."}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": ""
},
{
  "QuestionID": 242,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements about Oracle SQL functions are true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "INSTR finds the offset within a character string, starting from position 0."},
    {"label": "B", "text": "FLOOR returns the largest integer less than or equal to a specified number."},
    {"label": "C", "text": "CONCAT joins two or more character strings together."},
    {"label": "D", "text": "INSTR finds the offset within a string of a single character only."},
    {"label": "E", "text": "FLOOR returns the largest positive integer less than or equal to a specified number."},
    {"label": "F", "text": "CONCAT joins two character strings together."}
  ],
  "CorrectAnswer": ["B", "F"],
  "Explanation": "A.SELECT INSTR('HELLO WORLD', 'O', 1, 2) FROM DUAL;第2个'O'出现在第8个字符位置(空格也算位置)。INSTR 函数是从位置 1 开始计数的\nC. CONCAT 函数 只能连接两个字符串，如果要连接多个字符串，需要嵌套使用 CONCAT SELECT CONCAT(CONCAT('Hello', ' '), 'World') AS result FROM DUAL;或者用 || 运算符:SELECT 'Hello' || ' ' || 'World' || '!' AS result FROM DUAL;\nD.也可以多个字符"
},
{
  "QuestionID": 243,
  "QuestionType": "single",
  "QuestionText": "Examine this schema information:\n1.EMPLOYEES.DEPARTMENT_ID has a foreign key referencing \nDEPARTMENTS.DEPARTMENT_ID.\n2.EMP_VIEW is based on the EMPLOYEES and DEPARTMENTS tables.\n3.EMP_VIEW has columns EMPLOYEE_ID, EMPLOYEE_NAME and DEPARTMENT_NAME.\nYou must add a new column, MANAGER_ID, from the EMPLOYEES table, to the view, showing each employee's manager.\nWhich statement will do this?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "CREATE OR REPLACE VIEW emp_view AS \nSELECT employee_id, employee_name, department_name, manager_id \nFROM employees e, departments d \nWHERE e.department_id = d.department_id;"},
    {"label": "B", "text": "ALTER VIEW emp_view ADD (employee.manager_id);"},
    {"label": "C", "text": "ALTER VIEW emp_view MODIFY \n(SELECT employee_id, employee_name, department_name, manager_id \nFROM employees e, departments d \nWHERE e.department_id = d.department_id);"},
    {"label": "D", "text": "ALTER VIEW emp_view ADD (SELECT manager_id FROM employees);"}
  ],
  "CorrectAnswer": ["A"],
  "Explanation": "视图不能进行 alter，只能重建。"
},
{
  "QuestionID": 244,
  "QuestionType": "multiple",
  "QuestionText": "",
  "ImageURL": "images/q244.png",
  "Options": [
    {"label": "A", "text": "SELECT customer_name FROM customers WHERE customer_name LIKE 'Ma*';"},
    {"label": "B", "text": "SELECT customer_name FROM customers WHERE customer_name LIKE '%a%';"},
    {"label": "C", "text": "SELECT customer_name FROM customers WHERE UPPER(customer_name) LIKE 'MA%';"},
    {"label": "D", "text": "SELECT customer_name FROM customers WHERE customer_name LIKE '*Ma*';"},
    {"label": "E", "text": "SELECT customer_name FROM customers WHERE customer_name LIKE 'Ma%';"},
    {"label": "F", "text": "SELECT customer_name FROM customers WHERE UPPER(customer_name) LIKE 'MA*';"},
    {"label": "G", "text": "SELECT customer_name FROM customers WHERE customer_name = '*Ma*';"}
  ],
  "CorrectAnswer": ["B", "E"],
  "Explanation": ""
},
{
  "QuestionID": 245,
  "QuestionType": "single",
  "QuestionText": "Choose the best answer.\nYou need to allow user ANDREW to:\n1. Modify the TITLE and ADDRESS columns of your CUSTOMERS table.\n2. GRANT that permission to other users.\nWhich statement will do this?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "GRANT UPDATE ON customers.title, customers.address TO andrew;"},
    {"label": "B", "text": "GRANT UPDATE (title, address) ON customers TO andrew WITH GRANT OPTION;"},
    {"label": "C", "text": "GRANT UPDATE ON customers.title, customers.address TO andrew WITH ADMIN OPTION;"},
    {"label": "D", "text": "GRANT UPDATE ON customers.title, customers.address TO andrew WITH GRANT OPTION;"},
    {"label": "E", "text": "GRANT UPDATE (title, address) ON customers TO andrew;"},
    {"label": "F", "text": "GRANT UPDATE (title, address) ON customers TO andrew WITH ADMIN OPTION;"}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "对象权限允许授权只能用WITH GRANT OPTION）系统权限允许授权可用with admin option"
},
{
  "QuestionID": 246,
  "QuestionType": "single",
  "QuestionText": "Choose the best answer.\nWhich statement is true about TRUNCATE and DELETE?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "You can never TRUNCATE a table if foreign key constraints would be violated."},
    {"label": "B", "text": "You can DELETE rows from a table with referential integrity constraints."},
    {"label": "C", "text": "For tables with multiple indexes and triggers, DELETE is faster than TRUNCATE."},
    {"label": "D", "text": "For large tables, DELETE is faster than TRUNCATE."}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "A.如果该表是被其他表通过外键 “引用”的（即它是parent表），而这些外键约束是启用状态的，那么不能直接TRUNCATE。你必须先禁用(或者删除)那些引用该表的外键约束，或者使用TRUNCATE … CASCADE,并且那些外键必须支持ON DELETE CASCADE才行。\nB.DELETE 可以删除有外键约束的表中的数据，只要删除不会违反referential integrity（参照完整性），就可以。\nCD.DELETE 会逐行删除，大表操作很慢；TRUNCATE直接释放数据块，非常快"
},
{
  "QuestionID": 247,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about constraints?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "All constraints can be defined at the table or column level."},
    {"label": "B", "text": "A constraint can be disabled even if the constrained column contains data."},
    {"label": "C", "text": "A column with a FOREIGN KEY constraint can never contain a NULL value."},
    {"label": "D", "text": "A column with a UNIQUE constraint can contain a NULL value."},
    {"label": "E", "text": "Constraints are enforced only during INSERT operations."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "A.Not Null仅仅能定义在列级别\nC.外键列是允许 NULL 的，表示该行没有关联到 parent 表的任何记录\nD.UNIQUE约束允许列中存在NULL，并且多个NULL被视为不同值，所以不会违反唯一性\nE.约束不仅在INSERT时检查，也在UPDATE 时检查，甚至可能在DELETE时触发（如外键约束）"
},
{
  "QuestionID": 248,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about privileges?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "All schema objects have associated object privileges."},
    {"label": "B", "text": "Schema owners can grant any object privilege on any object in their schema to any other user or role."},
    {"label": "C", "text": "A combination of object and system privileges can be granted to a role."},
    {"label": "D", "text": "Object privileges granted on a table automatically apply to all synonyms for that table."},
    {"label": "E", "text": "Only users with the GRANT ANY PRIVILEGE privilege can grant and revoke system privileges from other users."},
    {"label": "F", "text": "Only users with the DBA role can create roles."}
  ],
  "CorrectAnswer": ["A", "B", "D"],
  "Explanation": "C.角色（role） 可以被授予 对象权限 或 系统权限，但不能同时授予系统权限和对象权限的组合（必须分别授予）\nE.并非只有拥有 GRANT ANY PRIVILEGE 的用户才能授予系统权限；拥有某个系统权限的用户，如果带有 WITH ADMIN OPTION，也可以授予该权限给其他用户\nF.创建角色（CREATE ROLE）需要CREATE ROLE系统权限，并非必须是DBA角色"
},
{
  "QuestionID": 249,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about dropping views?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Read only views cannot be dropped."},
    {"label": "B", "text": "Views referencing a dropped view become invalid."},
    {"label": "C", "text": "CASCADE CONSTRAINTS must be specified when referential integrity constraints on other objects refer to primary or unique keys in the view to be dropped."},
    {"label": "D", "text": "Data selected by a view's defining query is deleted from its underlying tables when the view is dropped."},
    {"label": "E", "text": "The creator of a view to be dropped must have the DROP ANY VIEW privilege."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "A.只读视图read-only view可以正常被DROP\nE.视图的创建者自己可以直接DROP VIEW view_name;，不需要DROP ANY VIEW权限。DROP ANY VIEW是为了删除别人的视图"
},
{
  "QuestionID": 250,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true?",
  "ImageURL": "images/q250.png",
  "Options": [
    {"label": "A", "text": "The MGR column in the DEPT table will not be able to contain NULL values."},
    {"label": "B", "text": "Both foreign key constraint definitions must be removed from the CREATE TABLE statements, and be added with ALTER TABLE statements once both tables are created, for the two CREATE TABLE statements to execute successfully in the order shown."},
    {"label": "C", "text": "The CREATE TABLE EMP statement must precede the CREATE TABLE DEPT statement for all three statements to execute successfully."},
    {"label": "D", "text": "The DEPTNO column in the EMP table will be able to contain NULL values."},
    {"label": "E", "text": "All three statements execute successfully in the order shown."},
    {"label": "F", "text": "The DEPT_FKEY constraint definition must be removed from the CREATE TABLE DEPT statement, and be added with an ALTER TABLE statement once both tables are created, for the two CREATE TABLE statements to execute successfully in the order shown."}
  ],
  "CorrectAnswer": ["D", "F"],
  "Explanation": "这里有两个约束涉及外键:\n1.EMP.DEPTNO 外键指向 DEPT.DEPTNO\n2.DEPT.MGR 外键指向 EMP.EMPNO\n这就是所谓的 循环依赖（circular reference），也叫双向外键。\nA.外键列默认可以包含 NULL（除非显式加 NOT NULL）\nB.第一步创建DEPT时，Oracle会检查外键DEPT_FKEY，它引用EMP.EMPNO。但是EMP还没创建，所以这个外键会报错,不完全需要去掉两个外键; DEPT.MGR外键必须延后用ALTER TABLE添加，因为它引用的 EMP 还不存在。另一个外键可以正常创建;EMP.DEPTNO外键引用 DEPT，DEPT已经创建，可以直接在CREATE TABLE 时定义\n"
},
{
  "QuestionID": 251,
  "QuestionType": "single",
  "QuestionText": "Choose the best answer.\nTable HR.EMPLOYEES contains a row where the EMPLOYEE_ID is 109.\nUser ALICE has no privileges to access HR.EMPLOYEES.\nUser ALICE starts a session.\nUser HR starts a session and successfully executes these statements:\nGRANT DELETE ON employees TO alice;\nUPDATE employees SET salary = 24000 WHERE employee_id = 109;\nIn her existing session ALICE then executes:\nDELETE FROM hr.employees WHERE employee_id = 109;\nWhat is the result?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The DELETE command will immediately delete the row."},
    {"label": "B", "text": "The DELETE command will immediately return an error."},
    {"label": "C", "text": "The DELETE command will wait for HR's transaction to end then delete the row."},
    {"label": "D", "text": "The DELETE command will wait for HR's transaction to end then return an error."}
  ],
  "CorrectAnswer": ["C"],
  "Explanation": "Hr 用户修改了行数据，改行就被锁住了，其它事务只有等待"
},
{
  "QuestionID": 252,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements about roles are true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Roles are assigned to roles using the ALTER ROLE statement."},
    {"label": "B", "text": "A role is a named group of related privileges that can only be assigned to a user."},
    {"label": "C", "text": "A single role can be assigned to multiple users."},
    {"label": "D", "text": "A single user can be assigned multiple roles."},
    {"label": "E", "text": "Privileges are assigned to a role using the ALTER ROLE statement."},
    {"label": "F", "text": "Privileges are assigned to a role using the GRANT statement."},
    {"label": "G", "text": "Roles are assigned to users using the ALTER USER statement."}
  ],
  "CorrectAnswer": ["C", "D", "F"],
  "Explanation": "A.角色不能赋给角色，角色只能赋给用户。ALTER ROLE 用于修改角色属性（比如密码、默认角色），不能用来分配角色。分配角色:GRANT role_name TO user_name [WITH ADMIN OPTION];\nB.角色确实是一组权限的集合，但是它不仅可以分配给用户，还可以分配给 其他角色;在Oracle 12c+中支持角色继承\nC.角色的权限是通过 GRANT 语句分配的;GRANT CREATE TABLE, CREATE VIEW TO READ_ONLY;"
},
{
  "QuestionID": 253,
  "QuestionType": "multiple",
  "QuestionText": "Which three actions can you perform only with system privileges?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Access flat files via a database, which are stored in an operating system directory."},
    {"label": "B", "text": "Execute a procedure in another schema."},
    {"label": "C", "text": "Log in to a database instance."},
    {"label": "D", "text": "Create stored procedures, functions and packages."},
    {"label": "E", "text": "Use the WITH GRANT OPTION clause."},
    {"label": "F", "text": "Query any table in a database."}
  ],
  "CorrectAnswer": ["C", "D", "F"],
  "Explanation": "系统权：登录数据库、建表/存储过程、跨库查询、WITH ADMIN OPTION → 需要系统权限\n对象权：操作自己表、执行自己/别人存储过程、WITH GRANT OPTION → 对象权限足够\n\nA.Oracle中访问文件需要CREATE DIRECTORY 权限以及 READ/WRITE 权限，属于对象权限/目录权限，不是标准系统权限\nB.执行其他 schema 的存储过程需要 对象权限（EXECUTE ON schema.proc），不是系统权限\nE.WITH GRANT OPTION 是 对象权限 的扩展，用于授予权限给其他用户，不属于系统权限"
},
{
  "QuestionID": 254,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about an Oracle database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A NUMBER column without data has a zero value."},
    {"label": "B", "text": "A table can have multiple foreign keys."},
    {"label": "C", "text": "A VARCHAR2 column without data has a NULL value."},
    {"label": "D", "text": "A table can have multiple primary keys."},
    {"label": "E", "text": "A column definition can specify multiple data types."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": ""
},
{
  "QuestionID": 255,
  "QuestionType": "single",
  "QuestionText": "Which statement satisfies all the requirements?",
  "ImageURL": "images/q255.png",
  "Options": [
    {"label": "A", "text": "SELECT last_name, hire_date, \n(CASE WHEN (SYSDATE - TO_YMINTERVAL('15-0')) >= hire_date THEN '15+ years of service' \nWHEN (SYSDATE - TO_YMINTERVAL('10-0')) >= hire_date THEN '10+ years of service' \nWHEN (SYSDATE - TO_YMINTERVAL('5-0')) >= hire_date THEN '5+ years of service' \nELSE '<5 years of service' \nEND) AS years \nFROM employees \nORDER BY hire_date;"},
    {"label": "B", "text": "SELECT last_name, hire_date, \n(CASE WHEN (SYSDATE - hire_date) >= TO_YMINTERVAL('5-0') THEN '5+ years of service' \nWHEN (SYSDATE - hire_date) >= TO_YMINTERVAL('10-0') THEN '10+ years of service' \nWHEN (SYSDATE - hire_date) >= TO_YMINTERVAL('15-0') THEN '15+ years of service' \nELSE '<5 years of service' \nEND) AS years \nFROM employees \nORDER BY hire_date;"},
    {"label": "C", "text": "SELECT last_name, hire_date, \n(CASE WHEN (SYSDATE - TO_YMINTERVAL('5-0')) >= hire_date THEN '5+ years of service' \nWHEN (SYSDATE - TO_YMINTERVAL('10-0')) >= hire_date THEN '10+ years of service' \nWHEN (SYSDATE - TO_YMINTERVAL('15-0')) >= hire_date THEN '15+ years of service' \nELSE '<5 years of service' \nEND) AS years \nFROM employees \nORDER BY hire_date;"},
    {"label": "D", "text": "SELECT last_name, hire_date, \n(CASE WHEN (SYSDATE - hire_date) >= TO_YMINTERVAL('15-0') THEN '15+ years of service' \nWHEN (SYSDATE - hire_date) >= TO_YMINTERVAL('10-0') THEN '10+ years of service' \nWHEN (SYSDATE - hire_date) >= TO_YMINTERVAL('5-0') THEN '5+ years of service' \nELSE '<5 years of service' \nEND) AS years \nFROM employees \nORDER BY hire_date;"}
  ],
  "CorrectAnswer": ["A"],
  "Explanation": "TO_YMINTERVAL 是 Oracle SQL 的一个函数，用于 将字符串或数字转换为 INTERVAL YEAR TO MONTH 类型，即表示“年-月”间隔的数据类型\nBD.(SYSDATE - hire_date) >= TO_YMINTERVAL('15-0');SYSDATE - hire_date 返回的是 天数（NUMBER 类型）;TO_YMINTERVAL('15-0') 是 INTERVAL YEAR TO MONTH 类型"
},
{
  "QuestionID": 256,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about external tables?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "They can be used in queries containing joins."},
    {"label": "B", "text": "Their metadata is stored in the database."},
    {"label": "C", "text": "They can be temporary tables."},
    {"label": "D", "text": "They can be indexed."},
    {"label": "E", "text": "They can be used in queries containing sorts."},
    {"label": "F", "text": "DML statements can modify them."}
  ],
  "CorrectAnswer": ["A", "B", "E"],
  "Explanation": "A.外部表External Tables本质上是 Oracle 数据库中的表定义，只不过数据存储在操作系统的外部文件里（如 CSV、文本文件）。可以像普通表一样在 SELECT 查询中做JOIN\nB.外部表的表结构（列名、数据类型等）存储在数据库的数据字典中，而数据本身在外部文件\nC.外部表 不支持 TEMPORARY，不能像GLOBAL TEMPORARY TABLE那样只在会话或事务内存在\nD.外部表不能创建索引，因为数据不在数据库内部，Oracle 无法直接维护索引\nF.外部表只读，不支持INSERT、UPDATE 或 DELETE"
},
{
  "QuestionID": 257,
  "QuestionType": "multiple",
  "QuestionText": "Which two will execute successfully?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "SELECT NVL('DATE', SYSDATE) FROM DUAL;"},
    {"label": "B", "text": "SELECT COALESCE('DATE', SYSDATE) FROM DUAL;"},
    {"label": "C", "text": "SELECT COALESCE('DATE', SYSDATE) FROM (SELECT NULL AS \"DATE\" FROM DUAL);"},
    {"label": "D", "text": "SELECT COALESCE(0, SYSDATE) FROM DUAL;"},
    {"label": "E", "text": "SELECT NVL('DATE', 200) FROM (SELECT NULL AS \"DATE\" FROM DUAL);"}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": "NVL要求两个参数的数据类型必须一致，或者第二个参数可以被隐式转换为第一个参数的类型;COALESCE两个参数的数据类型必须一致"
},
{
  "QuestionID": 258,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the data dictionary?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The data dictionary does not store metadata in tables."},
    {"label": "B", "text": "The data dictionary is accessible when the database is closed."},
    {"label": "C", "text": "Views with the prefix ALL_, DBA_ and USER_ are not all available for every type of metadata."},
    {"label": "D", "text": "Views with the prefix ALL_ display metadata for objects to which the current user has access."},  
    {"label": "E", "text": "Views with the prefix DBA_ display only metadata for objects in the SYS schema."}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": "A.Oracle的数据字典元数据是存储在系统表中的。只是访问方式通常通过视图，而不是直接操作这些表\nB.数据字典是数据库的一部分，当数据库 关闭时，无法访问\nC.并非所有元数据类型都有三种视图（USER_ / ALL_ / DBA_）。\nD.ALL_ 视图显示:当前用户拥有的对象;以及当前用户被授权访问的对象\nE.DBA_ 视图显示整个数据库中所有用户的对象，不仅仅是SYS。但前提是你必须拥有SELECT ANY DICTIONARY或DBA权限"
},
{
  "QuestionID": 259,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about external tables that use the ORACLE_DATAPUMP access driver?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "When creating an external table, data can be selected only from a table whose rows are stored in database blocks."},
    {"label": "B", "text": "Creating an external table creates a directory object."},
    {"label": "C", "text": "When creating an external table, data can be selected from another external table or from a table whose rows are stored in database blocks."},
    {"label": "D", "text": "Creating an external table creates a dump file that can be used only by an external table in the same database."},
    {"label": "E", "text": "Creating an external table creates a dump file that can be used by an external table in the same or a different database."}
  ],
  "CorrectAnswer": ["C", "E"],
  "Explanation": "B.创建外部表必须提前创建目录,不会自动创建目录\nD.Oracle 明确表示不仅可用于同一个数据库，还 可以用于 不同数据库。也就是说：可以跨数据库使用这些 dump 文件"
},
{
  "QuestionID": 260,
  "QuestionType": "single",
  "QuestionText": "Which will execute successfully?",
  "ImageURL": "images/q260.png",
  "Options": [
    {"label": "A", "text": "1 only"},
    {"label": "B", "text": "1, 2 and 3"},
    {"label": "C", "text": "2, 3 and 4"},
    {"label": "D", "text": "2 and 3 only"}
  ],
  "CorrectAnswer": ["D"],
  "Explanation": "CREATE ANY TABLE 可建他人表，表属他人手中拿；建者无权插删查，OWNER 才能任意花。\n4.CREATE SYNONYM 需要 CREATE SYNONYM 权限。SCOTT 只有 CREATE TABLE，没有 CREATE SYNONYM"
},
{
  "QuestionID": 261,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about using constraints?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "PRIMARY KEY and FOREIGN KEY constraints can be specified at the column and at the table level."},
    {"label": "B", "text": "A table can have multiple PRIMARY KEY and multiple FOREIGN KEY constraints."},
    {"label": "C", "text": "A table can have only one PRIMARY KEY but may have multiple FOREIGN KEY constraints."},
    {"label": "D", "text": "NOT NULL can be specified at the column and at the table level."},
    {"label": "E", "text": "A FOREIGN KEY column in a child table and the referenced PRIMARY KEY column in the parent table must have the same names."},
    {"label": "F", "text": "A table can have only one PRIMARY KEY and one FOREIGN KEY constraint."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": ""
},
{
  "QuestionID": 262,
  "QuestionType": "multiple",
  "QuestionText": "Which two queries can be used?",
  "ImageURL": "images/q262.png",
  "Options": [
    {"label": "A", "text": "SELECT book_title \nFROM books WHERE (price < 500 OR price > 1000) \nAND (purchase_date < '17-JAN-2007') \nORDER BY purchase_date DESC;"},
    {"label": "B", "text": "SELECT book_title \nFROM books WHERE (price < 500 OR > 1000) \nAND (purchase_date < '17-JAN-2007') \nORDER BY purchase_date DESC;"},
    {"label": "C", "text": "SELECT book_title \nFROM books WHERE (price IN (500, 1000)) \nAND (purchase_date < '17-JAN-2007') \nORDER BY purchase_date ASC;"},
    {"label": "D", "text": "SELECT book_title \nFROM books WHERE (price NOT BETWEEN 500 \nAND 1000) AND (purchase_date < '17-JAN-2007') \nORDER BY purchase_date DESC;"},
    {"label": "E", "text": "SELECT book_title \nFROM books WHERE (price BETWEEN 500 AND 1000) \nAND (purchase_date < '17-JAN-2007') \nORDER BY purchase_date;"}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": ""
},
{
  "QuestionID": 263,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true regarding indexes?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "When a table is dropped and is moved to the RECYCLE BIN, all indexes built on that table are permanently dropped."},
    {"label": "B", "text": "A UNIQUE index can be altered to be non-unique."},
    {"label": "C", "text": "An update to a table can result in updates to any or all of the table's indexes."},
    {"label": "D", "text": "An update to a table can result in no updates to any of the table's indexes."},
    {"label": "E", "text": "A table belonging to one user cannot have an index that belongs to a different user."}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": ""
},
{
  "QuestionID": 264,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "CONCAT joins two or more character strings together."},
    {"label": "B", "text": "FLOOR returns the largest integer less than or equal to a specified number."},
    {"label": "C", "text": "CONCAT joins two character strings together."},
    {"label": "D", "text": "INSTR finds the offset within a character string, starting from position 0."},
    {"label": "E", "text": "FLOOR returns the largest positive integer less than or equal to a specified number."},
    {"label": "F", "text": "INSTR finds the offset within a string of a single character only."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": ""
},
{
  "QuestionID": 265,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements will list only the employees who have been working with the company for more than five years?",
  "ImageURL": "images/q265.png",
  "Options": [
    {"label": "A", "text": "SELECT employee_name FROM employees WHERE (CURRENT_DATE - hire_date)/12 > 5;"},
    {"label": "B", "text": "SELECT employee_name FROM employees WHERE (SYSDATE - hire_date) / 12 > 5;"},
    {"label": "C", "text": "SELECT employee_name FROM employees WHERE (SYSDATE - hire_date) / 365 > 5;"},
    {"label": "D", "text": "SELECT employee_name FROM employees WHERE (SYSTIMESTAMP - hire_date) / 365 > INTERVAL '1825' DAY;"},
    {"label": "E", "text": "SELECT employee_name FROM employees WHERE (SYSTIMESTAMP - hire_date) / 12 > INTERVAL '5' YEAR;"},
    {"label": "F", "text": "SELECT employee_name FROM employees WHERE (CURRENT_DATE - hire_date)/365 > 5;"}
  ],
  "CorrectAnswer": ["C", "F"],
  "Explanation": ""
},
{
  "QuestionID": 266,
  "QuestionType": "single",
  "QuestionText": "Which statement will compute the total annual compensation for each employee?",
  "ImageURL": "images/q266.png",
  "Options": [
    {"label": "A", "text": "SELECT last_name, (monthly_salary * 12) + (monthly_salary * 12 * NVL(monthly_commission_pct, 0)) AS annual_comp FROM employees;"},
    {"label": "B", "text": "SELECT last_name, (monthly_salary + monthly_commission_pct) * 12 AS annual_comp FROM employees;"},
    {"label": "C", "text": "SELECT last_name, (monthly_salary * 12) + (monthly_salary * 12 * monthly_commission_pct) AS annual_comp FROM employees;"},
    {"label": "D", "text": "SELECT last_name, (monthly_salary * 12) + (monthly_commission_pct * 12) AS annual_comp FROM employees;"}
  ],
  "CorrectAnswer": ["A"],
  "Explanation": ""
},
{
  "QuestionID": 267,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about queries using set operators (UNION, UNION ALL, INTERSECT and MINUS)?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "None of the set operators can be used when selecting CLOB columns."},
    {"label": "B", "text": "The FOR UPDATE clause cannot be specified."},
    {"label": "C", "text": "The name of each column in the first SELECT list must match the name of the corresponding column in each subsequent SELECT list."},
    {"label": "D", "text": "Each SELECT statement in the query can have an ORDER BY clause."},
    {"label": "E", "text": "There must be an equal number of columns in each SELECT list."}
  ],
  "CorrectAnswer": ["B", "E"],
  "Explanation": "A.UNION、INTERSECT、MINUS 确实 不支持 CLOB / BLOB 列 的比较。UNION ALL 可以用\nB.在使用 UNION / UNION ALL / INTERSECT / MINUS 时，不能使用FOR UPDATE。FOR UPDATE 只用于单个 SELECT 来锁定行，而集合操作符返回的是组合后的结果集，不允许加FOR UPDATE\nC.列名不要求完全相同。Oracle只要求列的数据类型可兼容,并且数量相等。返回结果的列名,默认使用第一个 SELECT的列名\nD."
},
{
  "QuestionID": 268,
  "QuestionType": "multiple",
  "QuestionText": "Which two join conditions in a FROM clause are non-equijoins?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "table1 JOIN table2 ON (table1.column BETWEEN table2.column1 AND table2.column2)"},
    {"label": "B", "text": "table1 JOIN table2 ON (table1.column = table2.column) WHERE table2.column LIKE 'A%'"},
    {"label": "C", "text": "table1 NATURAL JOIN table2"},
    {"label": "D", "text": "table1 JOIN table2 ON (table1.column >= table2.column)"},
    {"label": "E", "text": "table1 JOIN table2 USING (column1, column2)"}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": "C.NATURAL JOIN 默认基于相同列做等值连接\nE.USING 是等值连接的简写"
},
{
  "QuestionID": 269,
  "QuestionType": "multiple",
  "QuestionText": "Which two queries return the highest salary in the table?",
  "ImageURL": "images/q269.png",
  "Options": [
    {"label": "A", "text": "SELECT MAX(salary) \nFROM employees \nGROUP BY department_id;"},
    {"label": "B", "text": "SELECT MAX(salary) \nFROM employees;"},
    {"label": "C", "text": "SELECT MAX(salary) \nFROM employees \nGROUP BY department_id HAVING MAX(salary) = MAX(MAX(salary));"},
    {"label": "D", "text": "SELECT department_id, MAX(salary) \nFROM employees \nGROUP BY department_id;"},
    {"label": "E", "text": "SELECT MAX(MAX(salary)) \nFROM employees \nGROUP BY department_id;"}
  ],
  "CorrectAnswer": ["B", "E"],
  "Explanation": "C.Oracle 不允许在同一级别的 HAVING 里嵌套 MAX(MAX(...))\n"
},
{
  "QuestionID": 270,
  "QuestionType": "single",
  "QuestionText": "Which statement is true about using functions in WHERE and HAVING?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Using aggregate functions in the HAVING clause requires a subquery."},
    {"label": "B", "text": "Using single-row functions in the WHERE clause requires a subquery."},
    {"label": "C", "text": "Using single-row functions in the HAVING clause requires a subquery."},
    {"label": "D", "text": "Using aggregate functions in the WHERE clause requires a subquery."}
  ],
  "CorrectAnswer": ["D"],
  "Explanation": "WHERE 先行，不能聚合；HAVING 分组，聚合随意。"
},
{
  "QuestionID": 271,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true?",
  "ImageURL": "images/q271.png",
  "Options": [
    {"label": "A", "text": "It skips only tables that exist in both ORCL:SH and TESTDB:HR."},
    {"label": "B", "text": "It drops and re-creates tables that exist in both ORCL:SH and TESTDB:HR."},
    {"label": "C", "text": "It skips only indexes that exist in both ORCL:SH and TESTDB:HR."},
    {"label": "D", "text": "It drops and re-creates indexes that exist in both ORCL:SH and TESTDB:HR."},
    {"label": "E", "text": "It skips all indexes of ORCL:SH and ORCL:OE."}
  ],
  "CorrectAnswer": ["B", "E"],
  "Explanation": "SCHEMAS=sh,oe →导入 sh 和 oe 两个模式\nREMAP_SCHEMA=sh:hr→将源模式 sh 的对象导入到目标模式 hr"
},
{
  "QuestionID": 272,
  "QuestionType": "multiple",
  "QuestionText": "TBS1 is a permanent user-defined tablespace. \nOracle Managed Files (OMF) is not used in this database. \nExamine this command: \n\nDROP TABLESPACE tbs1; \n\nWhich two will ensure that TBS1 is dropped and its datafiles are deleted from the file system?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "TBS1 must not contain any temp files."},
    {"label": "B", "text": "TBS1 must be altered READ ONLY."},
    {"label": "C", "text": "There must be no uncommitted transactions involving segments stored in TBS1."},
    {"label": "D", "text": "TBS1 must be READ WRITE."},
    {"label": "E", "text": "The INCLUDING CONTENTS AND DATAFILES clause must be added to the command."}
  ],
  "CorrectAnswer": ["C", "E"],
  "Explanation": "TBS1是永久用户定义表空间;与临时表空间不同,永久表空间存储数据段（表、索引等）\nC.DROP TABLESPACE 会删除表空间中的段，如果有 未提交事务 占用表空间，会报错。确保没有活跃事务，才能成功删除表空间及其数据段\nE.INCLUDING CONTENTS → 删除表空间内的对象（表、索引等）INCLUDING DATAFILES → 同时删除文件系统上的数据文件（非 OMF 时必需）"
},
{
  "QuestionID": 273,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about a dedicated server configuration?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A dedicated server process can be spawned without a listener when using local clients."},
    {"label": "B", "text": "A dedicated server process may be reused by a new session after the session using that process terminates."},
    {"label": "C", "text": "Each dedicated server process has its own dispatcher process."},
    {"label": "D", "text": "A dedicated server process can be spawned by the listener when using local clients."},
    {"label": "E", "text": "A dedicated server process communicates directly with a client or middle tier process once the session is established."},
    {"label": "F", "text": "The DBA configures the maximum number of dedicated server processes that can share the same dispatcher process."}
  ],
  "CorrectAnswer": ["A", "D", "E"],
  "Explanation": "A.本地连接（bequeath connection） 不需要 Listener，Oracle 可以直接在操作系统上创建专用服务器进程\nB.专用服务器进程:专用于当前会话，会话结束后，进程也终止或等待，但不会被新的会话重用（这是共享服务器的特点）\nC.Dispatcher 仅在 共享服务器（Shared Server） 中使用，专用服务器配置不需要 dispatcher"
},
{
  "QuestionID": 274,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about time zones, date data types, and timestamp data types in an Oracle database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The DATE datatype returns data with time zone information."},
    {"label": "B", "text": "A TIMESTAMP WITH LOCAL TIME ZONE data type column is stored in the database using the time zone of the session that inserted the row."},
    {"label": "C", "text": "The CURRENT_TIMESTAMP function returns data without time zone information."},
    {"label": "D", "text": "The DBTIMEZONE function can return an offset from Universal Coordinated Time (UTC)."},
    {"label": "E", "text": "The SESSIONTIMEZONE function can return an offset from Universal Coordinated Time (UTC)."}
  ],
  "CorrectAnswer": ["B", "E"],
  "Explanation": "D.如果数据库时区设置为区域名称，DBTIMEZONE返回的不是偏移量，而是名称。 这意味着在某些配置下，它无法返回偏移量。"
},
{
  "QuestionID": 275,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about UNDO and UNDO tablespaces?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "An instance will crash if the active undo tablespace is lost."},
    {"label": "B", "text": "UNDO segments are owned by SYSTEM."},
    {"label": "C", "text": "There can be only one UNDO tablespace created in a database."},
    {"label": "D", "text": "An UNDO tablespace may be owned by only one instance."},
    {"label": "E", "text": "UNDO segments are owned by SYSBACKUP."}
  ],
  "CorrectAnswer": ["D"],
  "Explanation": "A.如果 active undo tablespace 突然丢失，实例不会立即 crash，但会报错事务失败或 ORA-01555 等\nB.SYS\nC.一个数据库可以创建多个 undo tablespace，但每个实例一次只能使用一个\nD.在RAC 环境中，每个 undo tablespace不能被多个实例共享\nE.UNDO segments 属于 SYSBACKUP 或 SYS 用户"
},
{
  "QuestionID": 276,
  "QuestionType": "multiple",
  "QuestionText": "Which two actions can you perform using DBCA for an existing database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Create nonstandard block size tablespaces."},
    {"label": "B", "text": "Create a template that can be used to clone the database."},
    {"label": "C", "text": "Change the server mode from dedicated to shared, and vice versa."},
    {"label": "D", "text": "Change the character set."},
    {"label": "E", "text": "Create an additional listener."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "DBCA（Database Configuration Assistant）可以 创建新数据库 或 管理已有数据库\n对已有数据库，主要功能包括:\n--配置数据库选项\n--创建模板用于克隆/复制数据库\n--改变服务器模式（Dedicated ↔ Shared）\n--创建/管理监听器（部分受限）\n--配置初始化参数、表空间等\nE.DBCA可以创建监听器，但通常只在创建新数据库时使用,对已有数据库，添加监听器通常用 NETCA（Network Configuration Assistant） 或手动编辑 listener.ora"
},
{
  "QuestionID": 277,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true?",
  "ImageURL": "images/q277.png",
  "Options": [
    {"label": "A", "text": "The first ROLLBACK command leaves the table's 100 original rows locked."},
    {"label": "B", "text": "The second ROLLBACK command restores the 100 rows that were in the table originally."},
    {"label": "C", "text": "The second ROLLBACK command restores the row that was inserted."},
    {"label": "D", "text": "The first ROLLBACK command leaves the inserted row locked."},
    {"label": "E", "text": "The first ROLLBACK command restores the row that was inserted."},
    {"label": "F", "text": "The first ROLLBACK command restores the 100 rows that were in the table originally."},
    {"label": "G", "text": "The second ROLLBACK command rolls back the ROLLBACK TO SAVEPOINT command."}
  ],
  "CorrectAnswer": ["B", "D", "E"],
  "Explanation": ""
},
{
  "QuestionID": 278,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about Enterprise Manager (EM) Express?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "You can use a single instance of EM Express to manage multiple databases running on the same server."},
    {"label": "B", "text": "You can shut down a database instance using EM Express."},
    {"label": "C", "text": "By default, EM Express is available for a database after database creation using DBCA."},
    {"label": "D", "text": "You cannot start up a database instance using EM Express."},
    {"label": "E", "text": "EM Express uses a separate repository database to store target database metadata."}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": "EM Express 是轻量级的 Web 管理工具，用于管理单个 Oracle 数据库实例，EM Express本身建立在数据库内部，必须在数据库开着的状态下:\n--直接访问单实例数据库，无需单独安装管理数据库\n--不依赖管理仓库（不同于 EM Cloud Control）;EM Express 直接使用目标数据库本身存储元数据\n--可以监控性能、查看参数、管理用户\n--默认情况下 DBCA(Database Configuration Assistant)创建数据库时会启用EM Express"
},
{
  "QuestionID": 279,
  "QuestionType": "multiple",
  "QuestionText": "While one of your databases was in mount state, the datafiles were renamed because they had been moved to a new file system. The database was then opened. Which two statements are true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "V$DATAFILE displays the new names for the data files."},
    {"label": "B", "text": "DBA_DATA_FILES displays the original name for the data files."},
    {"label": "C", "text": "DBA_DATA_FILES must be resynchronized manually with the control file in order to have it display the new file names."},
    {"label": "D", "text": "DBA_DATA_FILES displays the new name for the data files."},
    {"label": "E", "text": "DBA_DATA_FILES displays both the new name and the old name for the data files."}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": "数据文件改名字，数据字典和动态性能视图会自动更新。"
},
{
  "QuestionID": 280,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about data block storage in an Oracle Database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "An index block can contain row data."},
    {"label": "B", "text": "A table block must always contain row data."},
    {"label": "C", "text": "Row data is stored starting at the end of the block."},
    {"label": "D", "text": "A block header contains a row directory pointing to all rows in the block."},
    {"label": "E", "text": "A data block header is of a fixed length."}
  ],
  "CorrectAnswer": ["A", "C", "D"],
  "Explanation": "A.因为索引块可以包含 键值 + ROWID，ROWID 指向表行，但不存完整行数据;注意：B-tree 索引不存整行，但某些特定索引（如 index-organized table, IOT）索引块确实存储行数据\nB.还有空闲的\nE.数据块头长度 不完全固定，取决于块类型和一些特性（如表、索引、LOB）只有标准块头是 最小固定长度，实际可扩展"
},
{
  "QuestionID": 281,
  "QuestionType": "single",
  "QuestionText": "As the DBA, you execute this command: \n\nGRANT CREATE VIEW TO usr1 WITH ADMIN OPTION; \n\nUSR1 then executes this command: \nGRANT CREATE VIEW TO usr2 WITH ADMIN OPTION; \n\nUSR2 then executes this command: \nGRANT CREATE VIEW TO usr3; \n\nWhich statement is true?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "USR1 can revoke the CREATE VIEW privilege from USR3."},
    {"label": "B", "text": "The DBA can revoke only ADMIN OPTION from USR1."},
    {"label": "C", "text": "When the DBA revokes the CREATE VIEW privilege from USR1, it is revoked from USR2 but not USR3."},
    {"label": "D", "text": "When the DBA revokes the CREATE VIEW privilege from USR1, it is neither revoked from USR2 nor USR3."},
    {"label": "E", "text": "When the DBA revokes the CREATE VIEW privilege from USR1, it is revoked from USR2 and USR3."},
    {"label": "F", "text": "When USR1 revokes the CREATE VIEW privilege from USR2, it is revoked from USR3."}
  ],
  "CorrectAnswer": ["D"],
  "Explanation": "WITH ADMIN OPTION用户可以将自己拥有的系统权限或角色再授予其他用户;授权者可以用 GRANT ... WITH ADMIN OPTION 给别人授予权限;不自动级联撤销\nB.DBA可以撤销整个权限，不只是 ADMIN OPTION\nWITH GRANT OPTION：用于对象权限；级联撤销。"
},
{
  "QuestionID": 282,
  "QuestionType": "single",
  "QuestionText": "Which query is valid?",
  "ImageURL": "images/q282.png",
  "Options": [
    {"label": "A", "text": "SELECT prod_id, release_date, SUM(cost) FROM products GROUP BY prod_id, release_date;"},
    {"label": "B", "text": "SELECT prod_id, release_date, SUM(cost) FROM products GROUP BY prod_id;"},
    {"label": "C", "text": "SELECT prod_id, AVG (MAX (cost)) FROM products GROUP BY prod_id;"},
    {"label": "D", "text": "SELECT prod_id, MAX (AVG(cost)) FROM products GROUP BY prod_id;"}
  ],
  "CorrectAnswer": ["A"],
  "Explanation": "非聚合的列必须全部出现在 GROUP BY 中"
},
{
  "QuestionID": 283,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true regarding the UNION and UNION ALL operators?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Duplicates are eliminated automatically by the UNION ALL operator."},
    {"label": "B", "text": "The names of columns selected in each SELECT statement can be identical."},
    {"label": "C", "text": "NULLS are not ignored during duplicate checking."},
    {"label": "D", "text": "The number of columns selected in each SELECT statement must be identical."},
    {"label": "E", "text": "Duplicates can optionally be eliminated by the UNION operator."},
    {"label": "F", "text": "The names of columns selected in each SELECT statement must be identical."},
    {"label": "G", "text": "The number of columns selected by the first SELECT statement can be greater than the number selected in subsequent SELECT statements."}
  ],
  "CorrectAnswer": ["B", "C", "D"],
  "Explanation": ""
},
{
  "QuestionID": 284,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the job?",
  "ImageURL": "images/q284.png",
  "Options": [
    {"label": "A", "text": "You can reattach to it and monitor it."},
    {"label": "B", "text": "You can reattach to it but not monitor it."},
    {"label": "C", "text": "It is paused and can be resumed."},
    {"label": "D", "text": "It continues to run in the background."},
    {"label": "E", "text": "It terminates."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": ""
},
{
  "QuestionID": 285,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about space-saving features in an Oracle Database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "An index that is altered to be UNUSABLE will retain its segment."},
    {"label": "B", "text": "Private Temporary Tables (PTTs) when used, are always dropped at the next COMMIT statement."},
    {"label": "C", "text": "A table that is truncated will always have all of its extents removed."},
    {"label": "D", "text": "Private Temporary Tables (PTTs) store metadata in memory only."},
    {"label": "E", "text": "An index created with the UNUSABLE attribute has no segment."}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "A.当索引被标记为 UNUSABLE 时，其段（segment）被释放或根本未分配\nB.PTTs 有两种生命周期类型：1.ON COMMIT DROP DEFINITION → 表定义在事务提交时消失2.ON COMMIT PRESERVE DEFINITION → 表定义在会话结束时消失\nC.TRUNCATE是快速清空数据,如果你想移除 全部 extents，需要使用 DROP ALL STORAGE 子句\nD.PTT 的metadata（表定义）存储在 SGA 的内存中，不占用数据文件中的永久空间"
},
{
  "QuestionID": 286,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about single row functions?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "MOD : returns the remainder of a division operation."},
    {"label": "B", "text": "FLOOR : returns the smallest integer greater than or equal to a specified number."},
    {"label": "C", "text": "CEIL : can be used for positive and negative numbers."},
    {"label": "D", "text": "TRUNC : can be used only with NUMBER data types."},
    {"label": "E", "text": "CONCAT : can be used to combine any number of values."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": ""
},
{
  "QuestionID": 287,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about an SPFILE?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It can be used to create a pfile."},
    {"label": "B", "text": "It can be created by sys from an idle instance."},
    {"label": "C", "text": "It must exist for a database instance to start."},
    {"label": "D", "text": "It contains initialization parameters whose values can be changed using the ALTER SYSTEM command."},
    {"label": "E", "text": "It contains only static initialization parameters."}
  ],
  "CorrectAnswer": ["A", "B", "D"],
  "Explanation": "A.CREATE PFILE='init.ora' FROM SPFILE;\nC.数据库 可以使用文本PFILE启动实例，不一定非要SPFILE"
},
{
  "QuestionID": 288,
  "QuestionType": "multiple",
  "QuestionText": "An Oracle database server session has an uncommitted transaction in progress which updated 5000 rows in a table. In which three situations does the transaction complete thereby committing the updates?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "when the session logs out successfully"},
    {"label": "B", "text": "when a DBA issues a successful SHUTDOWN IMMEDIATE statement and the user then issues a COMMIT"},
    {"label": "C", "text": "when a DBA issues a successful SHUTDOWN TRANSACTIONAL statement and the user then issues a COMMIT"},
    {"label": "D", "text": "when a CREATE INDEX statement is executed successfully in the same session"},
    {"label": "E", "text": "when a COMMIT statement is issued by the same user from another session in the same database instance"},
    {"label": "F", "text": "when a CREATE TABLE AS SELECT statement is executed unsuccessfully in the same session"}
  ],
  "CorrectAnswer": ["A", "C", "D"],
  "Explanation": "A.当用户会话正常退出时，如果有未提交的事务，Oracle会自动提交或回滚\nB.SHUTDOWN IMMEDIATE 会 强制回滚所有未提交事务，并终止会话。\nC.SHUTDOWN TRANSACTIONAL会等待所有活动事务完成后再关闭数据库\nD.所有DDL操作在Oracle中都是自动提交（implicit commit）：之前的未提交事务会先提交;当前DDL也会提交\nE.事务是会话级别的，其他会话的COMMIT不影响当前事务\nF.对失败的DDL会自动回滚DDL本身，但是不会影响之前的DML事务。因此未提交的5000行更新仍然未提交。"
},
{
  "QuestionID": 289,
  "QuestionType": "single",
  "QuestionText": "The STORES table has a column START_DATE of data type DATE, containing the date the row was inserted. You only want to display details of rows where START_DATE is within the last 25 months. Which WHERE clause can be used?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "WHERE MONTHS_BETWEEN(start_date, SYSDATE)<=25"},
    {"label": "B", "text": "WHERE TO_NUMBER(start_date-SYSDATE)<=25"},
    {"label": "C", "text": "WHERE ADD_MONTHS(start_date,25)<=SYSDATE"},
    {"label": "D", "text": "WHERE MONTHS_BETWEEN(SYSDATE,start_date)<=25"}
  ],
  "CorrectAnswer": ["D"],
  "Explanation": "MONTHS_BETWEEN 函数要把当前的时间写在前面，以前的写在后面，否则计算后会出现负数"
},
{
  "QuestionID": 290,
  "QuestionType": "multiple",
  "QuestionText": "In which three situations does the transaction complete thereby committing the updates?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "when a DBA issues a successful SHUTDOWN TRANSACTIONAL statement and the user then issues a COMMIT."},
    {"label": "B", "text": "When a CREATE TABLE AS SELECT statement is issued in the same session but fails with a syntax error."},
    {"label": "C", "text": "When a DBA issues a successful SHUTDOWN IMMEDIATE statement and the user then issues a COMMIT."},
    {"label": "D", "text": "When a CREATE INDEX statement is executed successfully in the same session."},
    {"label": "E", "text": "When the session logs out successfully."},
    {"label": "F", "text": "When a COMMIT statement is issued by the same user from another session in the same database instance."}
  ],
  "CorrectAnswer": ["A", "D", "E"],
  "Explanation": ""
},
{
  "QuestionID": 291,
  "QuestionType": "multiple",
  "QuestionText": "Which two statements are true about the ORDER BY clause?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "numeric values are displayed in descending order if they have decimal positions."},
    {"label": "B", "text": "Only columns that are specified in the SELECT list can be used in the ORDER BY clause."},
    {"label": "C", "text": "Column aliases can be used in the ORDER BY clause."},
    {"label": "D", "text": "NULLS are not included in the sort operation."},
    {"label": "E", "text": "In a character sort, the values are case-sensitive."}
  ],
  "CorrectAnswer": ["C", "E"],
  "Explanation": "默认情况下，NULL 会被认为最大值;显式控制 NULL 排序位置的关键字:NULLS FIRST:NULL 排在最前面;NULLS LAST: NULL 排在最后面"
},
{
  "QuestionID": 292,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about Data Manipulation Language (DML)?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "INSERT INTO...SELECT...FROM statements automatically commit."},
    {"label": "B", "text": "DELETE statements can remove multiple rows based on multiple conditions."},
    {"label": "C", "text": "UPDATE statements can have different subqueries to specify the values for each updated column."},
    {"label": "D", "text": "DML statements require a primary key be defined on a table."},
    {"label": "E", "text": "INSERT statements can insert NULLS explicitly into a column."}
  ],
  "CorrectAnswer": ["B", "C", "E"],
  "Explanation": "DDL建改删表清数据;DML增删改合"
},
{
  "QuestionID": 293,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about creating pluggable databases (PDBs) in Oracle 19c and later releases?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A snapshot copy PDB can be a full copy of a source PDB."},
    {"label": "B", "text": "A PDB snapshot depends on an existing storage snapshot of the source PDB."},
    {"label": "C", "text": "A snapshot copy PDB does not depend on an existing storage snapshot of the source PDB."},
    {"label": "D", "text": "A PDB snapshot can be a full copy of a source PDB."},
    {"label": "E", "text": "A PDB snapshot can be a sparse copy of a source PDB."}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "创建 PDB 有几种方法:\n1.Full Clone完整克隆:\n--创建一个完全独立的 PDB 副本\n--占用完整存储空间\n--克隆完成后，源 PDB 与克隆 PDB 完全独立\n2.Snapshot Clone / Sparse Clone快照/稀疏副本快照\n--副本依赖于源 PDB 的数据\n--占用空间少,只存储更改部分Copy-on-Write\n--如果源 PDB 删除或不可用，快照副本可能受影响\n\nPDB Snapshot是PDB的一个只读副本，通过快照克隆Snapshot Clone创建;强调“快照本身”;\nSnapshot Copy PDB可更新快照;可读写; 强调“快照克隆的副本”"
},
{
  "QuestionID": 294,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about indexes and their administration in an Oracle database?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A descending index is a type of function-based index."},
    {"label": "B", "text": "A unique and non-unique index can be created on the same table column."},
    {"label": "C", "text": "An INVISIBLE index is not maintained when Data Manipulation Language (DML) is performed on its underlying table."},
    {"label": "D", "text": "If a query filters on an indexed column then it will always be used during execution of the query."},
    {"label": "E", "text": "An index can be created as part of a CREATE TABLE statement."},
    {"label": "F", "text": "A DROP INDEX statement always prevents updates to the table during the drop operation."}
  ],
  "CorrectAnswer": ["A", "E", "F"],
  "Explanation": "A.Oracle 支持DESCENDING索引，它可以按降序排序数据。Oracle 将降序索引看作是一种函数式索引，因为它通过隐式函数对列进行排序。\nB.同一列可以有多个索引，但唯一索引和非唯一索引不可以同时存在在同一列上\nF. DROP INDEX时，会对索引结构加锁，防止表上的DML改变该索引; DROP INDEX ONLINE;允许删除索引时进行更新"
},
{
  "QuestionID": 295,
  "QuestionType": "multiple",
  "QuestionText": "Which three tasks are performed by background processes in an Oracle database instance?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Creating dedicated server connections"},
    {"label": "B", "text": "Reading database blocks into the buffer cache"},
    {"label": "C", "text": "Registering services with Oracle Net listeners."},
    {"label": "D", "text": "Writing dirty database block images from the buffer cache."},
    {"label": "E", "text": "Writing redo to log files."}
  ],
  "CorrectAnswer": ["C", "D", "E"],
  "Explanation": "Oracle 数据库的后台进程负责各种 数据库维护任务和系统管理工作，主要包括:\n--1.DBWR（Database Writer）将修改过的脏数据块dirty blocks(脏块 = 内存中已修改但磁盘尚未更新的数据块)从缓冲区写回磁盘\n--2.LGWR（Log Writer）将重做日志（redo log）缓冲区的内容写入磁盘\n--3.SMON（System Monitor）系统恢复，清理临时段和PMON(Process Monitor)清理失败的用户进程;注销服务注册服务到 Oracle Net listener 属于PMON的功能\n--4.CKPT检查点:本身不写数据块，它负责通知和标记，DBWR负责实际写数据块"
},
{
  "QuestionID": 296,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about roles?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Object privileges may not be granted to roles."},
    {"label": "B", "text": "Roles must be password protected."},
    {"label": "C", "text": "The SET ROLE statement can disable one or more roles for a session."},
    {"label": "D", "text": "All roles granted to a user are set on by default when the user logs in."},
    {"label": "E", "text": "The SET ROLE statement can enable one or more roles for a session."},
    {"label": "F", "text": "Roles may be granted to roles."}
  ],
  "CorrectAnswer": ["C", "E", "F"],
  "Explanation": "A.角色就是用来管理权限的工具;可以将 表、视图、序列等对象的权限授予角色，再把角色授予用户\nCE.SET ROLE NONE --禁用所有角色; SET ROLE role1 EXCEPT role2 --启用role1但禁用role2; SET ROLE role1, role2 --启用role1和role2\nD.只有通过 ALTER USER ... DEFAULT ROLE 定义的默认角色会在登录时自动启用\nF.角色嵌套（Role Hierarchy）可以将一个角色授予另一个角色，这样用户获得角色A，也能继承角色B的权限"
},
{
  "QuestionID": 297,
  "QuestionType": "multiple",
  "QuestionText": "Which three statements are true about performing Data Manipulation Language (DML) operations on a view with no INSTEAD OF triggers defined?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Views cannot be used to add or modify rows in an underlying table if the defining query of the view contains the DISTINCT keyword."},
    {"label": "B", "text": "Delete statements can always be done on a table through a view."},
    {"label": "C", "text": "Insert statements can always be done on a table through a view."},
    {"label": "D", "text": "Views cannot be used to query rows from an underlying table if the table has a PRIMARY KEY and the PRIMARY KEY columns are not referenced in the defining query of the view."},
    {"label": "E", "text": "Views cannot be used to add rows to an underlying table if the table has columns with NOT NULL constraints lacking default values which are not referenced in the defining query of the view."},
    {"label": "F", "text": "The WITH CHECK clause has no effect when deleting rows from the underlying table through the view."}
  ],
  "CorrectAnswer": ["A", "E", "F"],
  "Explanation": "视图就像一个“虚拟表” — 它本身不存储数据，只保存一个 SELECT 查询。当你对视图做查询时，数据库后台其实执行那个 SELECT，得到结果。\n注意点:1.必须有 CREATE VIEW 权限.\n2.基础表base tables或被引用的视图必须存在,且你有必要的 SELECT 权限\n3.可选的 OR REPLACE、FORCE、NOFORCE等子句，用以替换已有视图或在基础对象不存在时仍创建视图\n一般来说，用户执行 SELECT、INSERT、UPDATE、DELETE 操作视图也需要基础对象相应的权限。\n删除视图:使用 DROP VIEW 来删除\n可更新视图（Inherently updatable view）支持DML（INSERT / UPDATE / DELETE）:每个视图中的列都必须映射到单一表的一列;--视图定义不能包含 DISTINCT、 GROUP BY、 ORDER BY、集合表达式（collection expression in SELECT）等;--如果视图中有伪列（如 ROWID、ROWNUM）或表达式，则不能更新那些列对应的基础表行;--如果基础表有 NOT NULL约束且视图中未包含这些列，那么通过视图INSERT可能失败;--OIN 多表的视图通常也是不可更新，或者只能更新部分基础表\n如果在创建视图时加入WITH CHECK OPTION，那么通过视图的 INSERT/UPDATE 操作必须使结果仍然满足视图定义的 WHERE条件\n\nDefining query = 创建视图时的SELECT查询"
}



    ]
    },
    {
      "SubjectID": 2,
      "SubjectName": "OCP19C083",
      "questions": [
        {
  "QuestionID": 1,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about thresholds, metrics, and server-generated alerts? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "All metrics are instance related."},
    {"label": "B", "text": "Cleared stateful alerts are displayed by querying DBA_ALERT_HISTORY."},
    {"label": "C", "text": "A space usage management alert is automatically cleared after the underlying problem is resolved."},
    {"label": "D", "text": "They are generated by SMON when a tablespace is 97% full."},
    {"label": "E", "text": "Metrics are statistical counts for a specific unit."},
    {"label": "F", "text": "STATISTICS_LEVEL must be set to ALL to generate alerts"}
  ],
  "CorrectAnswer": ["B", "C", "E"],
  "Explanation": "1.Metrics指标:Oracle 会自动收集一些数据库的统计数据（例如 CPU 使用率、表空间使用率等）。这些数据叫做 metrics。\n2. Thresholds阈值:你可以设定某个指标达到什么程度时触发警报。例如:表空间使用超过85% → warning alert;表空间使用超过 97% → critical alert\n3.Server-generated alerts（服务器自动产生的警报）Oracle 自动根据 metric + threshold 触发警报，例如:表空间满了;归档空间快满了;Undo tablespace 有问题\n这些由 Oracle 后台自动产生，不是 SMON 产生的。\n**A.不是所有 metrics 都是 instance-level。\n例如:CPU usage是Instance-level;Tablespace space usage是Tablespace-level;Segment size是Object-level\n**B.stateful alert有状态警报的特点是:条件满足 → 产生警报;条件消失 → 警报自动清除\n例如:表空间使用率超过 97% → 触发 alert;后来减到 50% → alert 自动清除;历史记录（包括清除过的）会保存在:DBA_ALERT_HISTORY\n**C.Oracle 的空间类的alert是stateful alert\n**D.Oracle 有自己的 MMON(Manageability Monitor Process)负责监控和触发server-generated alerts\n**E.Metrics = Oracle 定期收集的一些统计值;如:每秒物理读次数;表空间使用率;事务数;CPU时间"
},
{
  "QuestionID": 2,
  "QuestionType": "multiple",
  "QuestionText": "While backing up to an SBT channel, you determine that the read phase of your compressed RMAN incremental level 0 backup is a bottleneck. FORCE LOGGING is enabled for the database. Which two could improve read performance? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Increase the size of tape I/O buffers."},
    {"label": "B", "text": "Disable FORCE LOGGING for the database."},
    {"label": "C", "text": "Increase the size of the database buffer cache."},
    {"label": "D", "text": "Enable asynchronous disk I/O."},
    {"label": "E", "text": "Increase the level of RMAN multiplexing."}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "RMAN(Recovery Manager)备份流程:\n1.读阶段:RMAN从数据文件data files读取块;这个阶段RMAN必须从所有datafile中把数据库的实际数据块读出来\n--RMAN会做两件事:(1)读取数据块direct path read:使用 direct path I/O(绕过 buffer cache直接把数据从磁盘读到用户程序);使用 OS I/O(同步/异步取决于系统);(2)过滤无用块（空块）如果是incremental backup,还会比较SCN(System Change Number系统改变号)\n--2.写阶段：写入到SBT（磁带/第三方备份软件\n\nA.tape buffer 是写阶段优化\nB.FORCE LOGGING 是控制 redo 的，不影响 RMAN 备份速度\nC.RMAN 使用 direct path read，不会读 buffer cache 内容，也不会把数据放进去。所以增加 buffer cache 完全无意义\nD.异步 I/O（AIO）;RMAN 可以一次发起多个I/O\nE.RMAN 可以一次读取多个文件的块，然后混合写入backup piece。默认情况下RMAN可能一次只从1～2个文件读取。如果你把multiplexing开高，例如:FILES PER SET 16;那么RMAN会同时从16个datafile读取"
},
{
  "QuestionID": 3,
  "QuestionType": "multiple",
  "QuestionText": "For which two requirements can you use the USER_TABLESPACE clause with the CREATE PLUGGABLE DATABASE command? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "to specify a default tablespace in a PDB cloned from another PDB in the same CDB."},
    {"label": "B", "text": "to exclude all tablespaces except SYSTEM, SYSAUX, and TEMP when plugging in a PDB"},
    {"label": "C", "text": "to include specific user tablespaces only when relocating a PDB"},
    {"label": "D", "text": "to specify the list of user tablespaces to include when moving a non-CDB to a PDB"},
    {"label": "E", "text": "to exclude a temp tablespace when plugging in a PDB"},
    {"label": "F", "text": "to specify the list of tablespaces to include when creating a PDB from the CDB seed"}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "USER_TABLESPACE 允许你在创建 PDB 或者将 PDB plug into CDB 时,指定只包含哪些用户表空间user tablespaces,USER_TABLESPACE 只影响 用户创建的表空间,而不是系统表空间\n\nA.DEFAULT TABLESPACE 是另一种参数，用来指定 PDB 默认表空间;USER_TABLESPACE 不用来指定 默认表空间，而是 选择包含哪些表空间\nB.如果你在 plug in 一个 PDB 时，只想要系统表空间(不包含用户表空间):USER_TABLESPACE NONE\nC.Relocating PDB（移动 PDB）时不使用 USER_TABLESPACE;Relocate 主要处理数据文件路径改变,不能通过 USER_TABLESPACE 选择表空间\nD.如果你要做 non-CDB → PDB(即把传统数据库迁移到多租户架构)，可以通过 USER_TABLESPACE 指定要包含哪些表空间;例如只迁移重要表空间，忽略一些测试表空间\nE.TEMP 是系统表空间，不能排除\nF.CDB seed 是模板 PDB，里面只有系统表空间;新 PDB 基于 seed 创建时，没有用户表空间可选择"
},
{
  "QuestionID": 4,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about requirements for various FLASHBACK operations? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "FLASHBACK transaction query requires undo to retrieve all versions of a row that existed between two points in time."},
    {"label": "B", "text": "FLASHBACK drop requires that the RECYCLEBIN parameter be set to ON."},
    {"label": "C", "text": "FLASHBACK version query requires that the RECYCLEBIN parameter be set to ON."},
    {"label": "D", "text": "FLASHBACK DATA ARCHIVE requires undo to store all versions of all rows of a table being tracked."},
    {"label": "E", "text": "FLASHBACK drop requires undo to retrieve all versions of a row that existed between two points in time."},
    {"label": "F", "text": "FLASHBACK version query requires undo to retrieve all versions of a row that existed between two points in time."}
  ],
  "CorrectAnswer": ["A", "B", "F"],
  "Explanation": "A.FLASHBACK TRANSACTION QUERY 用于查看两个时间点之间存在的事务对表的修改历史;它通过 undo 信息（undo tablespace）来恢复过去的行版本;Undo 必须存在才能查到过去版本\nB.FLASHBACK DROP = 恢复误删表;Oracle 使用 Recycle Bin（回收站）保存被 DROP 的表;RECYCLEBIN=ON 时，DROP 的表会进入回收站;如果 RECYCLEBIN=OFF，FLASHBACK DROP 不能工作\nC.FLASHBACK VERSION QUERY 用于查看两个时间点之间某个表行在一段时间内的所有版本;它依赖 undo 表空间;与 Recycle Bin 无关\nD.Flashback Data Archive (Total Recall) 是一种长期行历史存储;它不使用 undo，而是存储在Flashback Data Archive表空间;Undo 只用于短期回滚/Flashback Query\nE.FLASHBACK DROP 恢复的是整个表，通过Recycle Bin恢复不依赖undo;undo 用于 FLASHBACK QUERY 或 VERSION QUERY"
},
{
  "QuestionID": 5,
  "QuestionType": "multiple",
  "QuestionText": "Which three actions are performed by the Oracle Preinstallation RPM, oracle-database-server-xxxx-preinstall, for Oracle Grid Infrastructure, where xxxx is the Oracle version and release? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "performing checks to ensure minimum configuration requirements for Oracle Grid Infrastructure are met"},
    {"label": "B", "text": "creating the oracle OS user"},
    {"label": "C", "text": "creating the OSDBA (dba) group"},
    {"label": "D", "text": "creating the oraInventory (oinstall) group"},
    {"label": "E", "text": "creating the grid OS user"},
    {"label": "F", "text": "configuring the OS for Oracle Automatic Storage Management shared storage access"}
  ],
  "CorrectAnswer": ["B", "C", "D"],
  "Explanation": "安装Oracle数据库或者Oracle Grid Infrastructure，Oracle官方提供了预安装RPM（Preinstallation RPM）作用是自动完成数据库安装前必须做的一些系统配置，避免手动设置繁琐的系统参数,oracle-database-server-preinstall:\n--1.Preinstall 会自动创建:oraInventory (oinstall) group,用于管理 Oracle安装目录和软件所有权; 创建 dba 组,这个组用于管理数据库实例和数据文件权限; RPM 会创建默认数据库用户oracle,并设置 home 目录 /home/oracle,这个用户用于运行 Oracle Database 实例\n2.--自动配置 Linux 内核参数sysctl,例如:shmmax、shmall共享内存;sem信号量;panic_on_oops;file-max最大文件数\n--3.自动配置 ulimits资源限制:最大打开文件数 nofile;最大进程数 nproc;core 文件大小;stack 大小\n--4.自动配置 Oracle 目录权限,置正确的权限和属主，让 oracle 用户能够安装数据库软件\n\nOracle Grid Infrastructure（简称 GI）是 Oracle提供的一套基础架构软件，用于支持高可用性High Availability和集群环境。可以把GI理解为数据库高可用性和集群环境的底座，没有它，RAC 或 ASM 就无法运行功能:\n--集群管理\n--Oracle RAC（Real Application Clusters）支持\n--ASM（Automatic Storage Management）管理\n--备份与恢复基础组件\n\n oracle-grid-infrastructure-preinstall为 Grid Infrastructure（GI） 环境准备:\n--1.创建 grid 用户（而不是 oracle）\n--2.创建 asmadmin、asmdba、asmoper 等ASM组\n--3.配置共享存储权限\n--4.配置集群通讯参数\n--5.配置 GI 所需的更高内核限制\n它是用于:ASM + Clusterware + RAC 环境;可以用于 Oracle Restart（单节点 ASM + 自动重启）\n\nDatabase-preinstall = 给“单实例数据库”准备环境（oracle 用户）\nGI-preinstall = 给“集群/ASM/RAC”准备环境（grid 用户）"
},
{
  "QuestionID": 6,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about common objects? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "They can be created only in CDB$ROOT."},
    {"label": "B", "text": "They can be only metadata-linked in an application container."},
    {"label": "C", "text": "They can exist in user-defined schemas only in application containers."},
    {"label": "D", "text": "They can exist in CDB$ROOT and an application root."},
    {"label": "E", "text": "They can be extended data-linked in CDB$ROOT."},
    {"label": "F", "text": "They can be created only in an application root."}
  ],
  "CorrectAnswer": ["D", "F"],
  "Explanation": "common objects指的是在“根容器”级别定义、并可在其下属容器中以某种共享方式可见或可用的数据库对象。在CDB$ROOT中的common objects:通常是 Oracle自带的系统级common objects(例如某些系统视图、系统用户等)，它们在整个CDB中具有“通用”作用\n在 application root（应用根） 中的 application common objects（应用通用对象）：这是在 应用容器 概念下，专门为一个应用及其下属 application PDB 共享而创建的通用对象（由用户/应用创建）。这些对象通过SHARING属性决定如何在application PDBs中共享\n当你在 application root 创建一个表/对象时，可以用 SHARING 子句来指定共享行为（这决定对象的元数据和/或数据如何被 application PDB 访问）:\n--1.METADATA（metadata-linked）:只共享对象的结构/元数据（比如表结构、列定义、索引等）;每个 application PDB 有自己独立的数据（每个 PDB 存自己的行）;适合“结构统一但数据独立”的场景(例如：每个租户有同样表结构但数据隔离)\n--2.DATA（data-linked）:对象的结构和数据都存放在 application root，且对所有 application PDB 可见并共享同一份数据;适合“全局只读或统一数据源”的场景（例如：公司产品目录、标准代码表）。\n3.EXTENDED DATA（extended data-linked）:混合模式：在 application root 中有一份主数据（对所有 PDB 通用），但每个 application PDB 可以另存一份属于自己的数据（或覆盖/补充）;适合需要“共享主数据但允许每个 PDB额外局部数据”的复杂场景。\n--4.NONE（不共享）\n\nA.CDB$ROOT 中common objects是 Oracle 提供的数据库内置（system-supplied）common objects;用户不能在CDB$ROOT随意创建application-style common objects;用户创建的 application common objects 必须在 application root\nC.有些common objects在CDB$ROOT（由 Oracle 提供），而application common objects则位于 application root 并共享给所属的 application PDBs\nE.EXTENDED DATA（扩展数据链接）是 application common object 的一种共享模式\nF.“用户创建的 common objects”（也就是 application common objects）的创建位置：必须在 application root 中创建"
},
{
  "QuestionID": 7,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about the Automatic Database Diagnostic Monitor (ADDM)? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It analyzes a period of time corresponding to the 12 hours of activity."},
    {"label": "B", "text": "It runs automatically after each AWR snapshot."},
    {"label": "C", "text": "A DBA can run it manually."},
    {"label": "D", "text": "Results are written to the alert log."},
    {"label": "E", "text": "It analyzes a period of time corresponding to the last day of activity."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "ASH(Active Session History)实时性能监控,每1秒抽样一次活动session,只抽样 active session，所以非常轻量,只保留在内存V$ACTIVE_SESSION_HISTORY\nAWR(Automatic Workload Repository)是 “数据库历史性能库”,每小时自动采集快照snapshot,数据被存入DBA_HIST*视图里,保存默认 8 天\nADDM(Automatic Database Diagnostic Monitor)是 “自动数据库医生”,依据 AWR snapshots自动分析性能问题,每次 AWR snapshot 后 自动运行,也可以手动运行\n\nA.E.ADDM 分析的时段 不是固定12小时或1天，它分析的是两个 AWR snapshots 之间的时间。默认 AWR 间隔1小时（但 DBA 可改 AWR 间隔）\nD.ADDM 的分析结果保存在 AWR，并可在 EM 查看或通过查询获得"
},
{
  "QuestionID": 8,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about server-generated alerts? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Stateful alerts must be created by a DBA after resolving the problem."},
    {"label": "B", "text": "Stateless alerts can be purged manually from the alert history."},
    {"label": "C", "text": "Stateless alerts can be cleared manually."},
    {"label": "D", "text": "Stateless alerts are automatically cleared."},
    {"label": "E", "text": "Stateful alerts are purged automatically from the alert history."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "Oracle 的 server-generated alerts服务器生成的警报分成两类:① Stateful alerts:磁盘空间不足;表空间使用率超过阈值;归档空间不足etc;它们在 问题解决后自动清除clear\n② Stateless alerts:通常是一次性的事件，比如:ORA-错误;死锁;快速闪回区空间不足事件,不能自动“清除clear”，因为没有持续性状态,它们只保存在 alert history 中作为记录\n\nA.Stateful alerts 是 Oracle 自动产生的\nB.无论是 stateful 还是 stateless,DBA都可以手动purge清除历史记录\nC.stateless alert 本质上不能“自动 clear”，因为它们没有状态,但 DBA 可以用 DBMS_SERVER_ALERT.CLEAR_ALERT 手动清除 stateless alert"
},
{
  "QuestionID": 9,
  "QuestionType": "multiple",
  "QuestionText": "Which three are located by using environment variables? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "the Optimal Flexible Architecture (OFA) compliant path to store Oracle software and configuration files."},
    {"label": "B", "text": "the location of Oracle Net Services configuration files"},
    {"label": "C", "text": "the list of a disk group names to be mounted by an Oracle Automatic Storage Management (ASM) instance at startup"},
    {"label": "D", "text": "default directories for temporary files used by temporary tablespaces"},
    {"label": "E", "text": "the temporary disk space used by Oracle Installer during installation"},
    {"label": "F", "text": "the maximum number of database files that can be opened by a database instance"}
  ],
  "CorrectAnswer": ["A", "B", "E"],
  "Explanation": "Oracle 环境变量Environment Variables常见用途:\n--1.ORACLE_BASE / ORACLE_HOME / ORACLE_SID定义 Oracle 软件和数据库实例位置,是 OFA（Optimal Flexible Architecture）目录结构的核心\n--2.TNS_ADMIN指定 Oracle Net Services 配置文件（如 tnsnames.ora、listener.ora、sqlnet.ora）的位置\n--3.ORACLE_TMP 或 TEMP/ TMP系统临时目录,安装 Oracle 或运行工具时，临时文件存放路径\n\nC.ASM 启动挂载的 disk group 列表是在 init.ora 或 spfile 中设置,不是通过操作系统环境变量\nD.临时表空间的文件位置由 表空间定义（CREATE TEMPORARY TABLESPACE …）和数据库参数 DB_CREATE_FILE_DEST决定,虽然可以参考系统目录，但不是通过环境变量指定\nE.安装过程中 Oracle Installer需要临时空间,使用操作系统 TMP/TEMP 或 ORACLE_TMP 环境变量来指定临时目录\nF.由数据库参数DB_FILES 控制,与操作系统环境变量无关\n\n1.环境变量主要控制路径（软件路径、配置文件、临时目录）\n2.数据库参数控制行为（文件数、磁盘组、表空间位置）"
},
{
  "QuestionID": 10,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about opatchauto? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It performs a shutdown and then a restart of all processes in both Oracle Grid Infrastructure and Oracle Database home during the patching process."},
    {"label": "B", "text": "It must be invoked by a user with root user privileges."},
    {"label": "C", "text": "Patches are applied via opatchauto."},
    {"label": "D", "text": "Users must always input patch plans to opatchauto."},
    {"label": "E", "text": "It requires the Oracle Grid Infrastructure and Oracle Database instances to be shut down before being invoked."},
    {"label": "F", "text": "It applies patches in nonrolling mode by default."},
    {"label": "G", "text": "It is used to apply interim patches to Oracle Grid Infrastructure and Oracle Database home combinations"}
  ],
  "CorrectAnswer": ["A", "B", "G"],
  "Explanation": "opatchauto 是 OPatch 的高级自动化工具，用来自动修补 GI（Grid Infrastructure）+ DB homes，尤其在 RAC 环境中非常常见,它可以自动处理:\n1.停库／启库\n2.依赖关系\n3.自动执行 patch plan（有些 patch 会内置 plan）\n4.GI + DB 一起 patch\nB.opatchauto 必须用 root 用户运行\nC.不是所有补丁都能用 opatchauto。只有某些 GI + DB combo patch 或特定 PSU/Release Update 才能用 opatchauto\nD.大部分 GI patch 都自带 patch plan，用户无需提供任何 plan\nE.不用提前关，opatchauto会自动处理 shutdown / startup\nF.默认是 rolling（如果补丁支持 rolling）。只有不支持 rolling 的补丁才会变成 nonrolling\nG.opatchauto 除了 PSU/Release Update 也能应用 combination patches，例如：GI + DB 一起的 combo patch;GI interim patch + DB interim patch 的组合"
},
{
  "QuestionID": 11,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about the character sets used in an Oracle database? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Single-byte character sets provide better performance than multibyte character sets."},
    {"label": "B", "text": "Unicode enables information from any language to be stored using a single character set."},
    {"label": "C", "text": "Unicode is the only supported character set for Oracle databases created using Database Configuration Assistant (DBCA)."},
    {"label": "D", "text": "Single-byte character sets always use 7-bit encoding schemes."},
    {"label": "E", "text": "Multibyte character sets allow more efficient space utilization than single byte character sets."},
    {"label": "F", "text": "Single-byte character sets always use 8-bit encoding schemes."}
  ],
  "CorrectAnswer": ["A", "B"],
  "Explanation": "单字节字符集（比如 WE8MSWIN1252）每个字符占 1 byte;\n多字节字符集（比如 UTF8/AL32UTF8）每个字符占 1–4 bytes\nA.单字节字符集在：字符处理,比较,排序,存储、检索方面的开销都更小,所以性能通常更好\nB.Unicode（在 Oracle 中主要用 AL32UTF8）是一种可以表示世界上几乎所有语言字符的编码\nC.DBCA创建数据库时可以选择：单字节字符集（WE8ISO8859P1）;多字节字符集（UTF8、ZHS16GBK 等）;Unicode（AL32UTF8）;Unicode不是唯一选项\nD.F.7-bit是像ASCII那样的编码。但许多Oracle单字节字符集是 8-bit(256字符)\nE.多字节字符集（UTF8）通常占：英文：1 byte;亚洲文字：3 bytes;Emoji：4 bytes空间利用率通常比单字节更差"
},
{
  "QuestionID": 12,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about monitoring waits for sessions and services? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "V$SESSION_EVENT displays all waits for all past and existing sessions if the wait has occurred at least once for a session."},
    {"label": "B", "text": "V$SERVICE_EVENT displays all waits for all services if the wait has occurred at least once for a service."},
    {"label": "C", "text": "V$SESSION_WAIT_CLASS displays waits broken down by wait class only for waiting sessions."},
    {"label": "D", "text": "V$SESSION_WAIT and V$SESSION both contain details of the event on which a non-waiting session last waited."},
    {"label": "E", "text": "V$SESSION_EVENT displays all waits for all past sessions if the wait has occurred at least once for a session."},
    {"label": "F", "text": "V$SESSION_WAIT and V$SESSION both contain details of the event on which a session is currently waiting."}
  ],
  "CorrectAnswer": ["B", "D", "F"],
  "Explanation": "V$SESSION_WAIT→ 只显示当前 正在等待 或 刚刚结束一次等待 的信息(实时)\nV$SESSION_EVENT→ 历史统计; 会累积每个 session 的所有发生过的等待事件（直到 session 结束）\nV$SERVICE_EVENT按 service 汇总等待事件\nV$SESSION_WAIT_CLASS→ 按 wait class 对 session 的累计等待情况做统计\n\nA.E.V$SESSION_EVENT 只显示：当前 session;存活的 session;不会显示已经结束的 session\nB.V$SERVICE_EVENT：是 service 层级的等待历史统计;如果某个 service 下 任何 session 产生过某个 wait event，它就会显示\nC.V$SESSION_WAIT_CLASS按会话显示在各种等待事件操作中花费的时间\nD.F.V$SESSION_WAIT 显示每个会话的当前或最后一次等待;V$SESSION 如果会话当前正在等待，则显示该会话正在等待的资源或事件。如果会话未处于等待状态，则显示该会话最近一次等待的资源或事件"
},
{
  "QuestionID": 13,
  "QuestionType": "multiple",
  "QuestionText": "You must transport the UNIVERSITY tablespace from one database to another. The UNIVERSITY tablespace is currently open read/write. The source and destination platforms have different endian formats. Examine this list of actions:\n(1). Make the UNIVERSITY tablespace read-only on the source system.\n(2). Export the UNIVERSITY tablespace metadata using EXPDP.\n(3). Convert the UNIVERSITY tablespace data files to the destination platform format using RMAN on the source system.\n(4). Copy the UNIVERSITY tablespace data files to the destination system.\n(5). Copy the Data Pump dump set to the destination system.\n(6). Convert the UNIVERSITY tablespace data files to the destination platform format using RMAN on the destination system.\n(7). Import the UNIVERSITY tablespace metadata using IMPDP.\n(8). Make the UNIVERSITY tablespace read/write on the destination system.\n\nWhich is the minimum number of actions required, in the correct order, to transport the UNIVERSITY tablespace? (Choose one.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "1, 2, 4, 5, 7, 8"},
    {"label": "B", "text": "1, 2, 4, 6, 7, 8"},
    {"label": "C", "text": "1, 2, 3, 4, 5, 7, 8"},
    {"label": "D", "text": "1, 2, 3, 4, 5, 6, 7, 8"},
    {"label": "E", "text": "2, 4, 5, 6, 7"}
  ],
  "CorrectAnswer": ["C"],
  "Explanation": "你要 transport（跨数据库搬运）一个 tablespace;当前 tablespace 是 open read/write;源和目标平台 endian 字节序不同,这意味着：\n--1.必须先把 tablespace 置为只读\n--2数据文件必须做 endian 转换（RMAN支持跨平台转换）\n--3.元数据需要通过 Data Pump 导出导入\n\n(3)和(6)选一个,数据文件搬运前或搬运后做转换\n\n实际步骤:1.准备源表空间,只读 防止源数据库修改\n2.导出元数据\n3.RMAN 转换数据文件 endian\n4.拷贝数据文件,搬到目标服务器\n5.将包含元数据的EXPDP 导出的文件dump set传输到目标系统\n7.Data Pump 导入工具（IMPDP）在目标数据库中导入元数据\n8.将表空间设置为 读写 模式，使其在目标数据库中完全可用"
},
{
  "QuestionID": 14,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about OS groups and users for Oracle Grid Infrastructure and the Oracle Relational Database Management System (RDBMS)? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "By default, members of the OSASM group can access Automatic Storage Management and RDBMS instances."},
    {"label": "B", "text": "The primary group for the Oracle Grid Infrastructure and Oracle Database owners must be the Oracle Inventory group."},
    {"label": "C", "text": "The Oracle Grid Infrastructure installation must be owned by the grid user."},
    {"label": "D", "text": "The Oracle Grid Infrastructure owner owns Oracle Restart and Oracle Automatic Storage Management binaries."},
    {"label": "E", "text": "The Oracle Grid Infrastructure owner must have OSOPER, OSBACKUPDBA, and OSKMDBA as secondary groups."},
    {"label": "F", "text": "The same OSDBA group must be used for Automatic Storage Management and the Oracle Database."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "A.OSASM 组（通常为 asmadmin）的成员拥有 SYSASM 权限，用于管理 Oracle ASM 实例。他们不默认拥有访问 RDBMS 实例的 SYSDBA 权限。访问 RDBMS 实例的 SYSDBA 权限通常由 OSDBA 组（通常为 dba）的成员拥有\nB.Oracle 软件安装要求一个 Oracle Inventory 组（通常为 oinstall），这个组必须是所有 Oracle 软件安装所有者（例如 grid 用户和 oracle 用户）的primary group。这确保了所有 Oracle 软件安装所有者都具有对中央清单 (oraInventory) 目录的写入权限。\nC.最佳实践是使用一个专门的 grid 用户作为 Oracle Grid Infrastructure 的所有者，但这不是一个强制性的“必须”。您也可以选择使用 oracle 用户来拥有 Grid Infrastructure 和 Database（称为 Standard Administration 或最小权限分离）。但在 Job Role Separation 配置中，推荐使用 grid 用户。\nD.在分离用户（Job Role Separation）的配置中，Grid Infrastructure 所有者（通常为 grid 用户）负责安装和拥有 Oracle Clusterware（集群件）和 Oracle Automatic Storage Management (ASM) 的二进制文件。对于单实例安装（Standalone Server），Grid Infrastructure 指的是 Oracle Restart 和 Oracle ASM。因此，grid 用户拥有 Oracle Restart 和 Oracle ASM 的二进制文件\nE.这些组（OSOPER数据库运维、OSBACKUPDBA备份、OSKMDBA密钥管理 等）是用于 Oracle Database 特定的系统权限（例如 SYSOPER、SYSBACKUP、SYSKM），它们通常是 Oracle Database 所有者（例如 oracle 用户）的辅助组，而不是 Oracle Grid Infrastructure 所有者（例如 grid 用户）的辅助组。Grid Infrastructure 所有者主要需要 OSASM 组:主组 (Primary Group): oinstall (或自定义的 Oracle Inventory 组);关键辅助组 (Secondary Groups): asmadmin (OSASM) 和 asmdba (OSDBA for ASM);OSOPER for ASM 组（通常是 asmoper）可选\nF.在推荐的角色分离配置中，建议为 ASM 使用 OSDBA for ASM 组（通常为 asmdba）和为 Database 使用 OSDBA 组（通常为 dba），它们是不同的组。虽然可以使用同一个组（Standard Administration 配置），但这并不是“必须”的，且不符合角色分离的最佳实践"
},
{
  "QuestionID": 15,
  "QuestionType": "multiple",
  "QuestionText": "Which four are true about duplicating a database using Recovery Manager (RMAN)? (Choose four.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Duplication can be done by having the auxiliary database instance pull backup sets from the target database instance."},
    {"label": "B", "text": "A connection to an auxiliary instance is always required."},
    {"label": "C", "text": "A subset of the target database can be duplicated."},
    {"label": "D", "text": "A new DBID is always created for the duplicated database."},
    {"label": "E", "text": "A connection to the recovery catalog instance is always required."},
    {"label": "F", "text": "A backup of the target database is always required."},
    {"label": "G", "text": "Duplication can be done by having the target database instance push copies to the auxiliary database instance."},
    {"label": "H", "text": "A connection to the target database instance is always required."}
  ],
  "CorrectAnswer": ["A", "B", "C", "G"],
  "Explanation": "TARGET = 源库(要被复制的databasease)\nAUXILIARY = 新库(复制出来的databasease)\n基于磁盘备份Backup-based duplicate：只需要 auxiliary 连接，不需要 target，因为 auxiliary 是直接恢复磁盘上的 backup sets，不是 pull/push;如果是 active duplicate，就必须连接 target和 auxiliary，而且可以是 pull 或 push\n\nA.这描述了RMAN复制的常用方式。在 DUPLICATE 命令执行时，辅助Auxiliary实例会连接到Target实例，并从目标数据库的备份位置（如磁盘或磁带）pull所需的backup sets,这是标准的 server-assisted 复制方式\nB.要 duplicate,RMAN 必须至少连接TARGET database,AUXILIARY database,辅助实例 Auxiliary Instance就是指您正在创建的新数据库的实例。RMAN 必须连接到一个处于 NOMOUNT 状态的辅助实例，才能控制其创建数据文件、控制文件和启动数据库的整个过程\nC.RMAN 的 DUPLICATE 命令允许使用 SKIP TABLESPACE 子句来排除一个或多个表空间。这使得您可以仅复制目标数据库的一部分，例如:跳过一些大型的只读表空间或不需要的测试数据\nD.Full duplicate → 默认自动生成 新的 DBID;Duplicate for standby（搭建物理备库） → 必须保留原 DBID\nE.RMAN 可以在没有恢复目录Recovery Catalog的情况下执行复制操作,只要目标数据库的控制文件中包含足够的备份信息即可。这称为控制文件模式Control File mode复制;使用 recovery catalog可选,不是必须\nF.RMAN复制可以使用目标数据库的备份集Backup Sets,也可以使用目标数据库的活动数据文件副本 (Active Data File Copies)。Active Database Duplication无需提前创建备份,接通过网络复制数据文件,不需要 backup sets\nG.这描述了 RMAN复制的另一种方式，称为 Push-based或NFS-based复制。在这种情况下，RMAN 配置会指示Target实例将其数据文件直接push辅助实例的数据文件位置，而不是拉取备份集。这通常用于基于网络的快速复制\nH.如果使用的是基于备份的复制Backup-based Duplication，并且所有必需的备份和归档日志都存储在磁盘或磁带上（可以直接被辅助实例访问），那么不一定需要连接到目标 (Target) 实例"
},
{
  "QuestionID": 16,
  "QuestionType": "multiple",
  "QuestionText": "A container database called CDB1 is OMF-enabled. PDB_FILE_NAME_CONVERT is not configured in CDB1. PDB1 was unplugged from CDB1 earlier in the week. Examine this command, which will be executed in CDB1:\n\nCREATE PLUGGABLE DATABASE pdb1 -\nUSING '~/u01/app/oracle/oradata/pdb1.xml'\nSOURCE_FILE_NAME_CONVERT =\n('~/u01/app/oracle/oradata/', '~/u02/app/oracle/oradata/');\n\nWhich two are true? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "PDB1 data files already exist in the correct location."},
    {"label": "B", "text": "DBMS_PDB.CHECK_PLUG_COMPATIBILITY must be run in CDB1 before executing the command."},
    {"label": "C", "text": "PDB_FILE_NAME_CONVERT must be set before executing the command."},
    {"label": "D", "text": "/u01/app/oracle/oradata/pdb1.xml does not contain the current locations of data files for PDB1."},
    {"label": "E", "text": "PDB1 must be dropped from CDB1."}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "当你 UNPLUG PDB1 时，会生成一个XML文件（pdb1.xml），里面记录:当时数据文件的位置,PDB 的结构信息;但是之后如果数据文件被移动，xml 文件不会更新。所以 xml 文件“可能不包含当前的数据文件位置”\n当 CDB1 启用了 OMF（Oracle Managed Files） 后,Oracle 会自动管理文件路径:不需要设置 PDB_FILE_NAME_CONVERT(CDB 参数，永久规则，自动改路径),但是你可以使用 SOURCE_FILE_NAME_CONVERT(在执行 CREATE PLUGGABLE DATABASE时，将XML文件里的原路径转换为新路径)\nPlugging 之前,如果 PDB1 曾经属于 CDB1,那么:CDB1 里还记录着 PDB1 的信息,必须先 DROP PDB1（但保留数据文件）,才能重新 plug\n\nA.SOURCE_FILE_NAME_CONVERT的目的是为了在插入时进行文件复制和重命名,如果文件已经在正确位置,就不需要这个convert了\nB.CHECK_PLUG_COMPATIBILITY用于检查 PDB 与 CDB 之间是否存在版本或补丁集不兼容等问题，但它不是一个必须执行的步骤\nC.在本例中，您已经通过在 CREATE PLUGGABLE DATABASE 命令中显式使用 SOURCE_FILE_NAME_CONVERT 子句，覆盖了任何需要通过参数进行的自动文件管理，因此不需要设置该参数\nE.PDB1 之前已经从 CDB1 中 unplugged (拔出)。拔出操作会保留 PDB 的元数据（例如数据库名称、PDB ID 等）在 CDB 的字典中，但状态为 UNPLUGGED。要使用 CREATE PLUGGABLE DATABASE pdb1 ... 重新插入一个同名 PDB，您必须先通过 DROP PLUGGABLE DATABASE pdb1 KEEP DATAFILES; 命令删除 (Drop) CDB 中的旧元数据记录，以便 PDB 名称不冲突"
},
{
  "QuestionID": 17,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about transporting databases across platforms using Recovery Manager (RMAN) image copies? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "By default, the transported database will use Oracle Managed Files (OMF)"},
    {"label": "B", "text": "Data files can be converted on the destination system."},
    {"label": "C", "text": "Data files can be converted on the source system."},
    {"label": "D", "text": "A new DBID is automatically created for the transported database."},
    {"label": "E", "text": "Databases can be transported between systems with different endian formats."},
    {"label": "F", "text": "The password file is automatically converted by RMAN."}
  ],
  "CorrectAnswer": ["A", "B", "C"],
  "Explanation": "A.跨平台 RMAN image copy 默认使用 OMF 管理文件\nB.C.可以在目标端转换 endian;也可以在源端转换 endian\nD.Transported database 默认保留原 DBID;只有使用 RMAN duplicate 或 standby creation 时才会生成新的 DBID;运输数据库不改变 DBID\nE.需要使用 RMAN 或 RMAN + RMAN CONVERT 来转换 endian;直接拷贝不同 endian 的数据文件是不允许的\nF.RMAN不负责密码文件 (orapwd 或其他密码管理文件)的转换或传输。密码文件与数据库是分离的。您需要手动将密码文件从源系统复制到目标系统，并确保其格式和内容在新系统上兼容，通常需要使用 orapwd 实用程序重新创建或调整"
},
{
  "QuestionID": 18,
  "QuestionType": "multiple",
  "QuestionText": "Examine this command:\n$ rhpctl move database \"sourcehome Oracle_home_path\" \"destinationhome Oracle_home_path\"\n\nFor which two purposes can you use this command? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "to switch an existing Oracle Database home to a newer release of Oracle software on the same server"},
    {"label": "B", "text": "to switch to a read-only Oracle home"},
    {"label": "C", "text": "to switch back to the previous Oracle home as part of a rollback operation"},
    {"label": "D", "text": "to switch the Oracle Database home when using a centralized Rapid Home Provisioning server"},
    {"label": "E", "text": "to switch to a patched Oracle Database home"}
  ],
  "CorrectAnswer": ["C", "E"],
  "Explanation": "RHP（Rapid Home Provisioning） 是 Oracle 用来管理和部署数据库软件的工具,它可以管理多个 Oracle Home，包括:原始安装的 Oracle Home; 已打补丁的 Home; 回滚到旧版本的 Home\nrhpctl move database 命令用于 切换数据库使用的 Oracle Home\n\nA.虽然 rhpctl move database 用于切换家目录，但它通常用于在相同主要版本（Major Release）内进行补丁（例如 19.3 切换到 19.18）。跨主要版本（例如 19c 切换到 21c）通常需要使用 rhpctl upgrade database\nB.rhpctl move database 命令关注的是切换家目录路径，而不是改变家目录的读写属性\nD.选项本身描述了 rhpctl 命令的使用环境，但不是该命令的具体目的"
},
{
  "QuestionID": 19,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about changing the LOCAL_UNDO_ENABLED property to false in a CDB? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "After the change, only a common user with the required privilege can create an undo tablespace in CDB$ROOT."},
    {"label": "B", "text": "Any new PDB and existing PDBs are automatically configured to use the default undo tablespace in CDB$ROOT."},
    {"label": "C", "text": "After the change, only one undo tablespace can exist in CDB$ROOT."},
    {"label": "D", "text": "After the change, any user with the required privilege can create an undo tablespace in the PDBs."},
    {"label": "E", "text": "Undo tablespaces existing in PDBs must be dropped before the change."},
    {"label": "F", "text": "After the change, each existing PDB has to be reopened for the new undo mode to take effect."}
  ],
  "CorrectAnswer": ["A", "B"],
  "Explanation": "LOCAL_UNDO_ENABLED 是一个 CDB 级别属性，控制 undo tablespace 的管理模式:\nTRUE:每个 PDB 使用自己的 本地 undo tablespace（local undo）\nFALSE:所有 PDB 使用 CDB$ROOT 的共享 undo tablespace（central undo）\n\nA.B.当 LOCAL_UNDO_ENABLED 设置为 FALSE 时，CDB将切换到集中式撤销模式Centralized Undo Mode。在这种模式下,所有undo都集中存储在 CDB$ROOT 中的一个或多个undo tablespace。只有Common User（例如 SYS）来执行,普通 PDB 用户无法创建 undo tablespace,所有现有的 PDB（在下次打开时）和新创建的 PDB 都会自动使用 CDB$ROOT 默认的undo tablespace。PDB不再拥有或使用自己的undo tablespace\nC.在集中式撤销模式下，CDB$ROOT中也可以存在多个undo tablespace。管理员可以创建多个undo tablespace并在它们之间切换\nE.PDB 中的旧undo tablespace将变为离线，但不会被自动删除\nF.PDB 不一定需要重新打开。从 Oracle 19c 开始，如果 CDB 在关闭状态下进行切换，PDB 可以在下次启动时自动进入新的模式。如果 CDB 在打开状态下进行切换，虽然 PDB 会继续使用当前的撤销模式直到它被关闭和重新打开，但命令本身没有强制要求立即重新打开 PDB，这个行为是取决于 PDB 的当前状态的"
},
{
  "QuestionID": 20,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about SQL Performance Analyzer (SPA)? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is integrated with the SQL Access Advisor."},
    {"label": "B", "text": "It predicts the impact of system changes on SQL workload response time."},
    {"label": "C", "text": "It provides before and after execution statistics for each SQL statement in the analysis task."},
    {"label": "D", "text": "It offers fine-grained analysis of all the SQL statements in the analysis task as a group."},
    {"label": "E", "text": "SQL statements that were originally run concurrently are run concurrently by SPA."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "SQL Performance Analyzer（SPA）用于评估数据库更改对SQL工作负载性能的影响\nA.SPA 与 SQL Tuning Advisor (SQL 优化顾问) 紧密集成，而不是 SQL Access Advisor。SPA 识别出退化的 SQL 语句后，可以将它们提交给 SQL Tuning Advisor 进行进一步优化建议（如创建 SQL Profile）。SQL Access Advisor 专注于物理设计（索引、物化视图等）\nB.SPA 通过在更改之前和之后执行相同的 SQL 工作负载，量化地预测这些系统变更（例如升级、初始化参数修改、统计信息更新等）对整个 SQL 工作负载响应时间和性能的影响\nC.SPA 的分析结果是逐条 SQL 语句进行的。它会比较每条 SQL 语句在变更前后的执行计划、CPU 时间、I/O 等统计信息，并明确报告哪些语句变快了，哪些变慢了，以及变化的幅度。这是其精细分析的基础\nD.虽然它对所有 SQL 语句进行分析，但其分析的特点是逐条 (per-SQL) 比较和报告，而不是将它们作为一个整体组来分析其细微变化。它关注的是每条语句的个体性能变化\nE.SPA 默认 按顺序执行 SQL;要模拟并发，用户需要使用 Real Application Testing (RAT) 组件中的 Database Replay (数据库重放) 功能，而不是 SPA"
},
{
  "QuestionID": 21,
  "QuestionType": "single",
  "QuestionText": "A user complains about poor database performance. You want to verify if the user's session has waited for certain types of I/O activity. Which view displays all waits waited on by a session at least once? (Choose one.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "V$SESSION_EVENT"},
    {"label": "B", "text": "V$SESSTAT"},
    {"label": "C", "text": "V$SESSION_WAIT"},
    {"label": "D", "text": "V$SESSION_WAIT_CLASS"},
    {"label": "E", "text": "V$SESSION"}
  ],
  "CorrectAnswer": ["A"],
  "Explanation": "A. V$SESSION_EVENT显示了特定会话（SID）自连接以来在每个等待事件EVENT上等待的总次数TOTAL_WAITS和总等待时间TIME_WAITED\nB.V$SESSTAT显示的是会话的统计信息（如 CPU 使用时间、逻辑读次数等），而不是等待事件的详细信息\nC.V$SESSION_WAIT只显示一个会话当前正在等待或上一次等待的那个单个等待事件的详细信息\nD.V$SESSION_WAIT_CLASS显示 session 当前等待事件属于哪个 wait class\nE.V$SESSION是关于会话的基本信息和当前状态，例如用户名、状态、当前的 SQL ID 等"
},
{
  "QuestionID": 22,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about gathering optimizer statistics? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Executing DBMS_STATS.GATHER_DATABASE_STATS while connected to CDB$ROOT gathers object statistics in all open PDBs except PDB$SEED."},
    {"label": "B", "text": "Executing DBMS_STATS.GATHER_DATABASE_STATS while connected to a PDB opened in read/write mode gathers object statistics for that PDB."},
    {"label": "C", "text": "Executing DBMS_STATS.GATHER_DATABASE_STATS while connected to CDB$ROOT gathers object statistics only in CDB$ROOT."},
    {"label": "D", "text": "System statistics can be gathered only while connected to CDB$ROOT."},
    {"label": "E", "text": "Executing DBMS_STATS.GATHER_DATABASE_STATS while connected to CDB$ROOT gathers object statistics in all open pluggable databases (PDBs)."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "Gather Optimizer Statistics收集优化器统计信息 是 Oracle 数据库中一个非常重要的动作，用来让优化器Optimizer更聪明地选择执行计划。\nA.C.E.GATHER_DATABASE_STATS：收集整个数据库统计信息,在 CDB$ROOT中运行此命令默认只收集 CDB$ROOT 本身的对象统计信息,不会收集任何 PDB 的对象统计信息\nB.当你连接到一个以读/写模式打开的 PDB 并执行 DBMS_STATS.GATHER_DATABASE_STATS 时，它只会收集该 PDB 中所有对象（如表、索引）的统计信息，而不会影响到 CDB$ROOT 或其他 PDB\nD.也可以在 PDB 内部收集系统统计信息"
},
{
  "QuestionID": 23,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true? (Choose two.)",
  "ImageURL": "images/Q23.png",
  "Options": [
    {"label": "A", "text": "Any PDB not specified in the plan will be unable to execute statements in parallel."},
    {"label": "B", "text": "PDB3 can use all available parallel execution processes at times."},
    {"label": "C", "text": "PDB1 is always limited to 40% of the available system resources regardless of demand."},
    {"label": "D", "text": "Any PDB not specified in the plan will be able to use a maximum of 16.5% of the available system resources."},
    {"label": "E", "text": "PDB3 is guaranteed to receive at least 20% of the available system resources if there is enough demand."},
    {"label": "F", "text": "PDB2 is guaranteed at least 25% of the available parallel execution processes if there is enough demand."}
  ],
  "CorrectAnswer": ["A", "B"],
  "Explanation": "PARALLEL_SERVER_LIMIT 定义了该 PDB 最多可以使用的并行执行服务器进程占系统中所有可用进程的百分比\nSHARES 用于分配资源（如 CPU、I/O 等），并在空闲或竞争激烈时确定 PDB 获得资源的比例\nA.对于任何未明确指定指令的 PDB，将应用 ORA$DEFAULT_PDB_DIRECTIVE的规则,本题ORA$DEFAULT_PDB_DIRECTIVE 的 PARALLEL_SERVER_LIMIT 设置为 0\nB.PDB3 的 PARALLEL_SERVER_LIMIT 为空，没有硬性并行限制（即默认为 100%）\nC.PDB1 的 SHARES 为 2，总份额为 6。在资源竞争激烈时，PDB1保证获得的最小CPU/I/O资源比例2/6≈33.3%,在资源空闲时，它可以获得 100% 的资源\nD.未指定的 PDB 使用 ORA$DEFAULT_PDB_DIRECTIVE，其 SHARES 为 1，总份额为 6。在资源竞争激烈时，它保证获得的最小资源比例是 1/6≈16.67%\nD.PDB3 的 SHARES 为 1，总份额为 6。它保证获得的最小资源比例是 1/6≈16.67%，而不是 20%\nE.PARALLEL_SERVER_LIMIT (25%) 是 PDB2 并行进程的上限（最大值），不是保证的最低值"
},
{
  "QuestionID": 24,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about the execution of operating system scripts starting from Oracle Database 19c? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "orainstRoot.sh can be executed automatically by the Database installer by using sudo or root credentials."},
    {"label": "B", "text": "root.sh can be executed automatically by the Database Installer only if it is provided with root credentials."},
    {"label": "C", "text": "The sudo password can be specified in a response file."},
    {"label": "D", "text": "root.sh can be executed automatically by the Database installer only by using sudo credentials."},
    {"label": "E", "text": "The sudo password must be specified in a response file."},
    {"label": "F", "text": "The root password cannot be specified in a response file."}
  ],
  "CorrectAnswer": ["A", "F"],
  "Explanation": "orainstRoot.sh 和 root.sh 是 Oracle 数据库安装过程中两个非常重要的脚本，它们都需要以 root 用户的权限来执行，用于完成一些只有系统管理员才能操作的关键配置\norainstRoot.sh(Oracle Inventory Root Script)主要是在 [首次安装 Oracle 软件时执行] ，它的核心任务是创建或更新 Oracle Inventory的配置信息:\n1.创建或更新 /etc/oraInst.loc 文件; /etc/oraInst.loc 文件记录了:\n--1.inventory_loc(Oracle Inventory 的存储路径)\n--2.inst_group:拥有 Oracle Inventory 访问权限的 OS 用户组(通常是 oinstall)\n2.设置权限:确保 Oracle 软件安装用户组（如 dba 或 oinstall）拥有访问 Inventory 目录的正确权限。\n\nroot.sh(Root Script根脚本) [每次安装一个新的 ORACLE_HOME 时] 主要用于配置特定 Oracle Home 目录的系统环境，以及为数据库实例的运行准备系统资源:\n1.创建或更新 /etc/oratab 文件： 这是 Oracle 软件用来记录当前系统上所有安装的数据库实例信息的文件，包括实例名和对应的 ORACLE_HOME 路径\n2.设置执行权限： 设置 Oracle Home 下某些可执行文件的权限，允许它们在数据库启动和关闭时进行必要的系统级操作\n3.配置权限： 确保数据库实例能够正确访问所需的系统设备和资源(例如，在一些旧版本或特定配置下用于共享内存和信号量配置)\n\n响应文件Response File是一个文本文件（通常以 .rsp 为扩展名），其中包含了 Oracle 软件安装程序（Installer，如 OUI 或 Grid Setup Wizard）在安装过程中所需的所有配置参数、选项和输入值\n\nResponse File指导安装程序，安装程序在特定阶段自动调用或要求执行两个 root 脚本\n\nA.从 19c 开始，Oracle 引入了自动化执行 orainstRoot.sh 和 root.sh 的功能。对于 orainstRoot.sh，安装程序可以接收 sudo 密码(用户的登录密码)或直接的 root 密码来实现自动执行B.D.root.sh 可以通过提供 sudo 凭证或者root 凭证来自动执行\nC.E.F.sudo 密码也不建议或不允许直接写入响应文件"
},
{
  "QuestionID": 25,
  "QuestionType": "single",
  "QuestionText": "Automatic Shared Memory Management is disabled for one of your database instances. Some SQL statements perform poorly due to excessive hard parse activity, thereby degrading performance. What would be your next step? (Choose one.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Run the SQL Access Advisor."},
    {"label": "B", "text": "Run the Memory Advisor for the shared pool."},
    {"label": "C", "text": "Run the SQL Tuning Advisor."},
    {"label": "D", "text": "Run the Memory Advisor for the Program Global Area."},
    {"label": "E", "text": "Run the Memory Advisor for the System Global Area."}
  ],
  "CorrectAnswer": ["B"],
  "Explanation": "SQL 语句性能差，原因是excessive hard parse activity\n原因:过多的硬解析通常是因为 SQL 语句无法在共享池中找到对应的解析代码（即无法实现软解析),意味着:\n--1.SQL 语句没有重用（可能存在字面值差异）;--2.Shared Pool is too small导致频繁的LRU(Least Recently Used)淘汰，将旧的SQL cursors和执行计划从内存中挤出，使得下次执行时必须重新进行硬解析。(当你执行一个 SQL 查询（如 SELECT * FROM students），数据库会生成一个结果集（可能有多行）。Cursor 就是指向这个结果集的指针，你可以通过它逐行操作或提取数据)\n\nHard Parse是指数据库需要完整地执行所有解析步骤，才能生成一个可执行的、新的执行计划\nSoft Parse是指数据库在共享池中找到了与当前 SQL 语句完全匹配的游标，因此可以直接使用现有的执行计划\n\nA.SQL Access Advisor用于推荐索引、物化视图等访问结构，以改善执行计划，而不是解决硬解析导致的问题\nB.Memory Advisor会分析当前的工作负载和共享池的使用情况，并模拟不同大小的共享池对硬解析和缓存命中率的影响,确定共享池的最佳大小，以最小化硬解析活动\nC.SQL Tuning Advisor用于分析单条 SQL 语句的执行计划并提供建议，但这属于优化步骤，而不是解决内存不足导致的硬解析问题\nD.用于分析PGA 用于排序、哈希连接等操作的私有内存。它与共享池的硬解析问题无关\nE.SGA 内存顾问会评估整个 SGA 的大小，但它不会像共享池顾问那样聚焦于硬解析和游标缓存的问题\n\nSGA(System Global Area)是数据库实例级别的共享内存区域。它在数据库启动时分配，并作为所有用户进程和后台进程共享的一块内存池,SGA 的主要目的是缓存数据和控制信息，以便所有连接到该实例的用户都能快速、高效地访问这些共享资源\n\nPGA(Program Global Area)是用户进程/服务器进程级别的私有内存区域。它不是共享的，每个连接到数据库的用户会话或后台进程都会有自己独立的PGA,PGA 主要用于存储单个会话或进程工作所需的私有数据和控制信息"
},
{
  "QuestionID": 26,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about flashback features in Oracle Database 19c and later releases? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Flashback logs are automatically purged when DB_FLASHBACK_RETENTION_TARGET is set lower than the time they have already been retained."},
    {"label": "B", "text": "Flashback logs are monitored and proactively deleted when beyond the retention period defined in DB_FLASHBACK_RETENTION_TARGET only after there is space pressure."},
    {"label": "C", "text": "Flashback logs are monitored and proactively deleted when beyond the retention period defined in DB_FLASHBACK_RETENTION_TARGET before there is space pressure."},
    {"label": "D", "text": "Flashback logs are monitored for being older than the retention period defined in DB_FLASHBACK_RETENTION_TARGET and can be deleted by an administrator written event trigger."},
    {"label": "E", "text": "Flashback logs are automatically purged whenever the value of DB_FLASHBACK_RETENTION_TARGET is changed"}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "Flashback logs 是用于支持数据库闪回（Flashback Database）操作的关键文件，它们存储在 快速恢复区 (Fast Recovery Area, FRA)\nA.DB_FLASHBACK_RETENTION_TARGET 定义了数据库实例应尽力保留 Flashback logs 的时间。如果管理员将这个参数的值调低（例如从 24 小时改为 8 小时），那么所有超出新保留目标时间的旧 Flashback logs 会被系统识别，并在下次清理或空间检查时自动清理\nB.C.Oracle 数据库的后台进程(主要是 RVWR(Recovery Writer) 和 MMON(manageability Monitor))会主动监控 Flashback logs 的年龄。一旦日志的年龄超过 DB_FLASHBACK_RETENTION_TARGET 所设定的时间，它们就会被标记为过期，并在 FRA 空间尚未达到紧张程度之前被主动删除\nD.Flashback logs 的清理是数据库的内部管理任务，由后台进程自动处理。它们不依赖于管理员编写的事件触发器（event trigger）来删除\nE.只有当新的保留目标低于现有日志的保留时间时，日志才会被自动清理（如选项 A 所述）。如果目标被调高，则不会触发清理，而是会尝试保留更久"
},
{
  "QuestionID": 27,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true? (Choose two.)",
  "ImageURL": "images/Q27.png",
  "Options": [
    {"label": "A", "text": "Data file 24 can be recovered while PDB2 is opened."},
    {"label": "B", "text": "Data file 24 must be recovered while the CDB is opened."},
    {"label": "C", "text": "Data file 24 can be recovered while CDB$ROOT and PDB$SEED are opened."},
    {"label": "D", "text": "Data file 24 cannot be recovered while the CDB is opened."},
    {"label": "E", "text": "Data file 24 must be recovered while PDB2 is closed."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "LOG_MODE是ARCHIVELOG，表示数据库可以进行完全恢复\nPDB 状态： 存在 CDB$ROOT, PDB1 (Data File 24), PDB2 (Data File 16)。\n数据库实例已启动并挂载instance started, database mounted，但尝试打开所有PDB 时，PDB1的data file24无法被识别或锁定，导致 PDB1 无法打开。\nPDB 的恢复规则如下:\n--1.PDB 的恢复范围： 无论是数据文件恢复（RECOVER DATAFILE）还是整个 PDB 恢复（RECOVER PLUGGABLE DATABASE），都必须在特定的容器内执行。\n--2.PDB 恢复状态： 目标 PDB 必须处于打开 (OPEN) 或挂载 (MOUNT) 状态，才能对其进行恢复。如果 PDB 无法打开，则必须在 CDB$ROOT 中执行恢复命令。\n--3.CDB$ROOT 状态： 只要 CDB 处于 MOUNTED 或 OPEN 状态，就可以执行 PDB 的恢复操作。\nA.Data File 24 属于 PDB1。恢复 PDB1（或其文件）时，PDB2 是否打开是无关紧要的。只要 CDB 处于 OPEN 状态（并且 PDB1 至少处于 MOUNTED 或无法打开但 CDB OPEN 的状态），就可以执行对 PDB1 的恢复\nB.数据文件恢复可以在 CDB 处于 MOUNTED 模式下进行，只要归档日志可用即可\nC.如果 CDB$ROOT 处于 OPEN 状态，则可以在 CDB$ROOT 容器内执行对 PDB1 数据文件 24 的恢复命令。恢复 PDB1 时，PDB$SEED 是否打开是无关紧要的，但 CDB$ROOT 必须处于 OPEN 状态才能管理和恢复其子 PDB;\nPDB$SEED 是 Oracle 多租户架构（Multitenant）中的“模板 PDB”。它是一个read-only的系统PDB，Oracle 用它作为模板来快速复制创建新的PDB"
},
{
  "QuestionID": 28,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about RMAN duplexed backup sets? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A duplexed backup set uses the same number of SBT channels as a non-duplexed backup set for the same number of files."},
    {"label": "B", "text": "A non-duplexed backup set written to disk can be duplexed to disk by backing up the backup set that is already on disk."},
    {"label": "C", "text": "A non-duplexed backup set written to SBT can be duplexed to tape by backing up the backup set that is already on tape."},
    {"label": "D", "text": "A non-duplexed backup set written to disk can be duplexed to tape by backing up the backup set that is already on disk."},
    {"label": "E", "text": "A non-duplexed backup set written to SBT can be duplexed to disk by backing up the backup set that is already on tape."},
    {"label": "F", "text": "A duplexed backup set always uses twice as many SBT channels as a non-duplexed backup set for the same number of files."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "RMAN 双工备份集(Duplexed Backup Set)是指 RMAN 在创建备份集时，同时创建多个（最多 4 个）相同内容的备份集副本，以增加数据冗余和恢复的可靠性。\nA.Duplexed Backup Set只会影响输出的备份集数量,它不会影响用于读取源文件的通道数量。无论是单份还是双工备份，RMAN 读取数据所需的通道数量是相同的\nB.RMAN 允许你使用 BACKUP AS BACKUPSET... FROM BACKUPSET 命令，将一个已存在的、非双工的备份集作为源，创建它的一个或多个副本。如果源备份集在磁盘上，新副本可以写入磁盘，实现磁盘到磁盘的再双工\nC.E.RMAN 不支持直接从磁带设备上的备份集SBT(System Backup to Tape)读取数据来创建另一个备份集副本。如果源备份集在磁带上，你必须先将其恢复到磁盘或将其注册到目录中并进行特殊处理，但不支持直接的SBT到SBT的再备份操作\nD.使用 BACKUP AS BACKUPSET... FROM BACKUPSET 命令。如果源备份集在磁盘上，你可以指定一个SBT通道，将新的备份集副本写入磁带\nF.duplexed backup set创建多份副本。如果双工系数设置为2，且所有副本都写入SBT，那么RMAN可能会使用更多的SBT通道，但并非总是两倍。而且，如果副本都写入磁盘，则不会使用任何 SBT 通道"
},
{
  "QuestionID": 29,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about RMAN persistent configuration settings, administration, and their effects? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A target database's persistent RMAN configuration settings are always stored in the target's control file"},
    {"label": "B", "text": "Backup older than the recovery window retention policy are always deleted automatically if the backup location has insufficient space."},
    {"label": "C", "text": "Backups written to the fast recovery area (FRA) that are obsolete based on the redundancy retention policy can be deleted automatically to free space."},
    {"label": "D", "text": "The RMAN SHOW ALL command displays only settings with nondefault values."},
    {"label": "E", "text": "A target database's persistent RMAN configuration settings are always synchronized automatically with the RMAN catalog."},
    {"label": "F", "text": "The V$RMAN_CONFIGURATION view displays only settings with values that have been modified."},
    {"label": "G", "text": "A DBA must specify either a redundancy retention policy or a recovery window retention policy"}
  ],
  "CorrectAnswer": ["A", "C", "F"],
  "Explanation": "A.RMAN 持久化配置Persistent Configuration Settings, 例如CONFIGURE RETENTION POLICY总是存储在目标数据库的控制文件Control File中。如果使用了恢复目录Recovery Catalog,这些设置也会被同步到恢复目录中,但控制文件是它们的主存储位置\nB.C.即使备份已超过恢复窗口保留策略，它们也不会总是自动删除。只有存储在 FRA 中的备份，在空间压力下，才会被自动删除。如果备份存储在非 FRA 磁盘位置或磁带上，RMAN 不会（也不能）自动删除它们，必须通过 DELETE OBSOLETE 命令手动删除\nD.SHOW ALL 命令会显示所有持久化配置参数，包括那些使用默认值的参数\nE.RMAN Recovery Catalog（恢复目录）是一个存放在单独数据库里的 RMAN 备份元数据仓库,在单独数据库里保存备份历史和配置的地方，用来长期保存备份信息并管理多个数据库,RMAN 配置保存在控制文件中，并且在执行 CONFIGURE 命令时复制到 catalog;它们并不会自动、持续、实时同步\nF.动态性能视图 V$RMAN_CONFIGURATION 只显示那些已经被修改（即具有非默认值）的 RMAN 持久化配置参数\nG.RMAN 在安装时有一个默认的保留策略（REDUNDANCY 1）。DBA 可以选择不修改它，即不必必须指定。"
},
{
  "QuestionID": 30,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about Optimizer Statistics Advisor? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It can be run only manually."},
    {"label": "B", "text": "It is part of the DBMS_ADVISOR package."},
    {"label": "C", "text": "It can recommend changes to improve the statistics gathering process."},
    {"label": "D", "text": "It always analyzes all schemas in the database."},
    {"label": "E", "text": "It runs automatically every night by default."},
    {"label": "F", "text": "It is part of the DBMS_STATS package."}
  ],
  "CorrectAnswer": ["C", "E", "F"],
  "Explanation": "Optimizer Statistics Advisor旨在帮助 DBA 确保统计信息的质量，从而保证优化器生成高效的执行计划。\nA.E.默认是自动运行的,也可以手动运行\nB.F.是 DBMS_STATS 包的一部分\nD.它基于工作负载和最近的统计信息活动运行的。它不会在每次运行时都无差别地分析数据库中的所有 Schema。它专注于检查那些与最近执行的 SQL 语句相关的对象，或者那些统计信息可能存在问题的对象"
},
{
  "QuestionID": 31,
  "QuestionType": "multiple",
  "QuestionText": "You issued this command:\nRMAN> BACKUP RECOVERY FILES;\nWhich two are true? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "All Oracle recovery files not in the current FRA that have not been backed up already, are backed up."},
    {"label": "B", "text": "All non-Oracle files in the current FRA that have not been backed up already, are backed up."},
    {"label": "C", "text": "All Oracle recovery files in the current FRA that have not been backed up already, are backed up."},
    {"label": "D", "text": "All Oracle recovery files in the current fast recovery area (FRA) are backed up."},
    {"label": "E", "text": "These backups can be written to disk or SBT."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "BACKUP RECOVERY FILES 命令是备份FRA中与数据库恢复相关的关键文件，（一般备份到磁盘或磁带），RMAN 会自动识别需要备份的文件类型\nA.RMAN 的“恢复文件”（Recovery Files）不仅指 FRA 中的文件，还包括所有归档日志（Archived Redo Logs） 和 Flashback Logs。即使某些归档日志（在 FRA 启用之前）存储在 FRA 外部的归档目标路径中，只要它们是 Oracle 恢复所必需的，并且从未被备份过，RMAN 也会将其纳入 BACKUP RECOVERY FILES 的范围\nB.C.D.它会检查 FRA 中的所有 Oracle 恢复文件（如归档日志、Flashback Logs），并专门选择那些从未成功备份过的文件进行备份。这是一种用于确保恢复链完整性的有效方法\nE.不支持直接将备份写入磁盘或 SBT（磁带）的显式选择，它遵循当前的 CONFIGURE DEFAULT DEVICE TYPE 设置，也就是说你可以去改CONFIGURE DEFAULT DEVICE TYPE，选择存到disk还是tape，但是不能直接写命令让它存到磁盘还是磁带。"
},
{
  "QuestionID": 32,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about the Oracle database methodology? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The Oracle Database time model should be used to find the database and instance areas most in need of tuning."},
    {"label": "B", "text": "Tuning activities should stop once the user is satisfied with performance."},
    {"label": "C", "text": "Tuning activities should stop once agreed service levels for performance have been met."},
    {"label": "D", "text": "The database instance memory should always be tuned before tuning any file systems."},
    {"label": "E", "text": "SQL statements should always be tuned before tuning any file systems."},
    {"label": "F", "text": "The alert log should be used to find the database and instance areas most in need of tuning."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "Oracle 数据库性能调优的方法论 (Methodology)建立在两大核心支柱上:\n--1.诊断Diagnosis:关注时间。我们通过 Oracle 时间模型Time Model来衡量和定位瓶颈\n--2.目标 Goal:关注结果。调优的目标是达到服务级别协议 (Service Level Agreement, SLA)\nA.Time Model是调优的起点Start Point of Tuning，它通过 V$SYS_TIME_MODEL 等视图记录数据库在哪些等待事件 (Wait Events) 或 CPU 使用上花费了时间\nB.C.调优终点 (Stopping Point of Tuning):Service Levels (服务级别) 是客观、可测量的标准。一旦达到预定的性能指标，调优活动就完成了\nD.E.调优层次 (Tuning Hierarchy)在调优时，我们通常遵循 SQL → 实例 (Instance) → I/O (Filesystem) 的顺序。调优的起点是 Time Model (时间模型)。如果 Time Model 显示 I/O 等待占用了 80% 的时间，那么 DBA 就必须将 I/O 子系统（File Systems） 作为第一个调优对象在这种情况下，即使还有一些 SQL 语句（逻辑层）没有调优，也不能说“总是”必须先调优 SQL 或内存。最大的瓶颈决定优先级；虽然 SQL 优化 (Option E) 是最优先的（因为它能减少不必要的工作量），但如果存储硬件配置不合理（例如，严重缺乏 I/O 带宽），那么修复 I/O 可能是最快、最有效的第一步\nF.Alert Log警告日志主要记录数据库的启动、关闭、关键错误、配置变化等结构性事件"
},
{
  "QuestionID": 33,
  "QuestionType": "multiple",
  "QuestionText": "While backing up to the Oracle Fast Recovery Area (FRA), you determined the backup is taking too long and suspect a performance bottleneck. Which three are true about diagnosing and tuning these problems? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "If an RMAN BACKUP VALIDATE command takes roughly the same time as an actual backup, then both read and write I/O are likely bottlenecks."},
    {"label": "B", "text": "Setting DBWR_IO_SLAVES to a non zero value can improve backup performance when using synchronous I/O."},
    {"label": "C", "text": "If an RMAN BACKUP VALIDATE command takes noticeably less than an actual backup, then write I/O is a likely bottleneck."},
    {"label": "D", "text": "If an RMAN BACKUP VALIDATE command takes roughly the same time as an actual backup, then read I/O is a likely bottleneck."},
    {"label": "E", "text": "Data files with a high value in V$BACKUP_SYNC_IO.DISCRETE_BYTES_PER_SECOND are a potential performance bottleneck when synchronous I/O is used."},
    {"label": "F", "text": "Setting DBWR_IO_SLAVES to a non zero value can improve backup performance when using asynchronous I/O."},
    {"label": "G", "text": "Data files with a high value in V$BACKUP_ASYNC_IO.SHORT_WAITS are a potential performance bottleneck when asynchronous I/O is used."}
  ],
  "CorrectAnswer": ["B", "C", "D"],
  "Explanation": "RMAN> BACKUP ...： 执行完整的备份过程，包括从数据文件读取数据 (Read I/O) 和将备份集写入 FRA/磁盘/磁带 (Write I/O)\n\nRMAN> BACKUP VALIDATE ...： 仅执行读取和校验过程，但不将数据写入备份介质。这主要涉及 Read I/O\nSynchronous I/O (同步 I/O)： 当 DBWn 请求 OS 将数据块写入磁盘时，DBWn(Database Writer) 必须停止并等待 (wait) 写入操作完成后才能继续工作。这会浪费 CPU 时间，降低性能\n\nAsynchronous I/O (异步 I/O)： DBWn 请求写入后，可以立即继续处理其他任务，OS 在后台完成写入。完成后，OS 再通知 DBWn。这能最大限度地提高效率\n\n在 OS 不支持或未配置 异步 I/O 的情况下，DBWn默认会使用同步 I/O 模式。将DBWR_IO_SLAVES设置为一个非零值时，Oracle 会创建额外的后台进程，称为I/O Slaves。这些I/O Slaves的任务是代替DBWn主进程去执行那些耗时的同步 I/O 写入操作\n\nV$BACKUP_SYNC_IO.DISCRETE_BYTES_PER_SECOND (每秒离散字节数),这个指标衡量的是 RMAN 通道在同步 I/O 模式下的 I/O 吞吐量 (Throughput)，即每秒成功读取或写入的字节数\n\nV$BACKUP_ASYNC_IO.SHORT_WAITS:SHORT_WAITS 记录的是 RMAN 通道向 OS 发出 Asynchronous I/O (异步 I/O) 请求后，不得不短暂等待 I/O 完成的次数。SHORT_WAITS:只是 RMAN 在等待 I/O 完成时发生的短暂、轻微的停顿。这可能仅仅是 OS 快速追赶 RMAN 需求的信号\nLONG_WAITS:这才是真正的、严重的 I/O 瓶颈 的明确信号，表明 I/O 子系统已完全无法跟上"
},
{
  "QuestionID": 34,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true? (Choose two.)",
  "ImageURL": "images/Q34.png",
  "Options": [
    {"label": "A", "text": "The inserts on USER1.EMP remain uncommitted when the session connected to PDB2."},
    {"label": "B", "text": "The inserts on USER1.EMP were committed when the session inserted a row into USER2.DEPT."},
    {"label": "C", "text": "The insert on USER2.DEPT fails because of the active transaction in the parent container."},
    {"label": "D", "text": "The insert on USER2.DEPT is a recursive autonomous transaction by the child session and is committed."},
    {"label": "E", "text": "The inserts on USER1.EMP were rolled back when the session connected to PDB2."},
    {"label": "F", "text": "The insert on USER2.DEPT is uncommitted."},
    {"label": "G", "text": "The inserts on USER1.EMP were committed when the session connected to PDB2."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "ALTER SESSION SET CONTAINER不会 (WILL NOT) 触发隐式提交 (Implicit Commit),也不会 (WILL NOT) 触发隐式回滚 (Implicit Rollback)\n在一个 CDB (Container Database) 中，一个会话在任何时刻只能有一个活动事务 (Active Transaction)\n\nD.自治事务 (Autonomous Transaction) 是一个完全独立 (independent) 的事务，它与调用它的主事务 (Main Transaction) 相互隔离它的 COMMIT (提交) 或 ROLLBACK (回滚) 操作，不会影响到主事务的状态，反之亦然;从属 (subordinate) 或递归调用 (recursively called) 的，通常是由一个主事务调用。它是在主事务的执行流程中被启动的，而不是一个全新的、外部的会话\nINSERT只是一个普通的DML语句，它没有使用 PRAGMA AUTONOMOUS_TRANSACTION 指令，所以它不是一个自治事\nF.会fail,不会uncommitted"
},
{
  "QuestionID": 35,
  "QuestionType": "single",
  "QuestionText": "Examine this configuration:\n1. CDB1 is an Oracle Database 12c Release 2 database containing pluggable databases PDB$SEED, PDB1, and PDB2.\n2. PDB$SEED is open READ ONLY\n3. PDB1 is open READ WRITE\n4. PDB2 is MOUNTED\n5. ORACLE_HOME is /u01/app/oracle/product/18.1.0/dbhome_1\n\nYou execute these commands before upgrading the database to the current release: For which databases will fixup scripts be created? (Choose one.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "CDB1, PDB$SEED, PDB1, and PDB2"},
    {"label": "B", "text": "PDB$SEED, PDB1, and PDB2 only"},
    {"label": "C", "text": "CDB1 and PDB$SEED only"},
    {"label": "D", "text": "CDB1, PDB1, and PDB2 only"},
    {"label": "E", "text": "CDB1, PDB$SEED, and PDB1 only"}
  ],
  "CorrectAnswer": ["E"],
  "Explanation": "在 Oracle 多租户环境中进行数据库升级时，有两个核心组件是不能跳过的:\n--1.CDB1 (CDB$ROOT): 它是整个数据库的根，包含所有通用元数据。它的升级是必须的\n--2.PDB$SEED: 它是未来所有 PDB 的模板。为了确保升级后创建的新 PDB 都是新版本，PDB$SEED 也必须被升级\n\n要对一个容器（无论是 CDB 根还是 PDB）进行升级 (Upgrade)，必须运行修改其数据字典和组件的脚本。这种修改操作要求:PDB 必须处于读写状态;升级工具会跳过已挂载 (MOUNTED) 或只读 (READ ONLY) 的用户 PDB"
},
{
  "QuestionID": 36,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about Oracle Flashback features? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "FLASHBACK QUERY can retrieve REDO records from ONLINE and ARCHIVED REDO LOG files."},
    {"label": "B", "text": "FLASHBACK VERSION QUERY can retrieve REDO records from ONLINE and ARCHIVED REDO LOG files."},
    {"label": "C", "text": "FLASHBACK TABLE can undrop a column."},
    {"label": "D", "text": "FLASHBACK DROP can undrop an index when undropping a table."},
    {"label": "E", "text": "After a database is restored from flashback logs using the FLASHBACK DATABASE command, it is sometimes rolled forward using redo logs."}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "FLASHBACK QUERY和 FLASHBACK VERSION QUERY都是为了查看数据在过去某个时间点或 某个时间段内的状态\n\nREDO logs 用于恢复和前滚（物理变化）;UNDO segments 用于事务回滚和构造一致性读 (consistent read)（逻辑变化）。\n\nAB.使用的是 undo,不是 redo\nC.FLASHBACK TABLE 没有提供一个单独的、粒度精细的子句来仅恢复一个已删除的列\nD.FLASHBACK DROP 是一个例外，它不依赖于事务日志（ROLLBACK 依赖的 UNDO）。它依赖于 Recycle Bin (回收站) 机制。当一个表被 DROP 时，Oracle 只是重命名它并将它标记为在回收站中。FLASHBACK DROP 只是简单地将表名改回来，所以这是一种特殊的、基于对象重命名的恢复，而不是事务回滚\nE.FLASHBACK DATABASE 命令通过读取Flashback Logs，将数据文件块快速地物理还原到目标时间点或 SCN (System Change Number) 之前的状态。这是一个 快速回退(Rewind)的过程;为了确保数据库精确地达到用户指定的目标 SCN，Oracle 需要在 Flashback Logs 恢复的终点之后，应用 REDO Logs 中的记录，将数据库状态 前滚 (roll forward) 到精确的目标 SCN"
},
{
  "QuestionID": 37,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about an application seed pluggable database (PDB)? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is automatically synchronized with its application root PDB when an application is upgraded."},
    {"label": "B", "text": "It cannot be added to an application container after the application container has already been created."},
    {"label": "C", "text": "A new application PDB created by cloning an application seed PDB can have an old version of the application installed after cloning completes."},
    {"label": "D", "text": "It is automatically synchronized with its application root PDB when an application is installed."},
    {"label": "E", "text": "It cannot be dropped from its application container."},
    {"label": "F", "text": "A new application PDB created by cloning an application seed PDB can have an up-to-date version of the application installed after cloning completes."},
    {"label": "G", "text": "It is not required in an application container."}
  ],
  "CorrectAnswer": ["C", "F", "G"],
  "Explanation": "Application Root PDB定义应用结构、元数据、用户。它是克隆的主源 (Primary Source)\nApplication Seed PDB 是Application Root PDB的只读副本;是为了方便和快速创建新的应用 PDB而设计的模板\nAD.Application Root PDB完成安装或升级后，DBA 必须执行一个显式的命令（例如 ALTER PLUGGABLE DATABASE APPLICATION $APP_NAME SYNC）来更新Application Seed PDB，使其与Application Root PDB 保持一致\nB.DBA 可以先创建Application Container，然后在需要时，随时使用 CREATE PLUGGABLE DATABASE ... FROM ... 命令来创建（添加）Application Seed PDB\nE.Application Seed PDB 可以像任何其他PDB一样被删除 (DROP PLUGGABLE DATABASE)，只要确保在操作时关闭了Application Root PDB 即可\nCF.当一个新的Application PDB 从 Application Seed PDB 克隆出来后，它就成为了一个independent、READ WRITE的数据库,DBA 可以自由地在上面执行install或upgrade操作，包括安装一个旧版本或一个最新版本\nG.Application Seed PDB是可选的，它是为了 加快克隆速度而存在的，可以直接从Application Root PDB克隆"
},
{
  "QuestionID": 38,
  "QuestionType": "multiple",
  "QuestionText": "Examine this configuration:\n1. CDB1 is a container database.\n2. PDB1 and PDB2 are pluggable databases in CDB1.\n3. PDB1 and PDB2 are OPEN in READ WRITE mode.\n\nYou execute these commands successfully:\n$ export ORACLE_SID=CDB1\n$ sqlplus / as sysdba\nSQL> ALTER SESSION SET CONTAINER = PDB1;\nSession altered.\nSQL> SHUTDOWN IMMEDIATE\n\nWhich two are true? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Uncommitted transactions in PDB1 have been rolled back."},
    {"label": "B", "text": "PDB1 is closed."},
    {"label": "C", "text": "Uncommitted transactions in CDB1 and PDB1 have been rolled back."},
    {"label": "D", "text": "CDB1 is shut down."},
    {"label": "E", "text": "CDB1 is in MOUNT state"}
  ],
  "CorrectAnswer": ["A", "B"],
  "Explanation": "SHUTDOWN IMMEDIATE 只影响当前容器 PDB1。整个 CDB1 (Root) 和其他 PDB (PDB2) 继续运行。\nIMMEDIATE 关键字表示数据库会立即停止运行，并对所有未提交的活动事务执行 ROLLBACK (回滚) 操作"
},
{
  "QuestionID": 39,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about Automatic Workload Repository (AWR), Automatic Database Diagnostic Monitor (ADDM), and the Manageability Monitor (MMON) background process? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "ADDM can recommend shrinking the buffer cache."},
    {"label": "B", "text": "ADDM can recommend extending the buffer cache."},
    {"label": "C", "text": "By default, MMON creates an AWR snapshot every 30 minutes."},
    {"label": "D", "text": "ADDM performs its analysis only when a DBA requests it."},
    {"label": "E", "text": "By default, AWR snapshots are automatically purged after eight days."},
    {"label": "F", "text": "AWR snapshots must be deleted when no longer required by ADDM."}
  ],
  "CorrectAnswer": ["A", "B", "E"],
  "Explanation": "MMON进程(Manageability Monitor Process)负责自动收集性能统计信息并创建(Automatic Workload Repository)AWR Snapshot\n\nAWR snapshot是数据库性能数据在某个时间点的集合, 间隔（默认 1 小时，Retention Period默认8天\n\n(Automatic Database Diagnostic Monitor)ADDM基于 AWR 的数据，自动分析数据库性能问题\n\nD.ADDM是自动诊断监视器。它确实会在 MMON创建 AWR快照后自动运行，并根据新的数据进行分析\nF.AWR 快照的生命周期由 保留期 (Retention Policy) 决定（默认 8 天），而不是由 ADDM 是否完成分析来决定。快照的管理是独立的"
},
{
  "QuestionID": 40,
  "QuestionType": "multiple",
  "QuestionText": "Examine the command for creating pluggable database PDB2 in container database CDB2.\n\nCREATE PLUGGABLE DATABASE pdb2\nADMIN USER pdb2_adm\nIDENTIFIED BY 123pdb\nROLES = (CONNECT);\n\nSelect three options, any one of which is required for it to execute successfully. (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Add the FILE_NAME_CONVERT clause to the statement and set the PDB_FILE_NAME_CONVERT parameter."},
    {"label": "B", "text": "Add only the CREATE_FILE_DEST clause to the statement."},
    {"label": "C", "text": "Set only the PDB_FILE_NAME_CONVERT parameter."},
    {"label": "D", "text": "Set the PDB_FILE_NAME_CONVERT parameter and enable OMF."},
    {"label": "E", "text": "Enable only OMF."},
    {"label": "F", "text": "Add the FILE_NAME_CONVERT clause to the statement and enable Oracle Managed Files (OMF)."}
  ],
  "CorrectAnswer": ["B", "C", "E"],
  "Explanation": "CREATE PLUGGABLE DATABASE 命令缺少一个关键信息：新 PDB 数据文件的存放位置，要让该命令成功执行，数据库必须能够确定新数据文件的 位置 (Location) 和 名称 (Name)\n\nFILE_NAME_CONVERT = 在 SQL 语句里用的，一次性的路径替换。\nPDB_FILE_NAME_CONVERT = 参数，不写在 SQL 里，用一次设置长期使用\n\nA.FILE_NAME_CONVERT 和 PDB_FILE_NAME_CONVERT 只能二选一，不需要同时用\nC.PDB_FILE_NAME_CONVERT 参数是解决PDB克隆或创建时，文件路径转换问题的。如果该参数在 CDB 级别设置，它提供了一个“查找-替换”的规则，Oracle 会用这个规则来自动生成新 PDB 文件在磁盘上的位置和名称\nDF.开启 OMF 后不需要任何 file convert 参数,不能一起用"
},
{
  "QuestionID": 41,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about Recovery Manager (RMAN) diagnostic message output? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Media Management messages for SBT devices are always written to sbtio.log."},
    {"label": "B", "text": "RMAN error stacks should be read from the bottom up as that is the order in which errors are generated."},
    {"label": "C", "text": "RMAN error stacks should be read from the top down as that is the order in which errors are generated."},
    {"label": "D", "text": "The RMAN LOG command line clause causes output issued during RMAN command compilation to be written to a log file and to standard output."},
    {"label": "E", "text": "The RMAN LOG command line clause causes output issued during RMAN command compilation to be written to a log file only."},
    {"label": "F", "text": "Media Management messages for SBT devices are written to an Oracle trace file."}
  ],
  "CorrectAnswer": ["B", "E"],
  "Explanation": "Recovery Manager (RMAN) diagnostic message output:\n1.标准输出 (Standard Output):RMAN 客户端命令执行期间的输出默认显示在终端屏幕上,不会包含媒体管理器详细信息,只是普通运行信息\n\n2.日志文件 (Log File):LOG command line clause的输出写入日志文件,把屏幕所有输出复制到 log,不会包含 trace 里的内部诊断信息,不会包含媒体管理器SBT详细日志\n\n3.Oracle Trace File(.trc):RMAN 与 Oracle server process 的内部错误;RMAN错误堆栈stack trace(错误堆栈Error Stack从下往上阅读);SBT调用失败的错误码(高层错误写入trace，但不会写入媒体管理器的详细messages)\n\n4.介质管理软件输出Media Management Software Output:这些信息由第三方 SBT 软件（如 NetBackup, TSM 等）生成，用于记录与磁带库和介质通信的细节,写到 sbtio.log（或第三方 Media Manager 的自有日志,sbtio.log 不是绝对的“唯一”位置）;"
},
{
  "QuestionID": 42,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about managing memory components in an Oracle database instance? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "With Automatic Shared Memory Management, the database instance can increase the Large Pool size by reducing the Shared Pool size."},
    {"label": "B", "text": "With Automatic Memory Management, the database instance can increase the System Global Area size by reducing the Program Global Area size."},
    {"label": "C", "text": "Automatically tuned and resized System Global Area components will always revert to their initial sizes after an instance restart."},
    {"label": "D", "text": "Automatic Memory Management must be used together with locking the System Global Area into physical memory."},
    {"label": "E", "text": "With Automatic Shared Memory Management, the database instance can increase the Program Global Area size by reducing the System Global Area size."},
    {"label": "F", "text": "On Line Transaction Processing systems often use less Program Global Area than Decision Support Systems."}
  ],
  "CorrectAnswer": ["A", "B", "F"],
  "Explanation": "1.Automatic Memory Management:控制参数MEMORY_TARGET;最全面的管理模式。数据库在 SGA 和 PGA 之间动态分配内存，以满足当前工作负载需求。\n\n2.Automatic Shared Memory Management:控制参数SGA_TARGET;仅管理 SGA 的大小，允许 SGA 内部组件（如共享池、大池、缓冲区缓存）之间动态调整大小,PGA 仍需独立管理\n\nC.在 ASMM 或 AMM 模式下,SGA 组件（如共享池、缓冲区缓存）的实际大小在实例关闭时不会恢复到其初始值，它们会保留在 SPFILE/PFILE 中设置的 SGA_TARGET 或各个组件的最小/初始限制值\nD.锁定 SGA（使用 LOCK_SGA=TRUE）是可选的，用于防止 SGA 被交换到磁盘Swap Out，以提高性能，但它不是使用 AMM 的强制要求\nF.(On Line Transaction Processing)OLTP联机事务处理的特点是大量短小的事务，它们主要执行索引查找和简单的 DML 操作，因此对 PGA 中所需的排序区和哈希区等工作区需求较少;(Decision Support Systems)DSS决策支持系统的特点是执行复杂的查询，涉及大量的全表扫描、大型连接和聚合。这些操作需要大量的内存来进行排序Sort和哈希连接Hash Join，因此对 PGA 的工作区需求非常高"
},
{
  "QuestionID": 43,
  "QuestionType": "multiple",
  "QuestionText": "A database is configured in ARCHIVELOG mode. Full RMAN backups are taken daily and no backup to trace has been taken of the control file. A media failure has occurred. In which two scenarios is complete recovery possible? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "when any archived log from, before, or after the most recent backup is corrupt."},
    {"label": "B", "text": "after losing all copies of the control file"},
    {"label": "C", "text": "after losing an archived log from after the most recent backup"},
    {"label": "D", "text": "after losing an archived log from before the most recent backup"},
    {"label": "E", "text": "after losing the SYSTEM tablespace"}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "完整恢复Complete Recovery必须有:Control File;Data Files;Online Redo Logs;Archived Redo Logs"
},
{
  "QuestionID": 44,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about Database Point-in-Time Recovery? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The database must have FLASHBACK DATABASE ON to perform Database Point-in-Time Recovery."},
    {"label": "B", "text": "The database must be in MOUNT state when performing Database Point-in-Time Recovery."},
    {"label": "C", "text": "Database Point-in-Time Recovery is performed by the Managed Recovery Process (MRP)."},
    {"label": "D", "text": "The Database must be in ARCHIVELOG mode."},
    {"label": "E", "text": "The target point for the recovery must be specified as a time or System Change Number (SCN)."},
    {"label": "F", "text": "The database must be open RESETLOGS after Database Point-in-Time Recovery."}
  ],
  "CorrectAnswer": ["B", "D", "F"],
  "Explanation": "数据库时间点恢复(Database Point-in-Time Recovery)是一种不完整恢复（Incomplete Recovery）的形式，它将数据库恢复到过去的某个指定时间点、SCN 或日志序列号，通常用于从逻辑错误（如意外删除或更新数据）中恢复\n\nBDF.行数据库时间点恢复（DBPITR）时，数据库必须处于 MOUNT 状态。因为恢复过程需要访问控制文件和数据文件，但数据库不需要处于 OPEN 状态;时间点恢复依赖归档日志来回滚到指定时间点，因此数据库必须处于ARCHIVELOG 模式;时间点恢复属于不完全恢复，完成后必须使用 OPEN RESETLOGS 打开数据库，以重置日志序列，确保数据一致性\n\nA.DBPITR 是基于 RMAN 备份和归档日志的传统恢复方法。Flashback Database 是另一种快速恢复方法，它使用闪回日志Flashback Logs来实现，两者是不同的机制，DBPITR 不依赖于 Flashback\nC.(Managed Recovery Process)MRP 是 Data Guard 备用数据库用来自动应用归档日志的进程。在主数据库上执行 RMAN 的时间点恢复时，是由 服务器进程 (Server Process) 而不是 MRP 来执行日志应用\nE.除了时间和 SCN，恢复目标还可以通过 日志序列号（Log Sequence Number, LSN 或 Log Sequence#） 来指定。RMAN 提供了 UNTIL TIME, UNTIL SCN, 和 UNTIL SEQUENCE 三种指定目标点的方式"
},
{
  "QuestionID": 45,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about the SQL Tuning Advisor? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It checks each query being analyzed for stale statistics."},
    {"label": "B", "text": "It checks each query being analyzed for missing statistics."},
    {"label": "C", "text": "It only recommends syntactic changes to SQL statements."},
    {"label": "D", "text": "It can recommend semantic changes to SQL statements."},
    {"label": "E", "text": "It considers all SQL statements being analyzed by the advisor task as a group."},
    {"label": "F", "text": "It builds SQL profiles for each poorly performing SQL statement to prevent regressions."}
  ],
  "CorrectAnswer": ["A", "B", "D"],
  "Explanation": "SQL Tuning Advisor通常作为一个顾问任务 (Advisor Task) 运行:\n1.输入 (Input):DBA 或开发人员向顾问提供一个或多个需要分析的 SQL 语句。这些语句通常来自:\n--自动工作负载资料档案库 (AWR) 中的历史数据\n--SQL 调优集 (SQL Tuning Set, STS)\n--直接输入的 SQL 语句\n\n2.分析Analysis:顾问启动一个四阶段的综合分析:\n--统计信息分析Statistics Analysis:这是第一步，也是最重要的步骤之一\n--访问路径分析Access Path Analysis:检查索引的使用和效率\n--SQL 结构分析SQL Structure Analysis:检查 SQL 语句本身的写法\n--替代结构分析Alternative Structures Analysis建议创建物化视图或考虑分区方案\n\nE.SQL 优化顾问通常是针对单个或多个独立的 SQL 语句进行分析，并为每个语句提供独立的优化建议。将其视为一个整体组进行分析是 SQL 访问顾问SQL Access Advisor的特性，该顾问会分析工作负载Workload并推荐索引和物化视图的组合优化\nF.防止退化prevent regressions是 SQL 计划管理SQL Plan Management的主要功能"
},
{
  "QuestionID": 46,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about duplicating pluggable databases (PDBs) with RMAN? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Two or more PDBs can be duplicated with the same RMAN DUPLICATE command."},
    {"label": "B", "text": "All tablespaces belonging to a PDB must be duplicated when duplicating the PDB."},
    {"label": "C", "text": "The auxiliary instance is automatically created with ENABLE_PLUGGABLE_DATABASE = TRUE."},
    {"label": "D", "text": "A user with SYSDBA or SYSBKUP must use RMAN logged in to a PDB in order to duplicate it."},
    {"label": "E", "text": "CDB$ROOT and PDB$SEED are automatically duplicated if a PDB is duplicated."}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": "Target Instance：生产数据库实例\nAuxiliary Instance辅助实例（duplicate_db）= 临时实例 + RMAN 操作 + 克隆/恢复 + 不干扰生产\nB.RMAN 复制 PDB 时，默认会复制所有必要的表空间，但您可以使用 SKIP TABLESPACE 子句来排除某些非必要或临时性的表空间\nC.ENABLE_PLUGGABLE_DATABASE 是 CDB（Container Database）初始化参数,控制 是否允许创建 Pluggable Database（PDB）\nD.RMAN 复制操作必须在 CDB 级别（即连接到 CDB$ROOT）进行，以便管理整个 CDB 的数据文件和控制文件，而不能连接到单个 PDB 来发起复制操作\nE.使用 RMAN 复制一个或多个 PDB 时，RMAN 实际上执行的是一个克隆操作。它会创建一个新的容器数据库 (CDB) 来容纳复制的 PDB。为了使新的 CDB 能够正常工作，RMAN 会自动复制:CDB$ROOT:包含 CDB 的元数据和通用数据。PDB$SEED:用于未来创建新 PDB 的模板"
},{
  "QuestionID": 47,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about Rapid Home Provisioning (RHP), which has been available since Oracle 18c? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is an Oracle Database service."},
    {"label": "B", "text": "It can be used to deploy Oracle Database homes."},
    {"label": "C", "text": "It cannot be used to provision applications."},
    {"label": "D", "text": "It can be used to deploy Grid Infrastructure homes, including Oracle Restart."},
    {"label": "E", "text": "It cannot be used to provision middleware."},
    {"label": "F", "text": "It is an Oracle Grid Infrastructure service."}
  ],
  "CorrectAnswer": ["B", "D","F"],
  "Explanation": "Rapid Home Provisioning旨在实现 Oracle 软件（特别是数据库和网格基础设施）的集中式、标准化、快速部署和生命周期管理，它不是一个数据库实例，而是一个基础设施服务，它作为 Oracle Grid Infrastructure (GI) 的一部分运行;RHP 适用于管理拥有大量 Oracle 数据库安装的大型环境，通过集中管理黄金镜像Golden Images，将软件部署从繁琐、耗时的过程转变为快速、标准化的克隆操\n\nRHP 管理的对象:\n1.Software HomesOracle Database homes;\n2.Grid Infrastructure (GI) homes\n3.Oracle Engineered Systems Software:Exadata 等工程系统上的专用软件\n4.通用软件部署 (General Software Deployment):从 Oracle Database 19c/21c 开始，RHP 的功能已扩展，可以用于部署和管理通用软件(非 Oracle)应用程序和中间件的软件主目录。这个扩展功能打破了 RHP 仅限于 Oracle 软件的限制"
},
{
  "QuestionID": 48,
  "QuestionType": "multiple",
  "QuestionText": "Examine this configuration:\n1). CDB1 is a container database.\n2). COMMON_USER_PREFIX is C##.\n3). PDB1 is a pluggable database contained in CDB1.\n4). APP1_ROOT is an application container contained in CDB1.\n5). APP1_PDB1 is an application PDB contained in APP1_ROOT.\nYou execute these commands successfully:\nWhich two are true? (Choose two.)",
  "ImageURL": "images/Q48",
  "Options": [
    {"label": "A", "text": "APP1_USER1 can be created in PDB1."},
    {"label": "B", "text": "APP1_USER1 can be created in CDB1."},
    {"label": "C", "text": "APP1_USER1 can have different privileges in each Application PDB contained in APP1_ROOT."},
    {"label": "D", "text": "C##_APP_USER1 can be created in CDB1."},
    {"label": "E", "text": "P1_USER1 can be created in CDB1."},
    {"label": "F", "text": "C##_USER1 will have the same privileges and roles granted in all PDBs in CDB1."}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "Application Container一个特殊的 PDB，位于 CDB 之下,包含Application PDBs;\n\nApplication Container 就像一个软件的主模板。所有的租户Application PDBs使用同一个标准化的应用程序框架Application Root，但拥有各自隔离的业务数据\n\nCDB 解决了 Oracle 数据库管理和资源整合的问题。\n\nApplication Container 解决了 企业级应用软件的部署和生命周期管理（例如，只需在 Application Root 中打一次补丁，所有 Application PDB 都会自动更新）的问题\n\nA.相当于在PDB1里面又建了一个APP1_USER1,和app1_root里的APP1_USER1只是同名，没有关系\nB.Common User用户名必须以 C## 或 c## 开头。必须包含 CONTAINER=ALL (除非是隐式创建)\nC.APP1_USER1 作为一个Application Common User,appl_root 中授予给 APP1_USER1通用权限 (Common Privileges),APP1_USER1 在不同的应用 PDB 中，可以拥有的“不同”权限\nD.语法上可以，但是将一个应用用户命名为CDB通用用户 (C##APP_USER1) 并放在 CDB1 中，是错误的架构设计，因为它破坏了多租户和应用容器的隔离性和最小权限原则"
},
{
  "QuestionID": 49,
  "QuestionType": "multiple",
  "QuestionText": "Which two are facets of performance planning that should always be considered or implemented for an Oracle Database environment? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "defining primary keys for all tables to speed up all queries"},
    {"label": "B", "text": "using check constraints to speed up updates"},
    {"label": "C", "text": "defining foreign keys for all tables to speed up joins"},
    {"label": "D", "text": "the physical data model"},
    {"label": "E", "text": "the configuration of storage arrays"}
  ],
  "CorrectAnswer": ["D", "E"],
  "Explanation": "A.虽然主键（Primary Key）是关系完整性的基础，并会自动创建唯一索引，但并非所有表都需要主键（如纯粹的日志表），且一个查询的性能瓶颈很少只依赖于主键。过度创建或不恰当的索引反而会增加 DML（插入、更新、删除）的开销\nB.Check 约束的目的是保证数据的完整性，例如确保某一列的值在特定范围内。Check 约束在 更新 (Updates) 或 插入 (Inserts) 时需要进行额外的验证步骤，这通常会增加 DML 操作的开销，而不是加速它们\nC.外键（Foreign Key）的目的是维护参照完整性，确保子表中的数据引用了父表中存在的数据。外键本身不会直接加速 Join 操作；Join 的加速主要依赖于索引。在某些情况下，维护外键的完整性（例如，在父表上进行 DML 操作时检查子表）反而会增加开销\nD.物理数据模型定义了表的结构、数据类型、索引策略、分区策略 (Partitioning) 和关系。设计不佳的物理模型（如不恰当的数据类型、缺少关键索引、不合理的分区）将导致所有查询性能低下，无论硬件配置多好。这是进行 SQL 调优 和 索引优化 的前提\nE.数据库工作负载通常是 I/O 密集型的。存储阵列（Storage Arrays）的配置，包括 RAID 级别、磁盘类型（HDD vs. SSD vs. NVMe）和 存储网络带宽，直接决定了数据库的 IOPS (Input/Output Operations Per Second) 和吞吐量。如果存储配置是瓶颈，数据库的性能将受到严重限制，特别是对于大量数据读写的操作"
},
{
  "QuestionID": 50,
  "QuestionType": "multiple",
  "QuestionText": "Which three actions are performed by Database Upgrade Assistant (DBUA)? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It recompiles all stored PL/SQL code by using utlrp.sql."},
    {"label": "B", "text": "It empties the RECYCLE BIN."},
    {"label": "C", "text": "It performs prerequisite checks to verify if the Oracle database is ready for upgrade."},
    {"label": "D", "text": "It sets all user tablespaces to read-only before starting the upgrade."},
    {"label": "E", "text": "It removes the AUDSYS schema and the AUDIT_ADMIN and AUDIT_VIEWER roles."},
    {"label": "F", "text": "It increases tablespace size, if required, to meet upgrade requirements."}
  ],
  "CorrectAnswer": ["B", "C", "F"],
  "Explanation": "Database Upgrade Assistant (DBUA)是一个基于 Java 的图形用户界面（GUI）工具，它随 Oracle 数据库软件安装包一起提供，帮助 DBA 自动化、简化和指导整个 Oracle 数据库升级过程。它将复杂的命令行升级步骤（如运行各种脚本）封装在了一个易于操作的向导中\n\nDBUA 的功能涵盖了升级过程的三个关键阶段：准备、执行和后处理:\n--升级前的检查与准备 (Pre-Upgrade Checks):\n1.先决条件检查（Prerequisite Checks）： 这是 DBUA 最重要的功能之一。它会自动检查当前数据库环境，确保其满足新版本的所有要求\n2.创建还原点/备份： 允许您在升级前创建 Flashback Guarantee 还原点或提示您进行完整的数据库备份\n3.配置管理： 如果需要，它可以自动增加表空间大小（如 SYSAUX），以确保升级过程有足够的空间\n--升级的自动化执行 (Upgrade Execution):DBUA 会在后台执行所有必需的 SQL 脚本和操作，例如调用核心的 catupgrd.sql 脚本，将数据字典和内部组件升级到新版本\n--升级后的清理与优化 (Post-Upgrade Actions):\n1.重新编译无效对象:自动执行 utlrp.sql 脚本，重新编译所有无效的 PL/SQL 代码、视图和 Java 对象，确保应用程序在新版本下能够正常工作。\n2.时区文件更新： 检查并更新时区文件\n3.统计信息收集： 帮助收集新的或变化的系统统计信息，以优化新环境下的查询性能\n\nB.DBUA 会在升级前的检查和修复阶段主动清空回收站或提示用户进行清空\nD.DBUA 不会在升级前将用户表空间设置为只读。它主要关注于 SYSTEM 和 SYSAUX 表空间，并且用户表空间需要保持可写以便在升级过程中进行数据字典和元数据的更新\nE.AUDSYS 模式是 Oracle 数据库中统一审计功能的核心组成部分，不会在升级过程中被移除。恰恰相反，在从旧版本升级时，DBUA 会帮助迁移审计数据到新的统一审计系统"
},
{
  "QuestionID": 51,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about RMAN backups when using a media manager to write backups to tape when there are only two tape drives? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "SBT tape compression can be used even if no RMAN compression is configured."},
    {"label": "B", "text": "Any backup set written to the SBT device in this configuration can contain a maximum of two backup pieces."},
    {"label": "C", "text": "Any backup written to the SBT device in this configuration can contain a maximum of two backup sets."},
    {"label": "D", "text": "SBT tape compression and RMAN backup compression should be used in parallel."},
    {"label": "E", "text": "The SBT device should be configured to use PARALLELISM 2 to allow both tape drive to be used simultaneously."}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": "A.SBT (System Backup to Tape) 接口允许 Oracle RMAN 与第三方介质管理软件通信。SBT 介质管理器（例如 NetBackup, RMAN, Data Protector 等）通常在将数据写入物理磁带之前，可以在软件层面或通过磁带驱动器本身执行其自己的压缩（SBT 压缩）。这种压缩独立于 RMAN 内部配置的压缩\nB.备份集 (BACKUP SET) 的大小和数量与 PARALLELISM 或磁带驱动器的数量无关。一个备份集可以包含一个或多个备份片 (BACKUP PIECES)，备份片的数量仅受备份集内容和 MAXPIECESIZE 参数限制\nC.RMAN 在一次备份操作中创建的备份集数量仅受要备份的数据量和备份命令（如 SECTION SIZE、FILES_PER_SET）的控制，与可用的并行度或驱动器数量无关\nD.同时启用 RMAN压缩和磁带压缩可能导致冗余处理，降低效率，通常不建议同时使用。"
},
{
  "QuestionID": 52,
  "QuestionType": "multiple",
  "QuestionText": "You plan to install Oracle Grid Infrastructure for a Standalone Server and Oracle Database for the first time on a server. Examine this command and its outcome:\n\n# id oracle\nuid=54321 (oracle) gid=54321(oinstall) groups=54321 (oinstall), 54322 (dba)\n\nWhich two are true? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "oracle will be an owner of the Oracle Inventory."},
    {"label": "B", "text": "oracle must be the owner of every Oracle Database installation."},
    {"label": "C", "text": "oracle can own an Oracle Database installation but not an Oracle Grid Infrastructure installation."},
    {"label": "D", "text": "oracle will be granted the SYSASM privilege when installing the Oracle Database software."},
    {"label": "E", "text": "The user account, oracle, and group, oinstall, can be used for all Oracle software installations."}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": "A.Oracle Inventory（存储所有 Oracle 软件安装信息的中央目录）由安装第一个 Oracle 软件的用户账户拥有。在 Linux/Unix 环境中，这个用户的主组通常是 oinstall。由于用户 oracle 的主组是 oinstall，并且它是第一个安装的用户，因此它将拥有这个 Inventory\nB.通常使用不同的操作系统用户来分别拥有 Grid Infrastructure（如 grid 用户）和 Oracle Database（如 oracle 用户），以实现权限分离和最小权限原则。因此，它不是“必须”\nC.在单实例服务器上，允许使用同一个 oracle 用户来拥有 Grid Infrastructure (GI) 和 Database 软件。只有在安装 RAC (Real Application Clusters) 时，才要求使用独立的 grid 操作系统用户来安装 GI 软件\nD.SYSASM 权限是在数据库实例连接到 ASM 实例时，由 ASM 实例授予的，而不是在安装 Database 软件时授予的。 该权限由 Grid Infrastructure 的安装用户（或者说，由该用户所在的 OS 组）来行使\nE.在单实例（Standalone Server）环境中，标准做法是使用一个安装所有 Oracle 软件的统一用户。oinstall 组是 Oracle Inventory Group，它用于创建和管理 Oracle 安装的共享文件权限。oracle 用户是 Oracle Software Owner，用于执行 Grid Infrastructure 和 Database 的安装。这个用户和组的组合是用于安装所有 Oracle 软件的标准配置"
},
{
  "QuestionID": 53,
  "QuestionType": "single",
  "QuestionText": "Examine this configuration:\n1. CDB1 is a container database running in ARCHIVELOG mode.\n2. Controlfiles of CDB1 are multiplexed in '/u01/app/oracle/oradata/CDB1/controlfile/controlfile01.ctl' \nand '/u02/app/oracle/fast_recover_area/cdb1/CDB1/controlfile02.ctl'.\n3. The only backup of CDB1 was taken when CONTROLFILE AUTOBACKUP was OFF.\n4. SNAPSHOT CONTROLFILE NAME is '/u01/app/oracle/product/12.2.0.1/db_1/dbs/snapcf_cdb1.f'.\n\nWhile CDB1 is open, '/u02/app/oracle/fast_recover_area/cdb1/CDB1/controlfile02.ctl' is accidentally deleted. To recover from this critical failure, you execute these commands:\n$ rman target sys/oracle_4U@localhost:1521/cdb1\nRMAN> SHUTDOWN ABORT\n...\n\nOracle instance shut down\n\nRMAN> STARTUP NOMOUNT\nRMAN> RESTORE CONTROLFILE FROM '/u01/app/oracle/oradata/CDB1/controlfile/controlfile01.ctl'\n\nWhat will be the outcome? (Choose one.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It will create '$ORACLE_HOME/dbs/cdb1/CDB1/controlfile02.ctl'"},
    {"label": "B", "text": "It will create '/u01/app/oralce/oradata/CDB1/controlfile/controlfile02.ctl'"},
    {"label": "C", "text": "It will re-create '/u02/app/oracle/fast_recover_area/cdb1/CDB1/controlfile02.ctl'"},
    {"label": "D", "text": "It will create '/u01/app/oracle/product/12.2.0.1/db_1/dbs/snapcf_cdb1control02.ctl'"},
    {"label": "E", "text": "It will fail because there is no autobackup of the controlfiles."}
  ],
  "CorrectAnswer": ["C"],
  "Explanation": "故障:数据库正在运行（CDB1 is open）时，一个控制文件副本 /u02/app/oracle/...controlfile02.ctl 被意外删除\n操作:实例被中止 (SHUTDOWN ABORT)，然后以不加载模式启动 (STARTUP NOMOUNT)。\n恢复命令:RMAN> RESTORE CONTROLFILE FROM '/u01/app/oracle/oradata/CDB1/controlfile/controlfile01.ctl\n\nABD.RMAN 在使用 RESTORE CONTROLFILE 时，默认的目的是恢复到原始位置，而不是创建新的、名称不同的文件，除非使用 SET CONTROLFILE AUTOBACKUP FORMAT 或 RESTORE CONTROLFILE TO '新路径' 显式指定\nE.失败的前提是 RMAN 无法找到任何可用的控制文件。但在这个场景中，RMAN 被明确告知从 /u01/app/oracle/oradata/CDB1/controlfile/controlfile01.ctl（一个完好的、在线的副本）进行恢复，所以它不会失败"
},
{
  "QuestionID": 54,
  "QuestionType": "single",
  "QuestionText": "Examine these actions:\n1). Create a new database for a recovery catalog.\n2). Create a tablespace with sufficient space in the catalog database for the recovery catalog.\n3). Configure ARCHIVELOG mode for the catalog database.\n4). Create a user to own the recovery catalog schema with quota on the tablespace that will contain the catalog.\n5). Grant the RECOVERY_CATALOG_OWNER role to the recovery catalog schema owner.\n6). Grant the SYSBACKUP privilege to the recovery catalog schema owner.\n\nWhich are the minimum actions that must be performed before executing the CREATE CATALOG command?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "2, 4, 5, 6"},
    {"label": "B", "text": "1, 2, 3, 4, 5, 6"},
    {"label": "C", "text": "1, 2, 4, 5"},
    {"label": "D", "text": "2, 4, 5"},
    {"label": "E", "text": "1, 3, 4, 5"}
  ],
  "CorrectAnswer": ["D"],
  "Explanation": "1.你可以使用已有的数据库作为 Catalog，只要有空间和权限即可，并非强制要求新建数据库\n2.Recovery Catalog 需要一个表空间存储 RC_* 表,没有表空间，无法创建表，自然无法执行 CREATE CATALOG\n3.目录数据库不要求必须是 ARCHIVELOG 模式,ARCHIVELOG 只是保证 Catalog 数据库可恢复性，提高安全性\n4.必须有一个 schema/user 来存储 RMAN Catalog 对象,并且用户需要在表空间上有足够配额\n5.这是创建 Catalog 的核心权限,RECOVERY_CATALOG_OWNER 是一个预定义的角色，它包含创建和维护恢复目录所需的所有权限（例如 CREATE TABLE、CREATE SEQUENCE 等）。没有这个角色，目录所有者用户就无法执行 CREATE CATALOG\n6.SYSBACKUP 权限是授予连接到目标数据库（被备份数据库）的 RMAN 操作员用户的，以便他们可以执行备份和恢复操作。与 CREATE CATALOG 本身无关"
},
{
  "QuestionID": 55,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about creating pluggable databases (PDBs) using snapshots in Oracle 19c and later releases? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A PDB snapshot is always a full copy of the source PDB."},
    {"label": "B", "text": "A PDB snapshot is always a sparse copy of the source PDB."},
    {"label": "C", "text": "A snapshot copy PDB depends on a storage snapshot which can only be stored on specific file systems."},
    {"label": "D", "text": "A PDB snapshot depends on a storage snapshot which can be stored on any file system."},
    {"label": "E", "text": "A PDB snapshot depends on a storage snapshot which can only be stored on specific file systems."},
    {"label": "F", "text": "A snapshot copy PDB depends on a storage snapshot which can be stored on any file system."},
    {"label": "G", "text": "A snapshot copy PDB can be created from a stand-alone clone PDB."}
  ],
  "CorrectAnswer": ["C", "G"],
  "Explanation": "CF.快照拷贝 PDB 是一种存储效率很高、创建速度极快的 PDB 副本，但这种效率是通过利用底层文件系统提供的存储快照技术来实现的。不能在任何普通的文件系统上创建这种快照 PDB，而必须使用那些能够提供块级快照和写时复制功能的 特定文件系统（如 Oracle ACFS）作为数据文件的存储介质\nEF.PDB Snapshot依赖于它的源PDB (PDB Source)\n立克隆 PDB (Stand-Alone Clone PDB) 是 Oracle 多租户架构中克隆操作的一种类型，它指的是从一个源 PDB 创建一个完全独立、自给自足的副本;只要克隆 PDB 处于可写状态（READ WRITE 模式），即可基于其创建快照复制PDB"
},
{
  "QuestionID": 56,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about Oracle Database Configuration Assistant (DBCA) templates? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The General Purpose or Transaction Processing templates are most suitable when concurrency and recoverability are key criteria."},
    {"label": "B", "text": "Oracle DBCA templates can store only logical structure and not database files."},
    {"label": "C", "text": "New templates can only be created by modifying an existing user-created template."},
    {"label": "D", "text": "The Data Warehouse template is most suitable when transaction response time is the key criterion."},
    {"label": "E", "text": "Oracle DBCA templates can be used to create new databases and duplicate existing databases."}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": "A.事务处理模板 (Transaction Processing templates) 或称为 通用目的模板 (General Purpose templates)，其设计目标就是为了支持 高并发 (Concurrency) 和 可恢复性 (Recoverability) 的工作负载，也就是典型的 OLTP (Online Transaction Processing) 环境\nB.DBCA 模板主要分为两大类:1.结构模板Structural Templates:仅包含数据库的逻辑结构和配置信息;2.种子文件模板 (Seed File Templates):包含逻辑结构 以及 一个或多个数据文件（称为种子文件）\nD.数据仓库模板Data Warehouse template追求的是复杂查询的整体完成速度和数据分析的效率,如果应用要求：处理复杂的分析型查询。需要快速扫描和聚合大量数据\n如果 事务响应时间 是关键标准，应该选择事务处理Transaction Processing或 通用目的General Purpose模板"
},
{
  "QuestionID": 57,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true? (Choose two.)",
  "ImageURL": "images/Q57.png",
  "Options": [
    {"label": "A", "text": "The CONTAINERS clause cannot be used in queries on the REVENUE table."},
    {"label": "B", "text": "The REVENUE table must be a list-partitioned table."},
    {"label": "C", "text": "The MAPTABLE tables defines a logical partition key on a commonly used column for the REVENUE table."},
    {"label": "D", "text": "The MAPTABLE table is a metadata-linked table."},
    {"label": "E", "text": "A container map exists for the REVENUE table, but is not enabled."},
    {"label": "F", "text": "The REVENUE table partitions are not pruned across the PDBs automatically."}
  ],
  "CorrectAnswer": ["C", "F"],
  "Explanation": "应用通用表Application Common Table自动存在于所有的子PDB中\n\n应用通用表的数据存储有两种常见模式:\n1.元数据链接 Metadata-Linked所有PDB共享同一份数据. 存储在根容器中，子PDB通过链接访问数据. CONTAINERS_DEFAULT = YES;\n2.数据链接Data-Linked每个 PDB 存储自己的数据. 结构共享，但数据文件独立,CONTAINERS_DEFAULT = NO\n容器映射表 (Container Map Table)告诉 Oracle：哪些 PDB 有这个表的数据 → Oracle 只去这些 PDB 查，从而大幅提高跨容器查询性能。\n在 CDB Root 执行一个跨容器查询 (SELECT ... FROM CONTAINERS(FIN.REVENUE)) 时，它会去扫描所有 PDB 中的 REVENUE 表。为了避免扫描不必要的 PDB，Oracle 使用容器 ID (PDB ID) 作为隐式的分区键\n\nC.MAPTABLE（容器映射表）是容器映射分区的核心。它存储了 PDB ID 到分区键的映射。这个分区键是一个逻辑分区列，比如 PDB_ID，Oracle 利用这个逻辑列来组织和访问跨 PDB 的数据\nF.分区修剪Partition Pruning是提高分区表查询性能的关键技术。如果一个跨容器查询带有 PDB ID 的筛选条件（例如 WHERE con_id = 3），数据库需要知道哪些 PDB 包含这些数据，从而只扫描那些 PDB,这个优化功能由 CONTAINER_MAP_OBJECT 字段控制。CONTAINER_MAP_OBJECT 是 NO，表明自动的分区修剪功能没有启用，因此查询会扫描不必要的 PDB，性能会下降\n\nA.只要用户有权限，任何应用通用表都可以在 CDB Root 中使用 CONTAINERS 子句进行查询（例如 SELECT * FROM CONTAINERS(FIN.REVENUE)），因为它是应用容器中的通用对象\nB.虽然容器映射分区在概念上类似于列表分区，但它是一个内部的、由 Oracle 管理的分区类型。它不要求该表必须是 DBA 手动创建的列表分区表\nC.当 CONTAINER_MAP 字段显示 YES 时，表明 REVENUE 表使用了 容器映射分区 (Container Map Partitioning) 特性。容器映射分区允许 Oracle 自动根据 PDB ID (Container ID) 对数据进行分区。这要求创建一个容器映射表（在这里是 MAPTABLE），它定义了 PDB ID 到分区键的映射。这个分区键是 REVENUE 表上用于分区的一个逻辑列\nE.CONTAINER_MAP 字段显示为 YES，这意味着容器映射特性已启用。"
},
{
  "QuestionID": 58,
  "QuestionType": "multiple",
  "QuestionText": "Your container database, CDB1, has an application container, HR_ROOT, with an application PDB, HR_PDB1. You have the required privilege to clone HR_PDB1 to container database CDB2, which does not contain HR_ROOT. Which two are always true? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "CDB1 and CDB2 must be in shared undo mode."},
    {"label": "B", "text": "A common user must exist in CDB2 with the CREATE PLUGGABLE DATABASE privilege."},
    {"label": "C", "text": "All transactions in HR_PDB1 of CDB1 must commit before the cloning process starts."},
    {"label": "D", "text": "Cloning HR_ROOT automatically clones HR_PDB1."},
    {"label": "E", "text": "The HR_PDB1 clone created in CDB2 will be in mount state when cloning ends."}
  ],
  "CorrectAnswer": ["B", "E"],
  "Explanation": "A.共享撤销模式Shared Undo Mode并且不是 PDB 跨 CDB 克隆的硬性先决条件。PDB 克隆可以发生在配置了本地撤销（Local Undo Mode，现在是默认模式）或共享撤销模式的 CDB 之间\nB.要将任何 PDB（无论是普通 PDB 还是应用 PDB）克隆到另一个 CDB,需要以一个能够执行克隆操作的用户身份登录到目标 CDB2。权限要求:该用户必须拥有 CREATE PLUGGABLE DATABASE 权限。在目标 CDB 中执行此操作的用户必须是 通用用户 (Common User)（例如 SYS 或其他具有 C## 前缀的管理用户）\nC.RMAN 的克隆操作使用的是热备份Hot Backup或在线克隆技术。它通过在数据库运行期间获取数据文件的副本，并使用归档日志 (Archive Logs) 或 Redo Log 来处理克隆过程中未提交或正在进行的事务,不需要强制要求所有事务提交或将 PDB 置于只读模式\nD.可以将 HR_ROOT作为一个整体进行克隆，也可以只克隆其下的子 PDB HR_PDB1。克隆 HR_ROOT 并不意味着克隆所有的子 PDB,需要明确指定要克隆的对象。在这个场景中，是直接克隆了 HR_PDB1，而不是克隆整个应用容器根。\nE.当一个新的 PDB 被创建（通过克隆、插拔或恢复）后，它首先被置于 MOUNT状态。在 MOUNT 状态下，需要执行 ALTER PLUGGABLE DATABASE OPEN READ WRITE; 命令，并可能触发恢复或同步操作，之后才能被打开供读写使用"
},
{
  "QuestionID": 59,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about backup, restore, and recovery operations done without using Recovery Manager (RMAN)? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Backing up a database in NOARCHIVELOG mode using O/S utilities requires that the database instance be started and the database be in the MOUNT state."},
    {"label": "B", "text": "Backing up a database in ARCHIVELOG mode using O/S utilities requires that the database instance be started and the database be in MOUNT state."},
    {"label": "C", "text": "An Oracle database can be restored from backup files copied using O/S utilities."},
    {"label": "D", "text": "Oracle data file backups, copied using an O/S utility, can be added to the RMAN catalog as IMAGE COPIES."},
    {"label": "E", "text": "Backing up a database in NOARCHIVELOG mode using O/S utilities requires that the database instance be shut down."},
    {"label": "F", "text": "Oracle archive log backups, copied using an O/S utility, can be added to the RMAN catalog as a backup set."},
    {"label": "G", "text": "Backing up a database in ARCHIVELOG mode using O/S utilities requires that the database instance be started and the database be in OPEN state."}
  ],
  "CorrectAnswer": ["C", "D", "E"],
  "Explanation": "不使用 RMAN，而是使用 操作系统实用程序（O/S Utility） 进行数据库备份，也就是常说的 用户管理备份 (User-Managed Backup)\n--NOARCHIVELOG模式,数据库必须处于 SHUTDOWN 状态,必须先执行 SHUTDOWN IMMEDIATE 或 SHUTDOWN NORMAL，然后复制所有数据文件、控制文件和初始化参数文件。\n--ARCHIVELOG 模式下,数据库可以处于 OPEN 状态,备份前需对表空间执行 ALTER TABLESPACE ... BEGIN BACKUP;，复制完文件后执行 END BACKUP;。必须同时备份所有相关的归档日志。\nD.RMAN 的 image copy（镜像副本） 本质上就是：数据文件的逐块物理复制，没有压缩、没有格式化、没有改变结构。用 O/S copy 复制一个 datafile和 RMAN 做的 image copy 本质上一样,所以 RMAN 可以识别并 catalog\nF.RMAN 的 backup set 是 RMAN 逻辑容器，里面记录了元数据、通道信息、备份片信息等。单纯的 O/S 拷贝归档日志，RMAN 无法将其认作 backup set\nG.ARCHIVELOG 模式下，可以shutdown数据库"
},
{
  "QuestionID": 60,
  "QuestionType": "multiple",
  "QuestionText": "Examine this configuration:\n1). CDB1 is a container database.\n2). PDB1 and PDB2 are pluggable databases in CDB1.\nYou execute these commands successfully:\n$ export ORACLE_SID=cdb1\n$ sqlplus / as sysdba\nSQL> SHUTDOWN IMMEDIATE\nOracle instance shut down.\nSQL> STARTUP MOUNT\nDatabase mounted.\n\nWhich two are true? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "PDB1 and PDB2 are in MOUNT state."},
    {"label": "B", "text": "Redo logs are opened."},
    {"label": "C", "text": "PDB1 and PDB2 are in READ ONLY state."},
    {"label": "D", "text": "CDB$ROOT is in MOUNT state."},
    {"label": "E", "text": "PDB$SEED is in READ ONLY state."}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": "CDB$ROOT是 Mount状态,所有的 PDB及 PDB$seed也是 Mount状态"
},
{
  "QuestionID": 61,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about upgrading Oracle Grid Infrastructure? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A direct upgrade can be performed only from the immediately preceding Oracle Grid Infrastructure version."},
    {"label": "B", "text": "The newer version is installed in a separate Oracle Grid Infrastructure home on the same server as the existing version."},
    {"label": "C", "text": "An existing Oracle base can be used."},
    {"label": "D", "text": "The upgrade process will automatically install all mandatory patches for the current version of Oracle Grid Infrastructure."},
    {"label": "E", "text": "Existing Oracle Database instances must be shut down before starting the upgrade."},
    {"label": "F", "text": "Only the grid user can perform the upgrade."}
  ],
  "CorrectAnswer": ["B", "C", "E"],
  "Explanation": "A.Oracle 允许从多个旧版本（例如，从 12.2 或 18c）直接升级到 19c 或更高版本。通常，只要在支持的升级路径内，不一定必须是紧邻的上一个版本\nC.Oracle Base是 Oracle 软件安装时最基础、最顶层的目录，用来放所有 Oracle 产品的文件、日志、诊断信息等\nORACLE_BASE 是整个 Oracle 的根目录\nORACLE_HOME 是具体版本的安装目录\nD.升级过程只会安装基础版本软件。您仍需要单独下载并应用最新的 Release Updates (RU)、Release Update Revisions (RUR) 以及任何必要的强制补丁Mandatory Patches"
},
{
  "QuestionID": 62,
  "QuestionType": "multiple",
  "QuestionText": "A database is configured in ARCHIVELOG mode.\nA full RMAN backup exists but no control file backup to trace has been taken.\nA media failure has occurred.\nIn which two scenarios is incomplete recovery required? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "after losing a SYSAUX tablespace data file"},
    {"label": "B", "text": "after losing all members of an INACTIVE online redo log group"},
    {"label": "C", "text": "after losing all members of the CURRENT online redo log group"},
    {"label": "D", "text": "after losing all copies of the control file"},
    {"label": "E", "text": "after losing an UNDO tablespace that is in use"}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": "完全恢复Complete Recovery:\n1.目标:将数据库恢复到故障发生时的确切时间点/SCN\n2.何时使用:当所有必需的归档日志和在线重做日志都可用，并且可以应用到最后一条重做记录时\n3.核心场景:\n--丢失非 SYSTEM 表空间的数据文件。\n--丢失所有 INACTIVE 在线重做日志成员\n--丢失 SYSTEM 或其他重要文件，但所有重做日志都可用\n--数据库崩溃（实例恢复\n4.打开方式:使用 ALTER DATABASE OPEN; 正常打开数据库\n5.日志序列:保持不变,旧备份仍然有效，可用于未来恢复\n\n不完全恢复Incomplete Recovery:\n1.目标:将数据库恢复到故障发生之前的某个时间点、SCN 或日志序列\n2.何时使用:当无法应用所有必需的重做日志时，或者需要回退人为错误时。\n3.核心场景:\n--丢失所有 CURRENT 在线重做日志成员\n--丢失所有控制文件副本（从备份恢复控制文件）\n--丢人为错误或逻辑损坏（需要回退事务）\n4.打开方式:必须使用 ALTER DATABASE OPEN RESETLOGS; 打开数据库。\n5.重置日志序列，创建新的数据库世代，在 RESETLOGS 之前创建的所有备份失效"
},
{
  "QuestionID": 63,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about instance recovery? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is not possible if an archived log is missing."},
    {"label": "B", "text": "It is performed automatically after the database is opened; however, blocks requiring recovery are not available until they are recovered."},
    {"label": "C", "text": "Setting FAST_START_MTTR_TARGET to a lower value reduces instance recovery time by causing dirty buffers to be written to disk more frequently, thereby reducing the number of I/Os needed during instance recovery."},
    {"label": "D", "text": "It is performed by the Recovery Writer (RVWR) background process."},
    {"label": "E", "text": "Setting FAST_START_MTTR_TARGET to a higher value reduces instance recovery time by causing the log writer to write more frequently, thereby reducing the number of I/Os needed during instance recovery."},
    {"label": "F", "text": "It is performed automatically while the database remains in MOUNT state. Then the database is opened."}
  ],
  "CorrectAnswer": ["C", "F"],
  "Explanation": "实例恢复 (Instance Recovery)是 Oracle 数据库用于保证数据一致性的自动机制\n\n实例恢复在数据库启动过程中，从 NOMOUNT 状态转换到 MOUNT 状态之后，在尝试执行 ALTER DATABASE OPEN 命令时自动开始。它在数据库进入 OPEN 状态之前完成\n\n实例恢复主要由 SMON (System Monitor) 后台进程执行\n\n实例恢复只需要在线重做日志。它不需要归档日志（Archived Logs），归档日志是用于介质恢复 (Media Recovery) 的\n\nFAST_START_MTTR_TARGET 是一个初始化参数，用于控制实例恢复所需的时间\nMTTR = Mean Time To Recover平均恢复时间。该参数允许 DBA 设置一个目标时间（以秒为单位，例如 300 秒），数据库会尽力将实例恢复时间控制在这个范围内为了达到这个目标，Oracle 会动态调整检查点 (Checkpoint) 的频率和程度。\n检查点的作用是强制 DBWn (Database Writer) 进程将脏缓冲区（内存中已修改但尚未写入磁盘的数据块）写入数据文件。检查点完成后，该检查点之前的重做记录就不再需要用于实例恢复了\n\nFAST_START_MTTR_TARGET 设置较低的值 (如 30 秒):缩短恢复时间,更频繁地触发检查点,减少了自上次检查点以来需要在恢复时读取和应用重做日志的 I/O 量，从而加快恢复速度\n\nFAST_START_MTTR_TARGET 设置较高的值 (如 1800 秒):容忍更长的恢复时间;减少检查点的频率;减少了正常的数据库运行时 I/O 负担，但如果发生崩溃，实例恢复时间会更长。\n\n介质恢复Media Recovery是指从备份中恢复数据文件后，应用归档重做日志 (Archived Redo Logs)，将数据文件前滚到所需时间点（通常是故障发生时的 SCN）\n\n实例恢复处理的是内存中数据丢失（崩溃），使用在线重做日志。\n\n介质恢复处理的是磁盘上数据丢失（损坏），使用备份和归档日志。"
},
{
  "QuestionID": 64,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about Oracle Optimizer Statistics, their use, and their collection? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The number of table rows is considered when evaluating the cost of accessing a table using an index."},
    {"label": "B", "text": "Index balanced B*Tree height is considered when evaluating the cost of using an index."},
    {"label": "C", "text": "The Statistics Advisor can help recommend the best way to gather statistics."},
    {"label": "D", "text": "Statistics collected using DBMS_STATS always yield the best optimizer result."},
    {"label": "E", "text": "The Statistics Advisor generates actions for all recommendations."}
  ],
  "CorrectAnswer": ["B", "C"],
  "Explanation": "优化器统计信息 (Optimizer Statistics)是 Oracle 数据库用来描述数据库中数据和对象属性的一组元数据\nOptimizer Statistics种类:\n1.对象统计信息 (Object Statistics)描述数据库对象（表、索引、列、分区等）的数据分布和物理属性\n--行数 (NUM_ROWS);块数 (BLOCKS);平均行长 (AVG_ROW_LEN) → 估算全表扫描的成本，以及连接操作的基数\n--唯一值数量 (NUM_DISTINCT);空值数量 (NUM_NULLS);最大/最小值;直方图 (Histogram)→ 估算查询谓词（WHERE 子句）的选择性 (Selectivity)，即返回的行占总行数的比例。\n--索引块数;B*Tree HEIGHT;叶块数 LEAF_BLOCKS;聚簇因子Clustering Factor→ 估算索引扫描所需的 I/O 次数和效率。特别是B*Tree HEIGHT，直接决定了索引访问的成本\n2.系统统计信息 (System Statistics)描述数据库运行环境的性能特征，特别是 I/O 和 CPU 的能力;确保优化器在计算 I/O 成本和 CPU 成本时，能准确反映真实系统的硬件能力\n\n基于成本的优化器 (Cost-Based Optimizer, CBO)用来估算不同 SQL 执行计划的成本 (Cost)，从而选择出成本最低、执行效率最高的那个计划\n\n索引聚簇因子Index Clustering Factor, CF衡量表里行的物理存储顺序与索引键顺序的一致性。CF 越低（越接近表块数），说明数据与索引键顺序较一致，索引范围扫描时 I/O 效率越高;CF 越高（接近行数），说明数据分布比较分散，索引扫描时可能要大量随机 I/O\n\nB.索引的叶块数 + B‑tree 层级 → 决定访问索引本身需要多少 I/O (查索引)\n\nB*Tree 高度 (Height)表示从索引的根块 (Root Block) 到最深处的叶块 (Leaf Block) 所需的逻辑 I/O 次数（即中间层块的数量 + 根块）\n\n叶块数 (Leaf Blocks) 统计信息表示构成索引叶子层 (Leaf Level) 的数据块的总数量\n\nOptimizer Statistics Advisor（Oracle Database 里的 “统计顾问”）。它是 Oracle 内建工具，用来分析当前统计信息收集策略和收集结果的质量;它只负责分析现有统计实践 + 建议更好的统计收集策略\n\nD.过时的或不准确的统计信息可能会导致优化器选择错误的执行计划;在某些复杂场景中，DBA 可能需要手动干预或使用动态采样 (Dynamic Sampling) 来辅助优化"
},
{
  "QuestionID": 65,
  "QuestionType": "multiple",
  "QuestionText": "A container database (CDB) contains two pluggable databases PDB1 and PDB2.\nThe LOCAL_UNDO_ENABLED database property is set to FALSE in the CDB.\nData file 24 of PDB2 was deleted and you need to restore and recover it.\nThe only RMAN backup that exists was created with the BACKUP DATABASE command while connected to CDB$ROOT.\nWhich three are true? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Data file 24 can be recovered only while connected to PDB2."},
    {"label": "B", "text": "Data file 24 can be restored and recovered while connected to CDB$ROOT."},
    {"label": "C", "text": "Data file 24 can be restored only while connected to CDB$ROOT."},
    {"label": "D", "text": "Data file 24 can be restored only while connected to PDB2."},
    {"label": "E", "text": "Data file 24 can be recovered while connected to PDB2."},
    {"label": "F", "text": "Data file 24 can be recovered while connected to CDB$ROOT."}
  ],
  "CorrectAnswer": ["B", "E", "F"],
  "Explanation": "RESTORE:重建物理文件;是将数据文件从备份集中复制到其位置的过程\nRECOVER(介质恢复):更新文件数据;是应用归档重做日志（或在线重做日志）将数据文件前滚到最新状态的过程。\n\n在处理介质故障（如数据文件损坏或丢失）时：\n--文件不存在或损坏 → 必须 RESTORE + RECOVER。\n--文件存在但滞后 → 只需要 RECOVER。\n在处理实例崩溃（如断电）时:不需要 DBA 干预，数据库在启动时自动执行实例恢复，不需要 RESTORE 或手动 RECOVER。\n\nAEF.重做日志是 CDB 级别的，包含 CDB 中所有 PDB 的更改。CDB$ROOT 拥有全局权限，因此可以执行 CDB 中任何文件的介质恢复;PDB 本身也拥有管理其自己的数据文件的权限，并且可以请求 CDB 应用所需的重做日志，因此可以在 PDB 级别执行介质恢复。"
},
{
  "QuestionID": 66,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about data movement between a non-CDB and a PDB using Data Pump? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Tablespaces are automatically created as needed while importing full exports in either a non-CDB or a PDB."},
    {"label": "B", "text": "Oracle attempts to convert conventional database users to local users when moving schemas from a non-CDB to a PDB."},
    {"label": "C", "text": "A new PDB is automatically created when importing a non-CDB into a CDB."},
    {"label": "D", "text": "Oracle attempts to convert common users to conventional users when moving schemas from a PDB to a non-CDB."},
    {"label": "E", "text": "Moving data from a PDB to a non-CDB is only possible by using transportable tablespace export and import."},
    {"label": "F", "text": "Moving data from a non-CDB to a PDB is only possible by using conventional export and import."}
  ],
  "CorrectAnswer": ["B", "D"],
  "Explanation": "A.Oracle Data Pump不会自动创建目标数据库中不存在的表空间。\nC.Data Pump的导入操作不会自动创建新的 PDB。您必须手动创建一个 PDB，然后将 Non-CDB 的数据导入到该 PDB 中\nD.当使用 Data Pump 将数据从 PDB 导出时，导出的用户数据包含 本地用户 和该 PDB 的 通用用户。当将此数据导入到 Non-CDB 时：Non-CDB 不支持 通用用户 (C##) 命名规则。Data Pump 在尝试导入通用用户时，会尝试删除 C## 前缀。如果删除前缀后的用户名在 Non-CDB 中不存在且合法，Data Pump 就会创建一个传统的数据库用户。\n\n在 CDB 和 Non-CDB 之间移动数据有多种方法，包括：\n1.传统 Data Pump 导出/导入 (Conventional Data Pump Export/Import)：使用 SCHEMA 或 FULL 模式导出和导入数据文件。\n2.可传输表空间 (Transportable Tablespaces, TTS)：将表空间作为数据文件移动，通常速度更快，尤其适用于大型数据库。\n3.克隆/插拔操作 (PDB Plug/Unplug)：将 Non-CDB 转换为 PDB，或在 CDB 之间移动 PDB（这是最高效的整体迁移方式，但不是仅 Data Pump 的方法）。"
},
{
  "QuestionID": 67,
  "QuestionType": "multiple",
  "QuestionText": "Which three methods can be used for heap table data migration after upgrading a database? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "using Database Replay"},
    {"label": "B", "text": "using SQL Developer"},
    {"label": "C", "text": "using Oracle Data Pump"},
    {"label": "D", "text": "using operating system file copy utilities"},
    {"label": "E", "text": "using Database Upgrade Assistant"},
    {"label": "F", "text": "using the CREATE TABLE AS SELECT SQL statement"}
  ],
  "CorrectAnswer": ["B", "C", "F"],
  "Explanation": "堆表数据迁移意味着要使用某些工具或语句，将数据逻辑地从旧位置读出，然后逻辑地写入到新位置（通常是新创建的表或数据库中）。SQL Developer 和 Data Pump主要用于跨数据库或跨 Schema 的数据复制;CTAS主要用于同一数据库内的碎片整理和空间管理。\n\nA.Database Replay 是 Real Application Testing (RAT) 工具集的一部分，用于测试升级或配置更改的影响，而不是用于实际的数据迁移\nD.不适用于堆表数据。 数据库文件（如数据文件）是以 Oracle 特定的格式存储的，不能简单地用操作系统命令（如 cp 或 copy）复制到另一个数据库中并直接使用。这仅适用于 Transportable Tablespaces 场景，且需配合 SQL 和 RMAN 命令"
},
{
  "QuestionID": 68,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about Oracle instance recovery? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Recovery begins from the beginning of the CURRENT redo log group."},
    {"label": "B", "text": "Recovery begins from the last checkpoint position that was calculated by the Database Writer before instance failure."},
    {"label": "C", "text": "Recovery begins from the start of any ACTIVE redo log group or the start of the CURRENT log group if no other group is ACTIVE."},
    {"label": "D", "text": "Recovery reads redo until the end of the redo thread. SMON rolls back any dead transactions, and then the database is opened."},
    {"label": "E", "text": "Recovery begins from the last checkpoint position that was recorded in the control file by the checkpoint process (CKPT)."},
    {"label": "F", "text": "Recovery reads redo until the end of the redo thread, and then opens the database. SMON then rolls back any dead transactions."}
  ],
  "CorrectAnswer": ["E", "F"],
  "Explanation": "AC.恢复不是从重做日志组的开始（无论是当前还是活动）开始。恢复的起点是check point，它保证了只应用check point之后的更改，避免重复工作\nBE.检查点进程 (CKPT) 的职责是更新数据文件头和控制文件 (Control File) 中的检查点信息;恢复过程的起点是控制文件中记录的上一个检查点 (Last Checkpoint)。这个位置标志着所有在此时刻或之前的“脏数据”块都已安全地写入到数据文件中\n\n前滚 (Roll Forward)： 恢复进程从这个检查点位置开始，读取在线重做日志，将所有尚未写入数据文件（即在内存中丢失）的已提交或未提交事务的更改应用到数据文件。这一过程称为前滚 (Roll Forward)\n\n实例恢复分为两个阶段:\n--前滚阶段 (Roll Forward)： 自动应用重做日志直到日志线程的末尾，这会使数据文件包含所有已提交和未提交（死亡）事务的更改。\n--数据库打开： 一旦前滚完成，数据文件就处于一个一致的状态，可以安全地将数据库设置为 OPEN。这是 Oracle 的一个关键设计：数据库在死亡事务被回滚之前就可以打开。\n--回滚阶段 (Roll Back)： 在数据库打开后，系统监视器 (SMON) 进程才会在后台异步地回滚在崩溃时处于活动状态（死亡）的事务，释放它们占用的锁和资源。"
},
{
  "QuestionID": 69,
  "QuestionType": "single",
  "QuestionText": "Examine this configuration:\n1). The ORCL database data files are in Automatic Storage Management (Oracle ASM) disk group +DATA.\n2). ORCL uses disk group +FRA for the Fast Recovery Area.\n3). LISTENER is the listener for ORCL.\n4). The database, listener, ASM instance, and ASM disk groups are managed by Oracle Restart.\n5). All components are currently shut down.\nYou execute this command:\n$ srvctl start database -d ORCL\nWhat is the outcome? (Choose one.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The ORCL database, the Oracle ASM instances, the +DATA and +FRA disk groups, and the LISTENER are started."},
    {"label": "B", "text": "Only the ORCL database instance is started."},
    {"label": "C", "text": "Only the ORCL database and the ASM instances are started."},
    {"label": "D", "text": "Only the ORCL database instance, the Oracle ASM instance, and the +DATA and +FRA disk groups are started."},
    {"label": "E", "text": "Only the ORCL database instance and the +DATA and +FRA disk groups are started."}
  ],
  "CorrectAnswer": ["A"],
  "Explanation": "1.ORCL 数据文件在 +DATA\n2.ORCL FRA 在 +FRA\n3.LISTENER 是 ORCL 的监听器\n4.所有组件由 Oracle Restart 管理。\n5.所有组件当前都已关闭\nsrvctl start database 命令的目的是确保数据库及其所有必需的依赖项都已启动。srvctl start database 应该启动整个依赖链：启动 ASM 实例。\n挂载 +DATA 和 +FRA 磁盘组。\n启动 LISTENER。\n启动 ORCL 数据库实例。"
},
{
  "QuestionID": 70,
  "QuestionType": "multiple",
  "QuestionText": "Which four are true about a Recovery Manager (RMAN) duplication without a TARGET connection? (Choose four.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The NOREDO clause must be used if the backups of the database being duplicated were taken when the database was in NOARCHIVELOG mode."},
    {"label": "B", "text": "The UNDO TABLESPACE clause is always required when no connection exists to the TARGET instance."},
    {"label": "C", "text": "RMAN pushes the backups of the database to be duplicated over the network to the auxiliary instance."},
    {"label": "D", "text": "The NOREDO clause can be used if the backups of the database being duplicated were taken when the database was in ARCHIVELOG mode."},
    {"label": "E", "text": "RMAN SBT-based backups of the database to be duplicated can be used by the auxiliary instance."},
    {"label": "F", "text": "The UNDO TABLESPACE clause is always required when no connection exists to the recovery catalog and the TARGET database is closed."},
    {"label": "G", "text": "The UNDO TABLESPACE clause is always required when no connection exists to the recovery catalog and the TARGET database is opened."},
    {"label": "H", "text": "RMAN disk-based backups of the database to be duplicated can be used by the auxiliary instance."}
  ],
  "CorrectAnswer": ["A", "E", "F", "H"],
  "Explanation": "RMAN Duplication without a TARGET Connection基于备份的克隆 (Duplicate from Backup)，是 RMAN 中一种非常强大的恢复和测试手段，特别适用于源数据库不可用、已销毁或无法建立连接的场景\n由于无法连接 TARGET，RMAN 必须依赖用户提供以下信息:\n1.备份文件:必须有一个或多个完整的源数据库备份集，包括数据文件和控制文件（或 SPFILE）\n2.备份位置： 辅助实例必须能够直接访问这些备份文件（无论是磁盘文件还是 SBT 介质）\n3.控制文件信息： 必须有一个备份控制文件，用于获取源数据库的元数据\n4.辅助实例 (Auxiliary Instance)：必须在目标服务器上启动一个辅助实例到 NOMOUNT 状态。必须为该实例创建 PFILE 或 SPFILE。\n\nA.D.如果源数据库备份是在 NOARCHIVELOG 模式下创建的，必须使用 NOREDO。 这是因为没有归档日志可以应用。如果源数据库在 ARCHIVELOG 模式下，RMAN 不允许 NOREDO\n\nBFG.RMAN可以连接 TARGET 实例: 可以从数据库获取undo tablespace;不能连接 TARGET，但有 recovery catalog,可以从 catalog 获取undo tablespace;不能连接 TARGET，也没有 catalog无法获取undo tablespace\n\nRecovery Catalog 是一个普通的 Oracle 数据库,它本身就是一个数据库（可以叫 catalog database 或 schema）,需要在某台服务器上安装 Oracle Database，并创建一个专门的 schema 来存放 Recovery Catalog,RMAN 会连接到这个 catalog database 来读取 / 写入备份信息\n\nC.基于备份的克隆模式下，RMAN 不会通过网络推送备份。RMAN 要求辅助实例直接访问备份文件的物理位置（磁盘或 SBT）。只有在 基于活动数据库的克隆 且源数据库与辅助数据库不在同一主机上时，RMAN 才会通过网络推送数据文件\n\nEH.在无 TARGET 连接的克隆中，辅助实例 Auxiliary Instance需要能够访问源数据库的备份,如果备份存储在磁盘上，只要辅助实例所在的服务器可以访问该磁盘位置,SBT (System Backup to Tape) 备份存储在磁带或其他介质管理设备中。只要辅助实例的 RMAN 配置了正确的 介质管理器 (Media Manager) 库，它就可以从 SBT 设备中读取备份文件进行恢复"
},
{
  "QuestionID": 71,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Virtual Private Database (VPD) policies on objects in an application root are automatically synchronized with all application PDBs contained in the application container."},
    {"label": "B", "text": "Application-common TSDP policies are always container specific."},
    {"label": "C", "text": "Application-common Transparent Security Data Protection (TSDP) policies can be created only within an application install/patch BEGIN-END block."},
    {"label": "D", "text": "Application-common Oracle Label Security (OLS) policies cannot be created in an application root outside an install/patch BEGIN-END block."},
    {"label": "E", "text": "Fine-grained auditing (FGA) policies in an application root are automatically synchronized to all application PDBs contained in the application container."},
    {"label": "F", "text": "Application-common OLS policies can be created in an application root inside an install/patch BEGIN-END block."},
    {"label": "G", "text": "Unified auditing can be automatically synchronized to all application PDBs in an application container."}
  ],
  "CorrectAnswer": ["B", "D", "G"],
  "Explanation": "虚拟私有数据库 (VPD)也称为 行级安全 (Row-Level Security, RLS)\nA.application root 定义了 VPD 策略，它 不会自动同步到所有 application PDBs需要手动在 PDB 中应用策略\nB.在 application root 中定义的 TSDP policy，对于 application-common 对象，如果要在某个 application PDB 中生效，需要在那个 PDB (container) 中enable该策略\nCD.TSDP 不能在 install/patch BEGIN-END block 中创建，必须使用匿名 PL/SQL 块创建；OLS 在 application root 中创建时，必须在 install/patch BEGIN-END block 内；如果在外部创建，会失败\n\n1.容器隔离：绝大多数安全策略是 container-specific，即使对象是 application-common，也不会自动同步策略\n2.策略传播：VPD / TSDP / FGA 策略需要手动 propagate 或在 PDB 分别启用\n3.创建限制：TSDP → 不能放在 application install/patch BEGIN-END block; OLS → 必须放在 install/patch block; VPD / FGA → 需通过 DBMS_RLS / DBMS_FGA 过程创建\n4.审计策略：Unified Audit 可以跨 PDB，但需要注意 common/local 用户和权限。一旦通用策略在应用根中被创建和启用，它就会被设计为自动传播到该应用容器中的所有应用 PDBs（Application PDBs）"
},
{
  "QuestionID": 72,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about Automatic Workload Repository (AWR)? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "By default, AWR snapshots are taken every 60 minutes."},
    {"label": "B", "text": "Its collection level is determined by the value of the STATISTICS_LEVEL database parameter."},
    {"label": "C", "text": "By default, AWR snapshots are retained for 7 days."},
    {"label": "D", "text": "The taking of AWR snapshots can be disabled."},
    {"label": "E", "text": "AWR data is stored in the SYSTEM tablespace."}
  ],
  "CorrectAnswer": ["A", "B", "D"],
  "Explanation": "B.STATISTICS_LEVEL (默认 TYPICAL) 控制了包括 AWR 在内的大多数性能统计信息的采集\nD.AWR 快照的自动采集可以被禁用。可以通过执行 DBMS_WORKLOAD_REPOSITORY.DISABLE_AWR()\nE.AWR 数据存储在 SYSAUX 表空间中"
},
{
  "QuestionID": 73,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about automatic block repair? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Automatic block repair can repair blocks with no standby database if DB_BLOCK_CHECKING = TRUE."},
    {"label": "B", "text": "Real-Time Query must be enabled on a physical standby database for automatic block repair to be done on that physical standby database."},
    {"label": "C", "text": "Real-Time Query must be enabled on a primary database for automatic block repair to be done on any of its physical standby databases."},
    {"label": "D", "text": "It is not possible for media corrupt blocks."},
    {"label": "E", "text": "Real-Time Query must be enabled on a physical standby database for automatic block repair to be done on its primary database."}
  ],
  "CorrectAnswer": ["B", "E"],
  "Explanation": "automatic block repair是 Oracle Data Guard 的一项功能，允许损坏的块（逻辑损坏，如校验和不匹配）从 Data Guard 体系结构中的伙伴数据库（Primary 或 Standby）自动获取并修复\n自动块修复的核心机制是从另一份数据副本中获取正确块。如果环境中没有备用数据库（Standby Database），即使设置了 DB_BLOCK_CHECKING = TRUE（这只是启用块校验），也无法进行自动修复，因为没有块的来源\nBCE.Real-Time Query（Active Data Guard, ADG）是备用数据库（Standby Database）上的一个功能，它允许：备库自身进行查询 (如 B 选项中的修复源查询)。备库接受外部查询 (如 E 选项中主库对备库的查询)。主库primary database不涉及 ADG\nD.自动块修复可以修复 Media Corrupt Blocks（介质损坏块），前提是损坏的块是由逻辑错误（如校验和失败）导致的，并且Data Guard环境中有可用的、未损坏的块副本。修复范围包括逻辑损坏。"
},
{
  "QuestionID": 74,
  "QuestionType": "multiple",
  "QuestionText": "Oracle Managed Files (OMF) is enabled in a CDB and this command is successfully executed:\nCREATE PLUGGABLE DATABASE app1\n AS APPLICATION CONTAINER\n ADMIN USER admini IDENTIFIED BY app_123 ROLES= (CONNECT);\nWhich three are true? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Application PDBs that are subsequently created in the APP1 application container will be cloned from APP1$SEED."},
    {"label": "B", "text": "An application seed PDB is created for APP1."},
    {"label": "C", "text": "An application root PDB is created for APP1."},
    {"label": "D", "text": "A default service is created for the application root APP1."},
    {"label": "E", "text": "Application PDBs that are subsequently created in the APP1 application container will be cloned from PDB$SEED."},
    {"label": "F", "text": "APP1 can never be unplugged."}
  ],
  "CorrectAnswer": ["C", "D", "E"],
  "Explanation": "AB.CREATE PLUGGABLE DATABASE APP1 AS APPLICATION CONTAINER ...，并没有包含 AS SEED 子句，因此应用种子 PDB (APP1$SEED) 不会作为该命令的直接结果自动创建。 必须在创建应用根 PDB 后，再执行单独的 CREATE PLUGGABLE DATABASE APP1$SEED AS SEED 命令\n\nE.由于 APP1$SEED 不存在，如果用户在应用根中尝试使用默认方式创建应用 PDB，它会使用 CDB 的通用种子 PDB$SEED 作为模板。在没有应用种子的情况下，这是创建 PDB 的默认行为。\nF.如果 APP 容器没有任何 PDB，您可以拔下 APP 容器;如果 APP 里有 PDB，就不可以拔下来"
},
{
  "QuestionID": 75,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about RMAN encryption? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "RMAN encryption keys are stored in a database keystore."},
    {"label": "B", "text": "RMAN can encrypt the Oracle Database password file."},
    {"label": "C", "text": "Dual-mode encrypted backups can be restored only if both the password and the keystore used for encryption are available."},
    {"label": "D", "text": "The SET ENCRYPTION command overrides encryption settings specified by the CONFIGURE ENCRYPTION command."},
    {"label": "E", "text": "Password encryption can be persistently configured using the CONFIGURE ENCRYPTION command."}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": "RMAN 备份加密模式:\n1.透明加密模式 (Transparent Mode):加密和解密的密钥（通常是 TDE Master Key 或 Auto-Login Keystore）存储在 数据库 Keystore,恢复时，只要 Keystore 是开放且可用的，RMAN 就会自动从 Keystore 中获取密钥\n2.密码加密模式 (Password Mode)用户必须在 RMAN 命令中指定加密密码。RMAN 使用该密码对备份数据进行加密。恢复该备份时，用户必须提供完全相同的密码，否则 RMAN 无法解密和还原数据\n\nB.RMAN 的加密功能针对的是备份集和归档日志。Oracle Database 密码文件的安全由操作系统权限或使用 orapwd 实用程序创建时设置的密码保护，RMAN 本身没有加密密码文件的功能\nC.双模式 (Dual Mode) 加密指的是 RMAN 备份可以同时使用透明模式和密码模式加密。但是，要恢复备份，只需要其中一种解密机制可用即可：如果 keystore 可用，RMAN 可以使用透明模式自动解密。如果 keystore 不可用，用户可以使用加密时设置的密码进行解密\nD.RMAN 提供了两种设置加密的方法：CONFIGURE ENCRYPTION：用于设置持久的、全局的默认加密设置;SET ENCRYPTION：用于在单个 BACKUP 命令或 RUN 块内设置加密,根据 RMAN 的规则，SET ENCRYPTION 总是优先于（即覆盖）CONFIGURE ENCRYPTION 的持久设置\nE.Password encryption只能用SET ENCRYPTION IDENTIFIED BY 来配置；CONFIGURE ENCRYPTION 仅用于设置透明加密（依赖 Keystore）"
},
{
  "QuestionID": 76,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about performing an Oracle Database install on Linux? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The runfixup.sh script can install missing RPMs."},
    {"label": "B", "text": "The Oracle Preinstallation RPM must be used to configure the Oracle database installation owner, the Oracle Inventory group, and an Oracle administrative privileges group."},
    {"label": "C", "text": "It allows you to select the languages supported by the Oracle database server."},
    {"label": "D", "text": "It can be done before installing Grid Infrastructure for a Standalone Server."},
    {"label": "E", "text": "The Oracle Preinstallation RPM can be used to configure the Oracle database installation owner, the Oracle Inventory group, and an Oracle administrative privileges group."},
    {"label": "F", "text": "It can be done after installing Grid Infrastructure for a Standalone Server."},
    {"label": "G", "text": "The Oracle database administrator must be granted access to the root operating system account to run root privileged scripts."}
  ],
  "CorrectAnswer": ["D", "E", "F"],
  "Explanation": "A.runfixup.sh 脚本主要用于修正内核参数、文件系统挂载选项和资源限制（ulimits）等设置，以符合 Oracle 的要求。它不能用于安装缺失的操作系统 RPM 包。安装 RPM 通常依赖于操作系统自带的包管理器\nB.虽然 Oracle 推荐使用预安装 RPM，但它不是强制性的。用户可以手动完成所有必需的配置\nC.数据库内部支持的字符集、语言环境（NLS settings）不是在安装时通过“选择语言”的界面设置的\nD.单实例环境可以先安装数据库软件，再安装或不安装 GI\nE.预安装 RPM 可以用于自动创建所需的用户和组，这是它的主要功能之一\nF.单实例环境可以先安装 GI（提供 ASM），再安装数据库软件\nG.DBA 用户不能直接访问 root 账户"
},
{
  "QuestionID": 77,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about Recovery Manager (RMAN) in Oracle Database 19c and later releases? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It is only possible for RMAN to connect to a pluggable database as a target if an RMAN Virtual Private Catalog is used."},
    {"label": "B", "text": "It is always possible for RMAN to connect to a pluggable database as a target if any RMAN Catalog is used."},
    {"label": "C", "text": "A Virtual Private Catalog used to register a container database must be created in a pluggable database."},
    {"label": "D", "text": "A Virtual Private Catalog used to register a container database can be created in a pluggable database."},
    {"label": "E", "text": "It is always possible for RMAN to connect to a pluggable database as a target."},
    {"label": "F", "text": "A Virtual Private Catalog used to register a container database can be created in a non-container database."}
  ],
  "CorrectAnswer": ["D", "E", "F"],
  "Explanation": "Virtual Private Catalog提供多用户隔离的备份元数据可见性,基于主 catalog,依赖一个中央 RMAN Catalog,给 VPC 用户创建专用视图,内容是从主 catalog 中“过滤”出来的可见数据\n\nA.连接到 PDB 作为目标数据库是 RMAN 的基本功能，与是否使用 VPC 或恢复目录无关.\nBE.RMAN 总是可以连接到 PDB 作为目标，无论是否使用目录\nCDF.恢复目录（或 VPC）不必须创建在 PDB 中。它也可以创建在一个 Non-CDB 中,或者甚至创建在它所注册的 CDB 根目录 (CDB$ROOT) 中（但不推荐）"
},
{
  "QuestionID": 78,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true in Oracle 19c and later releases? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "If the password file location changes, then the new location is used automatically by the Oracle Server."},
    {"label": "B", "text": "Schema Only accounts can be granted administrator privileges."},
    {"label": "C", "text": "All the Oracle-supplied accounts are Schema Only accounts."},
    {"label": "D", "text": "Privilege Analysis is included in Oracle Enterprise Edition and no longer requires Database Vault."},
    {"label": "E", "text": "Unified Auditing can be configured to audit only events that are issued indirectly by an audited user."},
    {"label": "F", "text": "Unified Auditing can be configured to audit only events that are issued directly by an audited user."}
  ],
  "CorrectAnswer": ["B", "D", "F"],
  "Explanation": "A.Oracle Server 依赖于 sid 文件来查找密码文件。如果密码文件的位置发生变化，您通常需要重新配置或确保参数文件 (SPFILE/PFILE) 中的 REMOTE_LOGIN_PASSWORDFILE 参数正确设置，并且数据库实例需要重启才能识别新的密码文件位置。它不会“自动”使用新的位置\nB.Schema Only Accounts (仅模式账户没有密码) 是将数据库模式的所有权与用户登录/连接能力分开;仅模式账户不能用于登录或连接数据库。它们只是一个容器，用于存储表、索引等对象,可以给这些账户授予管理权限（如 DBA 角色）\n只有新创建的用于模式存储的账户推荐使用 Schema Only,已有账户都有密码\nD.从 Oracle Database 18c/19c 开始，权限分析已降级为 Oracle Enterprise Edition (EE) 的标准功能，不再需要购买和配置昂贵的 Database Vault 选件;\nEF.统一审计的默认行为是审计由用户直接发出的事件"
},
{
  "QuestionID": 79,
  "QuestionType": "multiple",
  "QuestionText": "You have configured RMAN SBT channels to write backups to media. You then take an RMAN backup by using this command:\n\nRMAN> BACKUP AS COMPRESSED BACKUPSET DATABASE KEEP UNTIL TIME 'SYSDATE + 730' RESTORE POINT 'OLD_CONFIGURATION';\n\nWhich three are true? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The restore point is a label for the system change number (SCN) that will be saved two years after the archival backup was taken."},
    {"label": "B", "text": "The data file backups in the self-contained archive backup are not considered obsolete for two years regardless of the retention policy."},
    {"label": "C", "text": "All archive logs created after this backup are kept for two years."},
    {"label": "D", "text": "The SPFILE is included in the self-contained archival backup."},
    {"label": "E", "text": "The control file is included in the self-contained archival backup."},
    {"label": "F", "text": "The restore point is a label for the system change number (SCN) before the archival backup was taken."}
  ],
  "CorrectAnswer": ["B", "D", "E"],
  "Explanation": "这个命令创建了一个特殊的备份，称为 自包含归档备份 (Self-Contained Archival Backup) 或 KEEP 备份\nAS COMPRESSED BACKUPSET指定备份以备份集 (Backup Set) 形式创建，并且在创建过程中应用 压缩 (COMPRESSED)。这会减小备份文件的大小\nDATABASE指定备份整个数据库（所有数据文件）。这个备份是自包含的 (Self-Contained)，意味着它会自动包含 控制文件 和 SPFILE（如果使用)\nKEEP UNTIL TIME 'SYSDATE + 730'保留这个备份集，直到当前系统时间（SYSDATE）加上 730 天（约两年）\nRESTORE POINT 'OLD_CONFIGURATION'在备份操作开始之前，RMAN 会在控制文件中自动创建一个恢复点 (Restore Point)，并为其贴上标签 'OLD_CONFIGURATION'\n\nAF.RESTORE POINT 'OLD_CONFIGURATION'：标记了一个历史的、过去的时间点;KEEP UNTIL TIME 'SYSDATE + 730'：设置了一个未来的删除点，保护了备份集本身\nB.除非您在命令中明确使用 ARCHIVELOG ALL 或类似子句来备份归档日志，否则 BACKUP DATABASE 命令不会影响归档日志的保留策略。只有归档日志本身的备份集会受 KEEP 子句保护"
},
{
  "QuestionID": 80,
  "QuestionType": "multiple",
  "QuestionText": "The USERS tablespace consists of data files 3 and 4 and must always be online in read/write mode. Which two are true about using RMAN to perform an open database backup of this tablespace? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Backups must be done incrementally."},
    {"label": "B", "text": "Backups must be contained in backup sets."},
    {"label": "C", "text": "Backups can be taken only if the database is in ARCHIVELOG mode."},
    {"label": "D", "text": "Backups can be done incrementally."},
    {"label": "E", "text": "The database must be registered in an RMAN catalog."},
    {"label": "F", "text": "Only consistent backups can be created."}
  ],
  "CorrectAnswer": ["C", "D"],
  "Explanation": "AD.备份可以是完全 (Full) 备份，也可以是增量 (Incremental) 备份\nB.RMAN 备份可以以 备份集 (Backup Sets) 的形式存储，也可以以 映像副本 (Image Copies) 的形式存储\nC.打开数据库备份 (Open Database Backup) 指的是在数据库处于 OPEN 状态时进行的备份。当数据库处于 OPEN 状态且数据文件处于读/写模式时，数据文件正在不断发生变化。为了确保备份的数据块是一致且可恢复的，Oracle 必须能够应用在备份期间产生的所有 重做日志 (Redo Log)。这要求数据库必须启用 ARCHIVELOG 模式。如果数据库处于 NOARCHIVELOG 模式，则只能进行一致性关闭备份 (Consistent Closed Backup)\nE.RMAN 可以运行在 NOCATALOG 模式下，依靠数据库的控制文件来存储元数据。使用恢复目录是可选的\nF.如果数据库处于 OPEN 状态且启用了 ARCHIVELOG 模式，那么 RMAN 创建的是 非一致性备份 (Inconsistent Backup)。非一致性备份指的是备份文件在时间点上不统一（因为文件在备份时可能正在写入）。但是，可恢复性是有保证的，因为 RMAN 依赖于归档日志在恢复时将这些数据文件“前滚”到一致状态。一致性备份只能在数据库处于关闭 (SHUTDOWN) 状态或被挂起 (SUSPEND) 时创建"
},
{
  "QuestionID": 81,
  "QuestionType": "multiple",
  "QuestionText": "Which four are true about RMAN backup sets? (Choose four.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A backup piece can belong to only one backup set."},
    {"label": "B", "text": "A data file can be split into multiple sections stored in different backup sets."},
    {"label": "C", "text": "A data file can be split into multiple sections stored in different backup pieces in the same backup set."},
    {"label": "D", "text": "Blocks from multiple data files can be contained in one backup piece."},
    {"label": "E", "text": "A backup set can contain only one backup piece."},
    {"label": "F", "text": "A backup set must be written to media."},
    {"label": "G", "text": "A backup set must be written to disk."},
    {"label": "H", "text": "Blocks from multiple data files can be contained in one backup set."}
  ],
  "CorrectAnswer": ["A", "C", "D", "H"],
  "Explanation": "RMAN (Recovery Manager) 使用 备份集 (Backup Set) 来存储备份数据。一个备份集包含一个或多个 备份片 (Backup Pieces)。\n备份集 (Backup Set): RMAN 备份操作创建的逻辑容器。它包含备份的全部数据。\n备份片 (Backup Piece): 备份集创建的物理文件。备份片是实际存储在磁盘或磁带上的文件。\n\nA.备份片是 备份集 的物理组成部分。一个物理文件（备份片）在逻辑上只属于一个备份操作（备份集）\nBCE.RMAN 不会将一个数据文件分成多个部分存储在不同的备份集中。一个数据文件的所有备份数据都会包含在一个或多个备份片中，而这些备份片都属于同一个备份集DG.RMAN 备份片 是一种多路复用格式。它将来自多个数据文件的块或来自数据文件和归档日志的块组合在一起，存储在单个备份片文件中\nFG.RMAN 备份集可以写入磁盘或介质管理设备"
},
{
  "QuestionID": 82,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about creating RMAN backups for an Oracle container database? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Tablespaces from different PDBs with identical names must be backed up by connecting RMAN separately to each PDB to back up the tablespaces."},
    {"label": "B", "text": "The BACKUP DATABASE command will create a pluggable database (PDB) backup when RMAN is connected to a PDB."},
    {"label": "C", "text": "SPFILE backups can be created while connected to an application root PDB."},
    {"label": "D", "text": "The BACKUP DATABASE PLUS ARCHIVELOG command will back up archive logs when RMAN is connected to a PDB."},
    {"label": "E", "text": "The BACKUP PLUGGABLE DATABASE command can be used to back up CDB$ROOT."}
  ],
  "CorrectAnswer": ["B", "E"],
  "Explanation": "A.在连接到CDB$ROOT时,RMAN 可以通过指定 PDB 名称来区分并备份具有相同表空间名称的表空间\nC.SPFILE是 CDB 实例级别的,只有在连接CDB$ROOT时，才能创建 CDB 的 SPFILE 备份\nD.只有当 RMAN 连接到 CDB 的 root（根容器）时，才允许备份 archive logs;如果连接到 PDB并执行 BACKUP DATABASE 或 BACKUP DATABASE PLUS ARCHIVELOG,archive logs 不会 被包括\nE.经过实际测试是可以的"
},
{
  "QuestionID": 83,
  "QuestionType": "multiple",
  "QuestionText": "Which three can be done using Oracle Database Configuration Assistant (DBCA) starting from Oracle Database 19c? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "cloning a remote container database in interactive mode"},
    {"label": "B", "text": "cloning a remote pluggable database in silent mode"},
    {"label": "C", "text": "relocating a remote pluggable database in interactive mode"},
    {"label": "D", "text": "relocating a remote container database in silent mode"},
    {"label": "E", "text": "cloning a remote container database in silent mode"},
    {"label": "F", "text": "relocating a remote pluggable database in silent mode"},
    {"label": "G", "text": "relocating a remote container database in interactive mode"}
  ],
  "CorrectAnswer": ["B", "E", "F"],
  "Explanation": "静默模式 是指在执行软件安装、配置、升级或创建数据库等操作时，完全不依赖用户交互界面 (GUI) 的运行方式\n silent mode 独有的功能：\n-createDuplicateDB（duplicate 一个 CDB → 只有 silent mode 支持）\n-createDuplicateDB 接受 primaryDBConnectionString → 明确支持“远程数据库连接”\n支持远程 PDB clone（source CDB 和 target CDB 在不同服务器）\nRelocate 只支持 PDB，不支持 CDB\n\nDBCA GUI（交互模式）功能较少\n-GUI 可以创建 CDB、PDB\n可以 clone 本地 PDB（同一个 CDB 内）\n不能输入远程 connection string\n不能创建 duplicate CDB"
},
{
  "QuestionID": 84,
  "QuestionType": "single",
  "QuestionText": "How do you achieve this?",
  "ImageURL": "images/Q084.png",
  "Options": [
    {"label": "A", "text": "Execute FLASHBACK PLUGGABLE DATABASE PDB1 TO RESTORE POINT R1 by using RMAN while connected to PDB1."},
    {"label": "B", "text": "Execute FLASHBACK PLUGGABLE DATABASE PDB1 TO RESTORE POINT R1 by using SQL while connected to PDB1."},
    {"label": "C", "text": "Execute FLASHBACK PLUGGABLE DATABASE PDB1 TO RESTORE POINT R1 by using SQL while connected to CDB$ROOT."},
    {"label": "D", "text": "Execute FLASHBACK PLUGGABLE DATABASE PDB1 TO RESTORE POINT R1 by using RMAN while connected to CDB$ROOT."},
    {"label": "E", "text": "This cannot be done due to the lack of a clean restore point."}
  ],
  "CorrectAnswer": ["E"],
  "Explanation": "PDB_NAME: PDB1\nPDB_RESTORE_POINT: R1\nPDB_RESTORE_POINT 存在：YES\nCLEAN_PDB_RESTORE_POINT：NO（意味着这不是一个关闭后创建的“干净”恢复点，而是一个保证数据一致性的“不干净”恢复点，通常需要介质恢复/日志应用\nPROPERTY_NAME: LOCAL_UNDO_ENABLED\nPROPERTY_VALUE: FALSE (这意味着 PDB1 使用的是 共享撤销（Shared Undo），即 CDB 的撤销表空间)。\n\nAD.FLASHBACK PLUGGABLE DATABASE 命令是 SQL 语句，而不是 RMAN 命令\nB.只有 CDB root 才拥有 CREATE PLUGGABLE DATABASE、DROP PLUGGABLE DATABASE、FLASHBACK PLUGGABLE DATABASE 等全局权限。普通 PDB 下没有足够权限执行这些操作\nDE.如果 CDB 是共享 UNDO 模式，要使用简化的 FLASHBACK PLUGGABLE DATABASE PDB1 TO RESTORE POINT R1 SQL 命令，该恢复点必须是 CLEAN 恢复点\n\nCLEAN_PDB_RESTORE_POINT这个恢复点是在 PDB 被关闭 (Closed) 且 没有任何活动事务 的情况下创建的"
},
{
  "QuestionID": 85,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about diagnosing Oracle Database failure situations using Data Recovery Advisor? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Using the Data Recovery Advisor LIST FAILURE command always requires that the database for which failures are to be listed is in MOUNT state."},
    {"label": "B", "text": "A failure can be closed only when it has been repaired."},
    {"label": "C", "text": "Data Recovery Advisor can be used if a database is closed."},
    {"label": "D", "text": "The Data Recovery Advisor CHANGE FAILURE command can be used only to change failure priorities."},
    {"label": "E", "text": "Data Recovery Advisor can proactively check for failures."}
  ],
  "CorrectAnswer": ["C", "E"],
  "Explanation": "Data Recovery Advisor (DRA)集成在 RMAN (Recovery Manager) 中，目的是将复杂的数据库恢复过程自动化、智能化，从而简化数据库管理员（DBA）处理数据故障的工作\nDRA 的工作分为三个核心阶段，对应 RMAN 中的三个主要命令:\n1.诊断:RMAN 命令LIST FAILURE,DRA 通过访问 自动诊断存储库ADR中的信息，列出所有已识别的持久性（需要干预）故障\n2.建议:RMAN 命令ADVISE FAILURE,DRA 分析列出的故障，考虑所有可用的备份和归档日志，并生成一个或多个修复选项 (Repair Options)，包括成本、数据丢失风险等信息\n3.修复:RMAN 命令REPAIR FAILURE,DBA 确认建议后，执行此命令。DRA 会自动生成并执行所有必要的 RMAN 语句（例如，恢复数据文件、应用归档日志等），完成故障修复\n\n使用 DRA，数据库需要满足以下关键前提:\n1.Fast Recovery Area (FRA) 已配置： 闪回日志和备份文件通常存储在 FRA 中。\n2.Flashback Database 已启用（推荐）： 启用后，DRA 可以利用闪回功能提供更快、数据丢失风险更小的修复选项。\n3.数据库处于 MOUNT 或 OPEN 状态： 多数诊断和修复操作需要数据库实例至少处于 MOUNT 状态才能访问控制文件和数据文件\n\nA.数据库不一定非得 MOUNT，也可以OPEN 状态执行。只有某些 failure types（如丢失控制文件）需要 MOUNT，但并非全部\nB.DRA 允许你 手动关闭未修复的故障，比如你决定暂时不修复某个故障或者故障不影响生产，关闭后 DRA 不再在列表中显示\nDCHANGE FAILURE 命令可以用于修改故障的优先级 (PRIORITY)，也可以用于修改故障的状态 (STATUS)，例如从 OPEN 修改为 CLOSED（但只能在修复后）\nE.DRA 是作为 故障自动诊断存储库 (ADR) 的一部分,会主动proactively运行健康检查（如数据文件头检查、块检查等），并在检测到持续或严重的故障时自动创建故障记录，即使 DBA 没有手动执行 ADVISE FAILURE 命令\n\n这题注意，网上查到C选项是错误的"
},
{
  "QuestionID": 86,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about an Oracle gold image-based installation in Oracle 18c and later releases? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It can be used for both Oracle Database and Oracle Grid Infrastructure installation."},
    {"label": "B", "text": "It can only install and configure Oracle Database software. The database has to be created separately."},
    {"label": "C", "text": "It does not require the setup wizard."},
    {"label": "D", "text": "It uses a single RPM that automatically extracts and installs the Oracle Database software."},
    {"label": "E", "text": "It can be used to install and upgrade Oracle Database for single-instance and cluster configurations."}
  ],
  "CorrectAnswer": ["A", "E"],
  "Explanation": "Gold Image-based installation 是指 使用预先安装好 Oracle Home（数据库软件和 Grid Infrastructure）并打好补丁的镜像;黄金镜像是一种预配置的、已安装但未配置的 Oracle 软件副本。它本质上是一个 ZIP 压缩包，包含完整的、已打补丁的软件安装文件,基于镜像的安装是一种新的安装方式，比原来的要简单，经过实验，只要把安装文件解压到 ORACLE_HOME/目录下，然后运行 runInstaller 就可以快速的安装和配置以及建库\nB.Gold Image-based installation 不仅可以安装 Oracle Database 软件，还可以用于安装 Oracle Grid Infrastructure（Clusterware / ASM 等）\nC.GUI 安装向导 (setup wizard / runInstaller);通过解压 ZIP 包获得文件，但要正式注册和配置这些软件，您仍然需要使用 Oracle Universal Installer (OUI) 或 DBCA/NETCA 等工具\nD.RPM 全称是 Red Hat Package Manager,它是 Linux 系统的一种软件包管理格式，用于在 Linux 系统上安装、升级、卸载、验证软件,Oracle 提供了 RPM 包来安装 Oracle Database Pre-Install 依赖项和执行一些基础设置，但黄金镜像的交付形式是 ZIP，而非 RPM。且 RPM 方式与黄金镜像方式是两种不同的安装路径"
},
{
  "QuestionID": 87,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about RMAN duplexed backup sets? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "They can be written only to disk."},
    {"label": "B", "text": "They must be written to media."},
    {"label": "C", "text": "They can be created by using the RMAN CONFIGURE command to specify duplexing before taking a backup."},
    {"label": "D", "text": "They can be created only by using the COPIES option of a BACKUP command."},
    {"label": "E", "text": "They can be written to media."}
  ],
  "CorrectAnswer": ["C", "E"],
  "Explanation": "RMAN 在创建备份集时，会同时向不同的通道或不同的位置写入 N 份相同的备份块，其中 N 是您指定的副本数（Duplexing Factor）\n两种主要的 RMAN 方法来启用duplexed backup sets:\n1.使用 SET BACKUP COPIES（临时/会话级别）,临时性的，仅对您在 RUN 块中执行的 当前 BACKUP 命令 生效\n2.使用 CONFIGURE ... COPIES（持久/全局级别）持久性的，它会修改 RMAN 配置库中的默认设置。此后，所有没有明确指定副本数的备份命令都会自动创建指定数量的副本。\n\nC.意思是，我先用RMAN CONFIGURE command来确定备份几份，然后我使用back up指令的时候，他会按照之前的设置直接备份"
},
{
  "QuestionID": 88,
  "QuestionType": "single",
  "QuestionText": "Which should be tuned first when doing a performance tuning exercise for an Oracle Database environment?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "SQL statements"},
    {"label": "B", "text": "log writer performance"},
    {"label": "C", "text": "general operating system health"},
    {"label": "D", "text": "database writer performance"},
    {"label": "E", "text": "database instance memory management and sizes"}
  ],
  "CorrectAnswer": ["C"],
  "Explanation": "OS 健康 (C) → SQL 调优 (A) → Instance Memory (E) → I/O 调优 (D, B)\n实际场景中 “瓶颈先在哪，就先解决哪”"
},
{
  "QuestionID": 89,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true in Oracle 19c and later releases? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "Tablespaces never remain in read/write mode during transportable tablespace operations."},
    {"label": "B", "text": "A transportable data pump import can leave a plugged-in tablespace in read-only mode."},
    {"label": "C", "text": "A transportable data pump import can leave a plugged-in tablespace in read/write mode."},
    {"label": "D", "text": "Simultaneous data pump jobs can be limited at the pluggable database (PDB) level."},
    {"label": "E", "text": "Tablespaces always remain in read/write mode during transportable tablespace operations."},
    {"label": "F", "text": "An ordinary data pump export of a table with encrypted columns will always encrypt the same columns when imported."}
  ],
  "CorrectAnswer": ["A", "B", "D"],
  "Explanation": "ABCE.在导出 (expdp) 或传输表空间之前，必须将表空间置为 READ ONLY 模式\nD.Oracle Data Pump 允许在 整个 CDB 或单个 PDB 层面限制并发作业数。控制方式是 Resource Manager，通过 Data Pump Consumer Group 或 Resource Plan 来管理：DBMS_RESOURCE_MANAGER 可以对 PDB 级别的并行作业数进行限制\nF.1.表列加密的本质:\n--加密列使用 TDE (Transparent Data Encryption) 或 column-level encryption\n--加密密钥存储在 Wallet / keystore 中，不直接存储在表数据里。\n2.导出 / 导入行为\n--导出 (expdp) 并不包含加密密钥，它只包含加密列的数据。\n--导入 (impdp) 时，如果目标数据库 Wallet / keystore 配置正确，数据可以正确解密和恢复。\n--如果目标数据库没有相同的加密密钥，数据无法自动保持加密状态。"
},
{
  "QuestionID": 90,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about the automatic execution of operating system scripts when performing silent mode installation starting from Oracle Database 19c? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The response file can specify the root or sudo password."},
    {"label": "B", "text": "The installer will prompt for the root or sudo password."},
    {"label": "C", "text": "Silent install always runs operating scripts automatically."},
    {"label": "D", "text": "The response file must contain the root or sudo password."},
    {"label": "E", "text": "The response file can specify the path of the sudo program."}
  ],
  "CorrectAnswer": ["B", "E"],
  "Explanation": "ABDE.root / sudo 密码不能写入response file，否则存在安全风险。安装时通常会要求用户手动输入 root 权限，或者执行安装后的 root 脚本 (root.sh) 时手动提供 sudo 权限\nC.Silent install 自动安装软件，但operating scripts必须手动执行"
},
{
  "QuestionID": 91,
  "QuestionType": "multiple",
  "QuestionText": "Which three capabilities require the use of the RMAN recovery catalog? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "using the KEEP FOREVER clause with the BACKUP command"},
    {"label": "B", "text": "using RMAN stored scripts"},
    {"label": "C", "text": "using the REPORT SCHEMA command to list a database's current data files and tablespaces"},
    {"label": "D", "text": "creating customized reports about a single database's backups"},
    {"label": "E", "text": "creating encrypted backups"},
    {"label": "F", "text": "using the REPORT SCHEMA command to list a database's data files and tablespaces at times in the past"}
  ],
  "CorrectAnswer": ["A", "B", "F"],
  "Explanation": "A.KEEP FOREVER 用于 指定备份永久保留，即不受 Retention Policy 或 默认控制文件覆盖策略 的限制,默认情况下，RMAN 会根据 RETENTION POLICY 或控制文件空间自动 删除旧备份,使用 KEEP FOREVER 后，这个备份 永远不会被 RMAN 删除（除非手动删除），即使它超出了保留策略也不受影响,用 KEEP FOREVER，必须连接到并使用 Recovery Catalog，否则 RMAN 会拒绝执行该命令\nB.RMAN stored scripts是存储在恢复目录中的、命名好的 RMAN 命令集合。控制文件无法存储这些脚本,必须使用recovery catalog\nCF.REPORT SCHEMA 是 RMAN 的一个命令，用于 显示数据库的数据文件、表空间、归档日志等的备份信息，帮助 DBA 了解备份覆盖情况,使用控制文件只显示最近的备份信息;使用Catalog 可以显示历史记录、跨数据库信息\nD.自定义报告（Customized Reports）只针对单个数据库，而且只依赖最近的备份信息，控制文件完全可以满足。这些报告 不需要 Recovery Catalog，因为只针对当前数据库，使用控制文件就可以生成。只有当你想生成 跨数据库、跨历史周期 的报告时，才必须用 Recovery Catalog\nE.加密备份是 RMAN 的功能，它通过配置 Transparent Data Encryption (TDE) 或使用 SET ENCRYPTION 命令实现，不需要恢复目录"
},
{
  "QuestionID": 92,
  "QuestionType": "multiple",
  "QuestionText": "Which three are true about the tools for diagnosing Oracle Database failure situations? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "The ADR command-line utility (ADRCI) can package incident information to send to Oracle Support."},
    {"label": "B", "text": "The Automatic Diagnostic Repository (ADR) has a separate home directory for each instance of each Oracle product that is installed and uses it."},
    {"label": "C", "text": "Flashback commands help with repairing physical errors."},
    {"label": "D", "text": "RMAN can always repair corrupt blocks."},
    {"label": "E", "text": "The ADR can store metadata in an Oracle Database repository."},
    {"label": "F", "text": "The Data Recovery Advisor uses the ADR."}
  ],
  "CorrectAnswer": ["A", "B", "F"],
  "Explanation": "A.ADRCI (ADR Command-Line Utility) 是用于管理 ADR (Automatic Diagnostic Repository) 内容的工具。当数据库发生关键错误并记录为一个 Incident 时，ADRCI 可以使用 IPS CREATE PACKAGE 命令将相关的诊断文件（如跟踪文件、日志、dump 文件等）收集并打包成一个文件，这个文件可以方便地上传给 Oracle Support 进行分析\nB.ADR 是一个基于文件系统的层次结构目录，用于存储所有诊断数据,其结构通常是\n--ADR Base:ADR 的根目录\n--ADR Home：在 ADR Base 下，每个 Oracle 产品（如数据库、ASM、Listener）的每个实例都有一个独立的 ADR Home 目录。例如，如果您在同一台机器上运行了两个不同的数据库实例 (DB1 和 DB2)，ADR 会为每个实例创建一个单独的 Home 目录来隔离诊断数据\nC.Flashback 命令（如 Flashback Database, Flashback Table, Flashback Query）用于逻辑错误（例如人为误操作、意外删除数据）的恢复,物理错误通常需要 RMAN 恢复或块介质恢复\nD.RMAN 可以修复可修复的损坏块，前提是存在一个未损坏的备份或副本。如果一个损坏的块没有任何可用的备份来恢复，RMAN 就无法修复它\nE.ADR 是一个基于文件系统的诊断数据存储库。它的设计目标是即使数据库完全不可用，诊断信息也能被访问。因此，它不会将其元数据存储在它所诊断的 Oracle 数据库 存储库（即数据文件）中\nF.Data Recovery Advisor (DRA) 是一个诊断工具，用于自动检测、分析持久性故障，并建议修复方案。DRA 的工作流程和诊断信息（如故障、修复建议）都依赖于从 ADR 中收集的元数据和详细信息。"
},
{
  "QuestionID": 93,
  "QuestionType": "multiple",
  "QuestionText": "The HR_ROOT application container must support the execution of a query on a table shared by application local PDBs PDB1 and PDB2, and remote PDB PDB3. Which three are true? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "A proxy PDB must exist in the application root in the remote CDB."},
    {"label": "B", "text": "A database link must exist in the local CDB root referring to the remote CDB."},
    {"label": "C", "text": "PDB3's application root replica must exist in the local CDB."},
    {"label": "D", "text": "A database link must exist in the remote CDB referring to the local CDB."},
    {"label": "E", "text": "The HR_ROOT replica must exist in the remote CDB."},
    {"label": "F", "text": "A proxy PDB must exist in the application root in the local CDB."}
  ],
  "CorrectAnswer": ["B", "E", "F"],
  "Explanation": "当一个应用程序容器 (如 HR_ROOT) 需要在一个 CDB (Container Database) 中查询另一个 远程 CDB 中的数据时，它需要使用一种称为跨 CDB 应用程序复制 (Cross-CDB Application Replication) 的技术，并结合数据库链接和代理 PDB 实现\n1.应用程序根复制 (Application Root Replica):要使本地 CDB 的应用程序根 HR_ROOT 能够识别和管理远程 CDB 上的应用数据，它必须在远程 CDB 中有一个副本\n2.数据库链接 (Database Link):为了实现两个 CDB 之间的数据通信和访问，必须建立一个连接通道,数据库链接必须建立在本地 CDB 的根容器 (CDB Root) 中，并指向远程 CDB 的根容器\n3.代理 PDB (Proxy PDB):在本地应用程序容器中，需要一个特殊的插拔式数据库 (PDB) 来代表远程 CDB 中的应用程序容器副本,这个代理 PDB 充当了远程应用程序副本的本地占位符,查询将通过这个代理 PDB 和数据库链接被路由到远程 CDB"
},
{
  "QuestionID": 94,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about poorly performing SQL statements and their tuning in Oracle database instances? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "SQL statements performing many physical I/Os can always have their performance improved by creating indexes."},
    {"label": "B", "text": "SQL statements doing only logical reads never require tuning because they do no physical I/O."},
    {"label": "C", "text": "The solution that best optimizes one SQL statement can degrade the performance of others."},
    {"label": "D", "text": "SQL statements doing joins always do more physical I/O than single table queries."},
    {"label": "E", "text": "Poorly performing SQL statements can be tuned automatically by the Oracle server."}
  ],
  "CorrectAnswer": ["C", "E"],
  "Explanation": "A.并非所有物理 I/O 问题都可以通过索引解决,如果查询需要访问表中的大量数据（例如，访问超过 15%-20% 的行），全表扫描 (Full Table Scan) 可能比使用索引更快，因为避免了多次单块读取的开销,I/O 问题也可能是由于存储配置、OS 级缓存或磁盘阵列性能不佳造成的，这些情况创建索引也无法解决\nB.逻辑读取 (Logical Reads) 表示从数据库缓存（SGA 中的 Buffer Cache）中读取数据块。即使没有物理 I/O，过多的逻辑读取也会导致\n--CPU 使用率过高:数据库需要消耗 CPU 来处理这些逻辑 I/O 和管理内存\n--缓存争用:大量的逻辑 I/O 会导致缓存中的块快速被老化和替换，引发闩锁 (latch) 或互斥体 (mutex) 争用，这会严重影响并发性能。因此，减少逻辑读取是 SQL 调优的一个重要目标。\nC.例如，为一个特定的复杂查询创建的新索引可以极大地提高该查询的性能。然而，这个新索引会增加数据操纵语言 (DML) 操作（如 INSERT、UPDATE、DELETE）的开销，因为每次数据更改时都必须维护索引，从而降低了 DML 语句的性能。因此，调优总是一个权衡的过程\nD.物理 I/O 的数量取决于查询访问的数据量，而不是联接操作本身,一个联接查询如果使用了高效的索引并且只返回少数几行，其物理 I/O 可能远少于一个对巨大单表进行全表扫描的查询\nE.自动 SQL 调优任务 (Automatic SQL Tuning Task)：这是一个维护窗口任务，它会自动识别性能不佳的 SQL 语句，并运行 SQL 调优顾问 (SQL Tuning Advisor, STA) 来生成调优建议（如创建索引、修改统计信息、创建 SQL 配置文件等）。SQL 配置文件 (SQL Profile)：这是 STA 生成的调优建议之一，它可以自动应用于性能不佳的 SQL 语句，使其使用更优的执行计划"
},
{
  "QuestionID": 95,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about Rapid Home Provisioning of Oracle software? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It can be used for applications and middleware."},
    {"label": "B", "text": "It can be used only for Oracle Grid Infrastructure, excluding Oracle Restart."},
    {"label": "C", "text": "It can be used only for Oracle Grid Infrastructure, including Oracle Restart."},
    {"label": "D", "text": "It can be used for both Oracle Database and Oracle Grid Infrastructure, including Oracle Restart."},
    {"label": "E", "text": "It can be used for both Oracle Database and Oracle Grid Infrastructure, excluding Oracle Restart."}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": "Rapid Home Provisioning (RHP) 是 Oracle Clusterware 的一项功能，它提供了一个集中的、自动化的框架，用于管理和部署 Oracle 软件映像（Software Images）\nRHP 允许管理员在共享存储上集中存储 Oracle Database、Oracle Grid Infrastructure、Oracle Restart、应用程序和中间件的黄金映像（Golden Images）,它能够快速地将这些黄金映像部署到集群节点或单实例服务器上,RHP 极大地简化了打补丁（Patching）、升级和回滚操作，通过管理和分发新的或更新的软件映像来完成\n"
},
{
  "QuestionID": 96,
  "QuestionType": "multiple",
  "QuestionText": "Your database is in ARCHIVELOG mode and you plan to use Flashback Database. Which two features or parameters manage space availability in the fast recovery area? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "the archived log deletion policy"},
    {"label": "B", "text": "the backup optimization policy"},
    {"label": "C", "text": "the backup retention policy"},
    {"label": "D", "text": "using guaranteed UNDO retention"},
    {"label": "E", "text": "the DB_CREATE_ONLINE_LOG_DEST_n parameter setting"},
    {"label": "F", "text": "the DB_RECOVERY_FILE_DEST parameter setting"}
  ],
  "CorrectAnswer": ["A", "C"],
  "Explanation": "数据库处于 ARCHIVELOG 模式，并且计划使用 Flashback Database。这意味着 Oracle 会在 快速恢复区（Fast Recovery Area, FRA） 中存储 闪回日志（flashback logs） 和 归档日志（archived redo logs）。为了保证这些功能正常工作，需要管理 FRA 的空间。\nA.Archived log deletion policy归档日志删除策略:控制何时可以从 FRA 删除归档日志。可以根据备份或保留策略自动释放 FRA 空间。\nB.Backup optimization policy备份优化策略:用于跳过未改变的文件备份，不直接管理 FRA 空间\nC.Backup retention policy备份保留策略:控制备份的保留时间，间接影响 FRA 空间，因为过期备份可以被删除\nD.Using guaranteed UNDO retention保证 UNDO保留:针对 UNDO 表空间的策略，不管理FRA空间\nE.DB_CREATE_ONLINE_LOG_DEST_n 参数:这是设置联机 redo 日志文件位置的参数，不管理 FRA\nF.DB_RECOVERY_FILE_DEST 参数:这个是设置 FRA 的位置，不直接管理空间 "
},
{
  "QuestionID": 97,
  "QuestionType": "multiple",
  "QuestionText": "Which two are true about Oracle Database Configuration Assistant (DBCA)? (Choose two.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "It can be launched from both the command line and the Universal Installer (OUI) interfaces."},
    {"label": "B", "text": "It can be used to change the character set of an existing database."},
    {"label": "C", "text": "It can be used to convert a non-container database to a container database."},
    {"label": "D", "text": "It can be used to create container databases and non-container databases."},
    {"label": "E", "text": "It can only be launched from the command line interface."}
  ],
  "CorrectAnswer": ["A", "D"],
  "Explanation": "AE.DBCA 是一个图形化（GUI）工具，但它也可以在静默（Silent）模式下通过命令行（Command Line）运行，通常是执行 dbca 命令。在安装 Oracle 软件时，也可以通过 Universal Installer (OUI) 界面选择运行 DBCA 来创建初始数据库。因此，它支持图形界面和命令行两种启动方式。\nB.DBCA 不能用于更改现有数据库的字符集,DBCA 的主要功能是创建、配置（如配置组件、管理选项）、删除和管理模板。\nC.DBCA 不能直接执行“非容器数据库”到“容器数据库”的转换。转换过程实际上是将一个 Non-CDB “插拔 (Plug)” 到一个新的 CDB 中，使其成为一个新的 可插拔数据库 (PDB)。这个过程通常涉及 DBMS_PDB 包、noncdb_to_pdb.sql 脚本或使用 AutoUpgrade 工具，而不是 DBCA 的核心功能\nD.BCA 是创建多租户容器数据库（CDB）的主要工具,DBCA 仍然提供了创建传统独立数据库（Non-CDB）的选项，通常是在“Database Identification”步骤中取消勾选“Create as Container database”选项"
},
{
  "QuestionID": 98,
  "QuestionType": "multiple",
  "QuestionText": "Which three are performed by Oracle Automatic Storage Management (ASM) instances? (Choose three.)",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "mounting disk groups"},
    {"label": "B", "text": "managing Allocation Units (AUs) for disk group content"},
    {"label": "C", "text": "managing extent allocation for Oracle database segments"},
    {"label": "D", "text": "acting as an I/O server to write data file blocks to ASM disks on behalf of Database Writer processes (DBWn)"},
    {"label": "E", "text": "managing space allocation for Oracle ASM files"},
    {"label": "F", "text": "acting as an I/O server to read data file blocks from ASM disks on behalf of database server processes"}
  ],
  "CorrectAnswer": ["A", "B", "E"],
  "Explanation": "Oracle Automatic Storage Management (ASM) 实例是一个轻量级、专门的 Oracle 实例，它不包含用户表和数据，其主要职责是管理数据库的存储元数据并为数据库实例提供存储服务\n主要功能:\n1.磁盘组（Disk Group）管理:挂载与卸载磁盘组 (Mount/Dismount Disk Groups),数据库 (datafiles)、控制文件 (control files)、日志文件 (redo/undo logs)、归档日志 (archive logs)、备份 (RMAN backups) 等都可以存放在这些磁盘组里\n2.ASM Instance (ASM 实例)：ASM 有自己的实例 (instance)，类似于数据库实例，但轻量很多，仅负责存储管理 (metadata + IO 管理)，不处理 SQL\n3.SM Files：存放在 disk groups 中的文件 (datafiles, redo logs, control files 等) 被称为 ASM 文件。ASM 管理这些文件的命名、分布、分配，不要 DBAs 手动处理底层路径。\n\nB.Allocation Unit (AU) 是 Oracle Automatic Storage Management (ASM) 中分配存储的最小基本单位。ASM 通过管理 AU 来实现其高性能、高可用性和灵活性的存储管理目标,ASM 文件（如数据文件）的空间是以 Extent 为单位分配的。一个 Extent 由一个或多个 AU 组成,ASM 实例负责 AU 内容的动态管理，其核心是自动条带化 (Striping)、镜像 (Mirroring) 和重平衡 (Rebalancing)。\nC.extent分配由数据库实例管理（如段空间管理），与 ASM 无关,\nDF.分别是后台进程和服务器进程,不是 ASM实例"
},
{
  "QuestionID": 99,
  "QuestionType": "single",
  "QuestionText": "Your CDB has two regular PDBs as well as one application container with two application PDBs and an application seed. No changes have been made to the standard PDB$SEED. How many default temporary tablespaces can be assigned in the CDB?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "six"},
    {"label": "B", "text": "seven"},
    {"label": "C", "text": "five"},
    {"label": "D", "text": "eight"},
    {"label": "E", "text": "three"}
  ],
  "CorrectAnswer": ["D"],
  "Explanation": "根据 Oracle 的多租户（Multitenant）架构规则，可以分配的默认临时表空间数量取决于所有可用的容器（Container）和种子（Seed）的数量。可以分配默认临时表空间的容器总数是:\n1.CDB Root ($CDB): 1 个\n2.常规 PDB: 2 个\n3.常规 PDB Seed (PDB$SEED): 1 个\n4.应用容器 Root (Application Root): 1 个\n5.应用 PDB: 2 个\n6.应用种子 (Application Seed): 1 个"
},
{
  "QuestionID": 100,
  "QuestionType": "single",
  "QuestionText": "Application PDBs, SALES_APP1 and SALES_APP2, must be created and they must access common tables of the SALES_APP application.Examine these steps:\n1. Install the SALES_APP application, including the common tables, in the application root.\n2. Install the SALES_APP application in the application root and the common tables in both the CDB root and the application root.\n3. Create an application seed.\n4. Install the SALES_APP application in the application seed.\n5. Create the SALES_APP1 and SALES_APP2 application PDBs.\n6. Sync the SALES_APP1 and SALES_APP2 application PDBs with the application root.\n7. Sync the SALES_APP1 and SALES_APP2 application PDBs with the application seed.\n8. Sync the application seed with the application root.\n Which are the minimum required steps in the correct sequence?",
  "ImageURL": "",
  "Options": [
    {"label": "A", "text": "3, 4, 1, 6, 8"},
    {"label": "B", "text": "2, 5, 6"},
    {"label": "C", "text": "1, 5, 6"},
    {"label": "D", "text": "1, 3, 5, 6, 7"},
    {"label": "E", "text": "1, 3, 5, 7"}
  ],
  "CorrectAnswer": ["C"],
  "Explanation": "要创建两个 应用 PDB：SALES_APP1 和 SALES_APP2,它们都属于一个 Sales Application Container（SALES_APP）,在 SALES_APP 容器里定义了一些 所有应用 PDB 都可以共享的表（common tables）。这两个 PDB (SALES_APP1 和 SALES_APP2) 都能读写这些公共表，而每个 PDB 也可以有自己的私有表。\n\n1.这是必需的第一步。Common表，即所有应用 PDB 共享且只读的元数据和数据，必须安装在 应用根容器 (Application Root) 中\n5.这是必需的下一步。创建应用 PDBs 是为了提供应用运行所需的隔离和专用环境\n6.这是必需的最后一步。要使新创建的 应用 PDBs 能够访问应用根容器中的 公共表，它们需要与应用根容器同步。同步操作确保应用 PDBs 接收到应用根容器中应用（SALES_APP）的所有定义，包括对公共表的访问权限\n\n2.错误,公共表只需要安装在应用根容器中，不需要安装在 CDB 根容器中\n3.4.(创建和安装应用种子): 不是必需.应用种子 (Application Seed) 只是一个可选项，用于优化后续应用 PDB 的创建速度。如果直接从应用根容器创建 PDB，可以省略这一步\n7.8.与应用种子同步: 不是必需的,只有在应用种子被用于创建 PDB,或者应用种子本身需要更新时才需要执行"
}



      ]
    }
  ],

  "users": [
    {
      "UserID": 1,
      "Username": "",
      "LastLogin": "",
      "RememberMe": false
    }
  ],

  "userProgress": [
    {
      "UserID": 1,
      "SubjectID": 1,
      "CompletedQuestions": [],
      "CurrentQuestionIndex": 0,
      "CorrectCount": 0,
      "WrongCount": 0
    }
  ],

  "userMistakes": [
    {
      "UserID": 1,
      "SubjectID": 1,
      "WrongQuestions": []
    }
  ]
}